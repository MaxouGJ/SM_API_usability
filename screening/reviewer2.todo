Authors $ Title $ Abstract
"Song F., Touili T." $ "Model-checking software library API usage rules" $ "Modern software increasingly relies on using third-party libraries which are accessed via application programming interfaces (APIs). Libraries usually impose constraints on how API functions can be used (API usage rules) and programmers have to obey these API usage rules. However, API usage rules often are not well documented or documented informally. In this work, we show how to use the SCTPL and SLTPL logics to precisely and formally specify API usage rules in libraries, where SCTPL/SLTPL can be seen as an extension of the branching/linear temporal logic CTL/LTL with variables, quantifiers and predicates over the stack. This allows library providers to formally describe API usage rules without knowing how their libraries will be used by programmers. We propose an automated approach to check whether programs using libraries violate API usage rules or not. Our approach consists in modeling programs as pushdown systems (PDSs) and checking API usage rules by SCTPL/SLTPL model-checking for PDSs. To make the model-checking procedure more efficient and precise, we propose an abstraction that reduces drastically the size of the program model and integrate may-alias analysis into our approach to reduce false alarms. Moreover, we characterize two sublogics rSCTPL and rSLTPL of SCTPL and SLTPL that are preserved by the abstraction. We implement our techniques in a tool and apply the tool to check several open-source programs. Our tool finds several previously unknown bugs in several programs. The may-alias analysis avoids most of the false alarms that occur using SCTPL or SLTPL model-checking techniques without may-alias analysis. © 2015, Springer-Verlag Berlin Heidelberg."
"Suro F., Ono Y." $ "Japanese EFL learners' uses of text-to-speech technology and their learning behaviors: A pilot study" $ "The purpose of this study is to show how EFL learners work on Text-to-speech (TTS) technology to improve their speaking accuracy. We constructed the system for improving speaking proficiency based on Web-Speech API. Usually, text-to-speech is available on the net or by using TTS applications in education. However, these sounds produced are not generally customized to the diversity of learners' learning strategies. The system constructed in the study makes it possible for learners to choose the words, phrases sentences or the passage they like to listen to for their speaking practice. Major findings that came out from this study are: (i) As to the easier materials, accuracy improvement was observed regardless of their proficiency, (ii) On the contrary, as to the difficult materials, such an improvement was not observed in the experiment, and (iii) there is diversity of how they worked on the system, and there are some patterns in their learning behaviors, Bottom-uppers and Top-downers. These findings suggest the usefulness of the current system for various types of learners in terms of learning strategies and a future possibility from a learning analytic point of view to modify the system. © 2016 IEEE."
"Acar Y., Backes M., Fahl S., Kim D., Mazurek M.L., Stransky C." $ "You Get Where You're Looking for: The Impact of Information Sources on Code Security" $ "Vulnerabilities in Android code - including but not limited to insecure data storage, unprotected inter-component communication, broken TLS implementations, and violations of least privilege - have enabled real-world privacy leaks and motivated research cataloguing their prevalence and impact. Researchers have speculated that appification promotes security problems, as it increasingly allows inexperienced laymen to develop complex and sensitive apps. Anecdotally, Internet resources such as Stack Overflow are blamed for promoting insecure solutions that are naively copy-pasted by inexperienced developers. In this paper, we for the first time systematically analyzed how the use of information resources impacts code security. We first surveyed 295 app developers who have published in the Google Play market concerning how they use resources to solve security-related problems. Based on the survey results, we conducted a lab study with 54 Android developers (students and professionals), in which participants wrote security-and privacy-relevant code under time constraints. The participants were assigned to one of four conditions: free choice of resources, Stack Overflow only, official Android documentation only, or books only. Those participants who were allowed to use only Stack Overflow produced significantly less secure code than those using, the official Android documentation or books, while participants using the official Android documentation produced significantly less functional code than those using Stack Overflow. To assess the quality of Stack Overflow as a resource, we surveyed the 139 threads our participants accessed during the study, finding that only 25% of them were helpful in solving the assigned tasks and only 17% of them contained secure code snippets. In order to obtain ground truth concerning the prevalence of the secure and insecure code our participants wrote in the lab study, we statically analyzed a random sample of 200,000 apps from Google Play, finding that 93.6% of the apps used at least one of the API calls our participants used during our study. We also found that many of the security errors made by our participants also appear in the wild, possibly also originating in the use of Stack Overflow to solve programming problems. Taken together, our results confirm that API documentation is secure but hard to use, while informal documentation such as Stack Overflow is more accessible but often leads to insecurity. Given time constraints and economic pressures, we can expect that Android developers will continue to choose those resources that are easiest to use, therefore, our results firmly establish the need for secure-but-usable documentation. © 2016 IEEE."
"Landhäußer M., Weigelt S., Tichy W.F." $ "NLCI: a natural language command interpreter" $ "Natural language interfaces are becoming more and more common, because they are powerful and easy to use. Examples of such interfaces are voice controlled navigation devices, Apple’s personal assistant Siri, Google Voice Search, and translation services. However, such interfaces are extremely difficult to build, to maintain, and to port to new domains. We present an approach for building and porting such interfaces quickly. NLCI is a natural language command interpreter that accepts action commands in English and translates them into executable code. The core component is an ontology that models an API. Once the API is “ontologized”, NLCI translates input sentences into sequences of API calls that implement the intended actions. Two radically different APIs were ontologized: openHAB for home automation and Alice for building 3D animations. Construction of the ontology can be automated if the API uses descriptive names for its components. In that case, the language interface can be generated completely automatically. Recall and precision of NLCI on a benchmark of 50 input scripts are 67 and 78 %, resp. Though not yet acceptable for practical use, the results indicate that the approach is feasible. NLCI accepts typed input only. Future work will use a speech front-end to test spoken input. © 2016 Springer Science+Business Media New York,End-user programming, Knowledge-based software engineering, Natural language processing for software engineering, Program synthesis, Programming in natural language"
"Pathirage M., Hyde J., Pan Y., Plale B." $ "SamzaSQL: Scalable fast data management with streaming SQL" $ "As the data-driven economy evolves, enterprises have come to realize a competitive advantage in being able to act on high volume, high velocity streams of data. Technologies such as distributed message queues and streaming processing platforms that can scale to thousands of data stream partitions on commodity hardware are a response. However, the programming API provided by these systems is often low-level, requiring substantial custom code that adds to the programmer learning curve and maintenance overhead. Additionally, these systems often lack SQL querying capabilities that have proven popular on Big Data systems like Hive, Impala or Presto. We define a minimal set of extensions to standard SQL for data stream querying and manipulation. These extensions are prototyped in SamzaSQL, a new tool for streaming SQL that compiles streaming SQL into physical plans that are executed on Samza, an open-source distributed stream processing framework. We compare the performance of streaming SQL queries against native Samza applications and discuss usability improvements. SamzaSQL is a part of the open source Apache Samza project and will be available for general use. © 2016 IEEE."
"Saied M.A., Sahraoui H." $ "A cooperative approach for combining client-based and library-based API usage pattern mining" $ "Software developers need to cope with the complexity of Application Programming Interfaces (APIs) of external libraries or frameworks. Typical APIs provide thousands of methods to their client programs, and these methods are not used independently of each other. Much existing work has provided different techniques to mine API usage patterns based on client programs in order to help developers understanding and using existing libraries. Other techniques propose to overcome the strong constraint of clients' dependency and infer API usage patterns only using the library source code. In this paper, we propose a cooperative usage pattern mining technique (COUPminer) that combines client-based and library-based usage pattern mining. We evaluated our technique through four APIs and the obtained results show that the cooperative approach allows taking advantage at the same time from the precision of client-based technique and from the generalizability of library-based techniques. © 2016 IEEE."
"Fleureau J., Galvane Q., Tariolle F.-L., Guillotel P." $ "Generic drone control platform for autonomous capture of cinema scenes" $ "The movie industry has been using Unmanned Aerial Vehicles as a new tool to produce more and more complex and aesthetic camera shots. However, the shooting process currently rely on manual control of the drones which makes it difficult and sometimes inconvenient to work with. In this paper we address the lack of autonomous system to operate generic rotary-wing drones for shooting purposes. We propose a global control architecture based on a high-level generic API used by many UAV. Our solution integrates a compound and coupled model of a generic rotary-wing drone and a Full State Feedback strategy. To address the specific task of capturing cinema scenes, we combine the control architecture with an automatic camera path planning approach that encompass cinematographic techniques. The possibilities offered by our system are demonstrated through a series of experiments. © 2016 Copyright held by the owner/author(s)."
"Weidner O., Atkinson M., Barker A., Vicente R.F." $ "Rethinking high performance computing platforms: Challenges, opportunities and recommendations" $ "A growing number of ""second generation"" high-performance computing applications with heterogeneous, dynamic and data-intensive properties have an extended set of requirements, which cover application deployment, resource allocation, -control, and I/O scheduling. These requirements are not met by the current production HPC platform models and policies. This results in a loss of opportunity, productivity and innovation for new computational methods and tools. It also decreases effective system utilization for platform providers due to unsupervised workarounds and ""rogue"" resource management strategies implemented in application space. In this paper we critically discuss the dominant HPC platform model and describe the challenges it creates for second generation applications because of its asymmetric resource view, interfaces and software deployment policies. We present an extended, more symmetric and application-centric platform model that adds decentralized deployment, introspection, bidirectional control and information flow and more comprehensive resource scheduling. We describe cHPC: an early prototype of a non-disruptive implementation based on Linux Containers (LXC). It can operate alongside existing batch queuing systems and exposes a symmetric platform API without interfering with existing applications and usage modes. We see our approach as a viable, incremental next step in HPC platform evolution that benefits applications and platform providers alike. To demonstrate this further, we layout out a roadmap for future research and experimental evaluation. © 2016 ACM."
"Gurram B., Giri N." $ "Improving localization accuracy of android's Fused Location Provider API using Kalman Filter" $ "This paper intends to improve the location accuracy of Google's Fused Location Provider API, for android handheld device using Kalman Filter. Since the Fused Location Provider was built for managing the battery and accuracy tradeoff between GPS provider and Network Provider, the estimate is likely to be noisy and the track obtained contains jumps. So by using Kalman filter, the jumps can be devoid, and a smooth track can be obtained. A real time experiment is carried out to check the improvements. The results show that the proposed location path is smoother than the path travelled using the conventional Fused Location Provider API. © 2016 IEEE."
"Mindermann K." $ "Are easily usable security libraries possible and how should experts work together to create them?" $ "Due to non-experts also developing security relevant applications it is necessary to support them too. Some improvements in the current research may not reach or impact these developers. Nonetheless these developers use security libraries. There are findings that even their usage is not easily possible and applications are left vulnerable to supposedly treated threats. So it is important to improve the usability of the security libraries. This is itself is not straightforward because of a required maturing process for example. By get- ting together experts of different involved areas, especially cryptographic and API-usability experts, both of the problems can be tackled. © 2016 ACM."
"Wu N., Hou D., Liu Q." $ "Linking usage tutorials into API client code" $ "Traceability links between software artifacts have important applications in the development process. This paper concerns a special case of traceability recovery, i.e., the automated integration of API usage tutorials with the API client code. Our solution involves partitioning the client code into multiple semantic groups/snippets and linking each snippet to the best matching tutorials. Evaluation using benchmarks created for two popular APIs reveals that our solution can find the expected tutorial links at the average rank of 1.6 and 1.4 in the top ranked results, for the two API's, respectively, and with good average precision and recall. We also evaluate the impact of both method partitioning and JavaDoc query expansion on tutorial linking performance. Lastly, we conduct a formative user study to pinpoint the scenarios where our solution actually helps a software developer. We conclude that it is a promising approach to speeding up the maintenance of API client code. © 2016 ACM."
"Fysarakis K., Mylonakis D., Manifavas C., Papaefstathiou I." $ "Node.DPWS: Efficient Web Services for the Internet of Things" $ "Interconnected computing systems in various forms will soon permeate our lives, realizing the Internet of Things (IoT) and letting us enjoy novel, enhanced services that promise to improve our everyday life. Nevertheless, this new reality introduces significant challenges in terms of performance, scaling, usability, and interoperability. Leveraging the benefits of service-oriented architectures (SOAs) can help alleviate many of the issues that developers, implementers, and users alike must face in the context of the IoT. Node.DPWS is a novel implementation of the Devices Profile for Web Services (DPWS) based on the Node.js platform. It comprises the first set of DPWS libraries available to Node.js developers and can be used to deploy lightweight, efficient, and scalable Web services over heterogeneous nodes, including devices with limited resources. A performance evaluation on typical embedded devices validated the benefits of Node.DPWS compared to alternative DPWS libraries. © 2016 IEEE."
"Tsai C.-C., Jain B., Abdul N.A., Porter D.E." $ "A study of modern Linux API usage and compatibility: What to support when you're supporting" $ "This paper presents a study of Linux API usage across all applications and libraries in the Ubuntu Linux 15.04 distribution. We propose metrics for reasoning about the importance of various system APIs, including system calls, pseudo-files, and libc functions. Our metrics are designed for evaluating the relative maturity of a prototype system or compatibility layer, and this paper focuses on compatibility with Linux applications. This study uses a combination of static analysis to understand API usage and survey data to weight the relative importance of applications to end users. This paper yields several insights for developers and researchers, which are useful for assessing the complexity and security of Linux APIs. For example, every Ubuntu installation requires 224 system calls, 208 ioctl, fcntl, and prctl codes and hundreds of pseudo files. For each API type, a significant number of APIs are rarely used, if ever. Moreover, several security-relevant API changes, such as replacing access with faccessat, have met with slow adoption. Finally, hundreds of libc interfaces are effectively unused, yielding opportunities to improve security and efficiency by restructuring libc. Copyright © 2016 held by owner/author(s)."
"Ali-Gombe A., Ahmed I., Richard G.G., III, Roussev V." $ "AspectDroid: Android app analysis system" $ "The growing threat to user privacy related to Android applications (apps) has tremendously increased the need for more reliable and accessible app analysis systems. This paper presents AspectDroid, an application-level system designed to investigate Android applications for possible unwanted activities. AspectDroid is comprised of app instrumentation, automated testing and containment systems. By using static bytecode instrumentation, AspectDroid weaves monitoring code into an existing application and provides data flow and sensitive API usage as well as dynamic instrumentation capabilities. The newly repackaged app is then executed either manually or via an automated testing module. Finally, the flexible containment provided by AspectDroid adds a layer of protection so that malicious activities can be prevented from affecting other devices. The accuracy score of Aspect Droid when tested on 105 DroidBench corpus shows it can detect tagged data with 95.29%. We further tested our system on 100 real malware families from the Drebin dataset [1]. The result of our analysis showed AspectDroid incurs approximately 1MB average total memory size overhead and 5.9% average increase in CPU-usage."
"Mani S., Padhye R., Sinha V.S." $ "Mining API expertise profiles with Partial Program Analysis" $ "A developer's API usage expertise can be estimated by analyzing source code that they have checked-in to a software repository. In prior work we proposed a system for creating a social network of developers centered around the APIs they use in order to recommend people and projects they might be interested in. The implementation of such a system requires analyzing code from repositories of large numbers of projects that use different build systems. Hence, one challenge is to determine the APIs referenced in code in these repositories without relying on the ability to resolve every project's external dependencies. In this paper, we consider a technique called Partial Program Analysis for resolving type bindings in Java source code in the absence of third-party library binaries. Another important design decision concerns the approach of associating such API references with the developers who authored them such as walking entire change history or use blame information. We evaluate these different design options on 4 open-source Java projects and found that both Partial Program Analysis and blame-based approach provide precision greater than 80%. However, use of blame as opposed to complete program history leads to significant recall loss, in most cases greater than 40%. © 2016 ACM."
"Nguyen T.T., Pham H.V., Vu P.M., Nguyen T.T." $ "Recommending API usages for mobile apps with hidden Markov model" $ "Mobile apps often rely heavily on standard API frameworks and libraries. However, learning to use those APIs is often challenging due to the fast-changing nature of API frameworks and the insufficiency of documentation and code examples. This paper introduces DroidAssist, a recommendation tool for API usages of Android mobile apps. The core of DroidAssist is HAPI, a statistical, generative model of API usages based on Hidden Markov Model. With HAPIs trained from existing mobile apps, DroidAssist could perform code completion for method calls. It can also check existing call sequences to detect and repair suspicious (i.e. unpopular) API usages. © 2015 IEEE."
"Suter P., Wittern E." $ "Inferring web API descriptions from usage data" $ "We describe a set of techniques to infer structured descriptions of web APIs from usage examples. Using trained classifiers, we identify fixed and variable segments in paths, and tag parameters according to their types. We implemented our techniques and evaluated their precision on 10 APIs for which we obtained: 1) descriptions, manually written by the API maintainers, and 2) server logs of the API usage. Our experiments show that our system is able to reconstruct the structure of both simple and complex web API descriptions, outperforming an existing tool with similar goals. Finally, we assess the impact of noise in the input data on the results of our method. © 2015 IEEE."
"Neville D., Malton A., Brain M., Kroening D." $ "Towards automated bounded model checking of API implementations" $ "We introduce and demonstrate the viability of a novel technique for verifying that implementations of application program interfaces (APIs) are bug free. Our technique applies a new abstract interpretation to extract an underlying model of API usage, and then uses this to synthesise a set of verifiable program fragments. These fragments are evaluated using CBMC and any potentially spurious property violation is presented to a domain expert user. The user's response is then used to refine the underlying model of the API to eliminate false positives. The refinement-analysis process is repeated iteratively. We demonstrate the viability of the technique by showing how it can find an integer underflow within Google's Brotli, an underflow that has been shown to lead directly to allow remote attackers to execute arbitrary code in CVE 2016-1968. © 2016, CEUR-WS. All rights reserved."
"Rossi D." $ "UML-based model-driven REST API development" $ "In the last few years we have witnessed the expansion of REST APIs as a method to implement machineto-machine interactions in open distributed systems. Recently REST APIs can also be found in several B2B and enterprise scenarios that were previously reserved to alternative technologies such as SOAP-based Web Services. Despite that, the development of REST-based solutions has remained mostly inspired by agile approaches with no or limited explicit modeling artifacts produced during the development process. This clashes with software development methods in which modeling artifacts are expected to be available for all developed software. Another problem is related to the resource-based nature of these APIs that miss standardized methods to discover and understand their capabilities akin to what object-oriented interfaces can do for objects and services. In this paper we propose a model-driven approach to REST API development, this approach is composed by two main steps: (i) UML modeling of the API using specific profiles and (ii) a model transformation that exploits RAML, a recent RESTful API modeling language, as an intermediate notation that can be used to automatically produce documentation and code for various languages/platforms. Copyright © 2016 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved."
"Hasegawa K., Kanayama N., Nishide T., Okamoto E." $ "Software library for ciphertext/key-policy functional encryption with simple usability" $ "In traditional public key encryption schemes, data encrypted by a public key pk can be decrypted only by a secret key sk corresponding to pk, and the relation between pk and sk is static. Therefore, the schemes are unsuitable for control of access to a single data by several users. Meanwhile, functional encryption (FE) is an encryption scheme that provides more sophisticated and flexible relations between pk and sk. Thus, FE enables only one pk to encrypt the data with any conditions for decryption, so it is considered a very useful tool for the access control of data on the cloud server. However, implementing the current FE scheme is a non-trivial task because the deep knowledge of the scheme is required. This is an obstacle factor to deploy the FE scheme in the real-world security systems. In this paper, we propose an implementation of the FE (Ciphertext-Policy FE and Key-Policy FE, which are useful classes of FE) library usable even for people who do not have the deep knowledge of these schemes. © 2016 Information Processing Society of Japan."
"Li B., Zhang Y., Lyu C., Li J., Gu D." $ "SSG: Sensor security guard for android smartphones" $ "The smartphone sensors provide extraordinary user experience in various Android apps, e.g. sport apps, gravity sensing games. Recent works have been proposed to launch powerful sensor-based attacks such as location tracing and sound eavesdropping. The use of sensors does not require any permission in Android apps, so these attacks are very difficult to be noticed by the app users. Furthermore, the combination of various kinds of sensors generates numerous types of attacks which are hard to be systematically studied. To better address the attacks, we have developed a taxonomy on sensor-based attacks from five aspects. In this work, we propose a sensor API hooking and information filtering framework, Sensor Security Guard (SSG). Unlike any rough hooking framework, this system provides finegrained processing for different security levels set by the users, or by default. The sensor data is blocked, forged or processed under different mode strategies and then returned to the apps. In addition, according to the taxonomy, SSG develops fine-grained corresponding countermeasures. We evaluate the usability of SSG on 30 popular apps chosen from Google Market. SSG does not cause any crash of either the Android system or the apps while working. The result indicated that SSG could significantly preserve the users’ privacy with acceptable energy lost. © Institute for Computer Sciences, Social Informatics and Telecommunications Engineering 2016."
"Wu W., Khomh F., Adams B., Guéhéneuc Y.-G., Antoniol G." $ "An exploratory study of api changes and usages based on apache and eclipse ecosystems" $ "Frameworks are widely used in modern software development to reduce development costs. They are accessed through their Application Programming Interfaces (APIs), which specify the contracts with client programs. When frameworks evolve, API backward-compatibility cannot always be guaranteed and client programs must upgrade to use the new releases. Because framework upgrades are not cost-free, observing API changes and usages together at fine-grained levels is necessary to help developers understand, assess, and forecast the cost of each framework upgrade. Whereas previous work studied API changes in frameworks and API usages in client programs separately, we analyse and classify API changes and usages together in 22 framework releases from the Apache and Eclipse ecosystems and their client programs. We find that (1) missing classes and methods happen more often in frameworks and affect client programs more often than the other API change types do, (2) missing interfaces occur rarely in frameworks but affect client programs often, (3) framework APIs are used on average in 35 % of client classes and interfaces, (4) most of such usages could be encapsulated locally and reduced in number, and (5) about 11 % of APIs usages could cause ripple effects in client programs when these APIs change. Based on these findings, we provide suggestions for developers and researchers to reduce the impact of API evolution through language mechanisms and design strategies. © 2015 Springer Science+Business Media New York,API changes, API usages, Data mining, Empirical study, Framework ecosystems, Framework evolution"
"Zou Y.R., Mustafa N., Memon N.A., Eid M." $ "ECO ECO: Changing climate related behaviors for cellphone-based videogames" $ "Global climate change has become a major issue of today's human society. Since most of our human activity could potentially have big environmental impacts once accumulated, it is especially important that the public is educated with the environmental effects of their daily actions. This paper's main purpose is to propose a gamified system that leverages the high saturation of smartphones and the rising popularity of Internet of Things (IoT) to educate young children with environmental concepts as well as encouraging them to commit to real-life ""green habits"". An android mobile game Eco Eco was developed to demonstrate the concept and test the proposed system's effectiveness for young users. This Farmville-like game is played only by conducting real-life environmental activities like using a reusable water bottle, walking more steps instead of using cars, or reduce usage of household electricity. The game, developed with Unity3D utilizes the Google Fit API for step count, CloudSight API for image recognition and a connected smart device for monitoring energy usage. A preliminary user test was also conducted to improve the usability of the system as well as to test the effects of this system. © 2015 IEEE."
"Robillard M.P., Chhetri Y.B." $ "Recommending reference API documentation" $ "Reference documentation is an important source of information on API usage. However, information useful to programmers can be buried in irrelevant text, or attached to a non-intuitive API element, making it difficult to discover. We propose to detect and recommend fragments of API documentation potentially important to a programmer who has already decided to use a certain API element. We categorize text fragments in API documentation based on whether they contain information that is indispensable, valuable, or neither. From the fragments that contain knowledge worthy of recommendation, we extract word patterns, and use these patterns to automatically find new fragments that contain similar knowledge in unseen documentation. We implemented our technique in a tool, Krec, that supports both information filtering and discovery. In an evaluation study with randomly-sampled method definitions from ten open source systems, we found that with a training set derived from about 1000 documentation units, we could issue recommendations with 90 % precision and 69 % recall. In a study involving ten independent assessors, indispensable knowledge items recommended for API types were judged useful 57 % of the time and potentially useful an additional 30 % of the time. © 2014, Springer Science+Business Media New York."
"Saied M.A., Benomar O., Sahraoui H." $ "Visualization based API usage patterns refining" $ "Learning to use existing or new software libraries is a difficult task for software developers, which would impede their productivity. Most of existing work provided different techniques to mine API usage patterns from client programs, in order to help developers to understand and use existing libraries. However, considering only client programs to identify API usage patterns, is a strong constraint as collecting several similar client programs for an API is not a trivial task. And even if these clients are available, all the usage scenarios of the API of interest may not be covered by those clients. In this paper, we propose a visualization based approach for the refinement of Client-based Usage Patterns. We first visualize the patterns structure. Then we enrich the patterns with API methods that are semantically related to them, and thus may contribute together to the implementation of a particular functionality for potential client programs. © 2015 IEEE."
"Shugay M., Bagaev D.V., Turchaninova M.A., Bolotin D.A., Britanova O.V., Putintseva E.V., Pogorelyy M.V., Nazarov V.I., Zvyagin I.V., Kirgizova V.I., Kirgizov K.I., Skorobogatova E.V., Chudakov D.M." $ "VDJtools: Unifying Post-analysis of T Cell Receptor Repertoires" $ "Despite the growing number of immune repertoire sequencing studies, the field still lacks software for analysis and comprehension of this high-dimensional data. Here we report VDJtools, a complementary software suite that solves a wide range of T cell receptor (TCR) repertoires post-analysis tasks, provides a detailed tabular output and publication-ready graphics, and is built on top of a flexible API. Using TCR datasets for a large cohort of unrelated healthy donors, twins, and multiple sclerosis patients we demonstrate that VDJtools greatly facilitates the analysis and leads to sound biological conclusions. VDJtools software and documentation are available at https://github.com/mikessh/vdjtools. © 2015 Shugay et al."
"Li Q., Li X." $ "Android Malware Detection Based on Static Analysis of Characteristic Tree" $ "The number of mobile malware is greatly increasing and the malware detection malware has become a critical problem. Android is fast becoming the most popular mobile platform resulting in quick increase in malware targeting the platform. Current static-analysis practice on Android application package (APK) mainly uses the features such as signature, md5 hash, permissions, data flows, API (Application Programming Interface) calls and etc. Extracted from the manifest file and the code. Such features lack consideration on the APK code organizations and object hierarchy, and thus they may be ineffective in detecting and predicting an APK'S application behaviors and maliciousness. Our research aims to find and implement a novel API-usage characterization approach for Android APK on different layers of resolutions, namely packages, classes, functions and APIs. A tree structure called 'Characteristic Tree' is used to contain such API-usage information on different layers of the tree structure, and a comparison algorithm is designed for calculating characteristic-tree similarity. This new detection method detection provides more meticulous insights in classifying and detecting Android malware of different types and code families. The variations in API-usage on different code layers imply code functionalities and application behaviors, and thus they can be used to improve current static-analysis method in malware detection and signature generation. Realistic malware packet samples of various types and families were used to validate the proposed approach, and results were discussed for its performance and future improvement. © 2015 IEEE."
"[No author name available]" $ "DLS 2015 - Proceedings of the 11th Symposium on Dynamic Languages" $ "The proceedings contain 14 papers. The topics discussed include: from APIs to languages: generalizing method names, a formalization of typed Lua, gradual certified programming in coq, message safety in dart, control-flow analysis of dynamic languages via pointer analysis, compiling for multi-language task migration, high-performance cross-language interoperability in a multi-language runtime, Java-to-JavaScript translation via structured control flow reconstruction of compiler IR, language-independent storage strategies for tracing-JIT-based virtual machines, measuring polymorphism in python programs, tracking down performance variation against source code evolution, server-side type profiling for optimizing client-side JavaScript engines, and an empirical investigation of the effects of type systems and code completion on API usability using TypeScript and JavaScript in MS visual studio."
"Knodel O., Spallek R.G." $ "Computing framework for dynamic integration of reconfigurable resources in a cloud" $ "Integrating FPGAs into clouds or data centers allows easy access to such reconfigurable resources and provides a promising opportunity to improve both performance and energy efficiency of such systems. Although currently the use of FPGAs as hardware accelerators and especially in clouds is mainly a topic of research, the integration of reconfigurable virtualized resources will become a task of growing importance in the future. We developed a cloud management and hypervisor system called RC3E providing FPGA resources as a service. This paper introduces a computing framework which extends our hypervisor and allows multiple (virtual) user designs on a single physical FPGA. The communication between host and FPGA is implemented by a communication API on the host and the integration of high-level synthesis (HLS) to accelerate applications. We demonstrate the usability of our framework by implementing a sample user design on an FPGA and measuring the performance with up to four simultaneous virtual user designs. © 2015 IEEE."
"Cramer T., Dietrich R., Terboven C., Müller M.S., Nagel W.E." $ "Performance Analysis for Target Devices with the OpenMP Tools Interface" $ "The requirement for large compute capabilities led to a wide use of accelerated high performance computing systems. In order to lower the burden for programming these new architectures, user friendly programming paradigms like OpenACC and OpenMP have come to existence. They offer pragmas to shift effort from the programmer to the compiler and runtime system, particularly for data management. However, for further improvement of the usability an adequate tools support is required as well. In our work we present in detail a general extension to the upcoming OpenMP tools interface (OMPT) with respect to the new OpenMP 4.0 target constructs. This extension aims to be a portable, vendor- and platform independent interface to enable the use of performance analysis tools with OpenMP for Accelerators. Finally, we evaluate the approach in a reference implementation to prove the validity and usability with the help of an instrumented OpenMP runtime and the Score-P measurement infrastructure. © 2015 IEEE."
"Xu X., Luis G.M., Lobov A., Lastra J.L.M." $ "Multiple ontology workspace management and performance assessment" $ "This paper describes the development of a multiple ontology workspace management system and its performance assessment. This management system provides users with their own ontology workspace as a repository. It aims to facilitate the storage and manipulation of ontology models for knowledge driven manufacturing execution systems. The system uses Jena TDB API to maintain the file system on the server and utilizes Spring framework to provide RESTful web services to expose functionalities to the users such as user account creation, ontology model upload and SPARQL query services. Besides the web interface for the interaction between the user and the system, the system also provides web service endpoints that are compatible with other query engines based on Graph Store HTTP Protocol defined in standard SPARQL 1.1. User authentication is also introduced in the system in order to keep the privacy and integrity of the user data. In the end the performance is tested to evaluate its usability. The developed system offers adequate performance for a large number of users and enables the users to store and retrieve information of ontology anywhere as long as internet is available. As the result, it improves the availability of ontology as an important role in knowledge representation, knowledge acquisition and knowledge driven manufacturing systems. © 2015 IEEE."
"En X.D., Zhili Z." $ "A Local Bounding Box Method for Campus Navigation Based on Baidu Map" $ "Baidu Map provides most of the path navigation in the cities, but it has some drawbacks in small regions, such as the incomplete description, updating not timely. Sometimes it will bring misleading for us. In this paper, a campus navigation system is designed based on Baidu map API, using PHP, JavaScript and xml technologies. The system can provide the basic map function and search the path navigation between any two points in the campus. First, draw the campus map in detail and cover it on the Baidu Map by using the Baidu Map API class. Then, reconstruct a campus's geographic information on the local database. At last, call the Baidu Map API Service class to draw the navigation path on the map. In this paper, in order to avoid the path spillover we proposed a method called ""Local Bounding Box (LBB)"", which solves the cross-border issues. © 2015 IEEE."
"Duncan B., Zhang Y." $ "Neural networks for sentiment analysis on Twitter" $ "The online medium has become a significant way that people express their opinions online. Sentiment analysis can be used to find out the polarity of an opinion, such as positive, negative, or neutral. Sentiment analysis has applications such as companies getting their customer's opinions on their products, political sentiment analysis, or opinions on movie reviews. Recent research has involved looking at text from online blogs, tweets, online movie reviews, etc. to try and classify the text as being positive, negative, or neutral. For this research, a feedforward neural network will be experimented with for sentiment analysis of tweets. The training set of tweets are collected using the Twitter API using positive and negative keywords. The testing set of tweets are collected using the same positive and negative keywords. © 2015 IEEE."
"Santos C., Martins F., Vasconcelos V.T." $ "Deductive verification of parallel programs using why3" $ "The Message Passing Interface specification (MPI) defines a portable message-passing API used to program parallel computers. MPI programs manifest a number of challenges on what concerns correctness: sent and expected values in communications may not match, resulting in incorrect computations possibly leading to crashes, and programs may deadlock resulting in wasted resources. Existing tools are not completely satisfactory: model-checking does not scale with the number of processes, testing techniques wastes resources and are highly dependent on the quality of the test set. As an alternative, we present a prototype for a type-based approach to programming and verifying MPI-like programs against protocols. Protocols are written in a dependent type language designed so as to capture the most common primitives in MPI, incorporating, in addition, a form of primitive recursion and collective choice. Protocols are then translated into Why3, a deductive software verification tool. Source code, in turn, is written in Why ML, the language of the Why3 platform, and checked against the protocol. Programs that pass verification are guaranteed to be communication safe and free from deadlocks. We verified several parallel programs from textbooks using our approach, and report on the outcome. © C. Santos, F. Martins & V.T. Vasconcelos."
"Sohan S.M., Anslow C., Maurer F." $ "A Case Study of Web API Evolution" $ "When applications are integrated using web APIs, changes on a web API may break the dependent applications. This problem exists because old versions of the APIs may no longer be supported, a lack of adequate documentation to upgrade to a newer version, and insufficient communication of changes. In this paper we conducted a case study of evolving Web APIs to investigate what changes are made between versions and how the changes are documented and communicated to the API users. The findings are a list of recommendations for practitioners and researchers based on API change profiles, versioning, documentation and communication approaches that are observed in practice. This study will help inform developers of evolving Web APIs to make decision about versioning, documentation and communication methods. © 2015 IEEE."
"[No author name available]" $ "IEEE International Conference on Program Comprehension" $ "The proceedings contain 38 papers. The topics discussed include: discovering loners and phantoms in commit and issue data, i know what you did last summer - an investigation of how developers spend their time, generating reproducible and replayable bug reports from android application crashes, searching the state space: a qualitative study of API protocol usability, generating refactoring proposals to remove clones from automated system tests, code, camera, action: how software developers document and share program knowledge using YouTube, two user perspectives in program comprehension: end users and developer users, exploring the use of concern element role information in feature location evaluation, manually locating features in industrial source code: the search actions of software nomads, the plague doctor: a promising cure for the window plague, and polymorphism in the spotlight: studying its prevalence in Java and SmallTalk."
"Sawant A.A., Bacchelli A." $ "A dataset for API usage" $ "An Application Programming Interface (API) provides a specific set of functionalities to a developer. The main aim of an API is to encourage the reuse of already existing functionality. There has been some work done into API popularity trends, API evolution and API usage. For all the aforementioned research avenues there has been a need to mine the usage of an API in order to perform any kind of analysis. Each one of the approaches that has been employed in the past involved a certain degree of inaccuracy as there was no type check that takes place. We introduce an approach that takes type information into account while mining API method invocations and annotation usages. This approach accurately makes a connection between a method invocation and the class of the API to which the method belongs to. We try collecting as many usages of an API as possible, this is achieved by targeting projects hosted on GitHub. Additionally, we look at the history of every project to collect the usage of an API from earliest version onwards. By making such a large and rich dataset public, we hope to stimulate some more research in the field of APIs with the aid of accurate API usage samples. © 2015 IEEE."
"Heiland R., Koranda S., Marru S., Pierce M., Welch V." $ "Authentication and authorization considerations for a multi-tenant service" $ "Distributed cyberinfrastructure requires users (and machines) to perform some sort of authentication and authorization (together simply known as auth). In the early days of computing, authentication was performed with just a username and password combination, and this is still prevalent today. But during the past several years, we have seen an evolution of approaches and protocols for auth: Kerberos, SSH keys, X.509, OpenID, API keys, OAuth, and more. Not surprisingly, there are trade-offs, both technical and social, for each approach. The NSF Science Gateway communities have had to deal with a variety of auth issues. However, most of the early gateways were rather restrictive in their model of access and development. The practice of using community credentials (certificates), a well-intentioned idea to alleviate restrictive access, still posed a barrier to researchers and challenges for security and auditing. And while the web portal-based gateway clients offered users easy access from a browser, both the interface and the back-end functionality were constrained in the flexibility and extensibility they could provide. Designing a well-defined application programming interface (API) to fine-grained, generic gateway services (on secure, hosted cyberinfrastructure), together with an auth approach that has a lower barrier to entry, will hopefully present a more welcoming environment for both users and developers. This paper provides a review and some thoughts on these topics, with a focus on the role of auth between a Science Gateway and a service provider."
"Calabria A., Spinozzi G., Benedicenti F., Tenderini E., Montini E." $ "adLIMS: A customized open source software that allows bridging clinical and basic molecular research studies" $ "Background: Many biological laboratories that deal with genomic samples are facing the problem of sample tracking, both for pure laboratory management and for efficiency. Our laboratory exploits PCR techniques and Next Generation Sequencing (NGS) methods to perform high-throughput integration site monitoring in different clinical trials and scientific projects. Because of the huge amount of samples that we process every year, which result in hundreds of millions of sequencing reads, we need to standardize data management and tracking systems, building up a scalable and flexible structure with web-based interfaces, which are usually called Laboratory Information Management System (LIMS). Methods: We started collecting end-users' requirements, composed of desired functionalities of the system and Graphical User Interfaces (GUI), and then we evaluated available tools that could address our requirements, spanning from pure LIMS to Content Management Systems (CMS) up to enterprise information systems. Our analysis identified ADempiere ERP, an open source Enterprise Resource Planning written in Java J2EE, as the best software that also natively implements some highly desirable technological advances, such as the high usability and modularity that grants high use-case flexibility and software scalability for custom solutions. Results: We extended and customized ADempiere ERP to fulfil LIMS requirements and we developed adLIMS. It has been validated by our end-users verifying functionalities and GUIs through test cases for PCRs samples and pre-sequencing data and it is currently in use in our laboratories. adLIMS implements authorization and authentication policies, allowing multiple users management and roles definition that enables specific permissions, operations and data views to each user. For example, adLIMS allows creating sample sheets from stored data using available exporting operations. This simplicity and process standardization may avoid manual errors and information backtracking, features that are not granted using track recording on files or spreadsheets. Conclusions: adLIMS aims to combine sample tracking and data reporting features with higher accessibility and usability of GUIs, thus allowing time to be saved on doing repetitive laboratory tasks, and reducing errors with respect to manual data collection methods. Moreover, adLIMS implements automated data entry, exploiting sample data multiplexing and parallel/transactional processing. adLIMS is natively extensible to cope with laboratory automation through platform-dependent API interfaces, and could be extended to genomic facilities due to the ERP functionalities. © 2015 Calabria et al."
"Schreiner M., Rädle R., Jetter H.-C., Reiterer H." $ "Connichiwa - A framework for cross-device web applications" $ "While Mark Weiser's vision of ubiquitous computing is getting closer to reality, a fundamental part of it-the interconnection of devices into a ""ubiquitous network"",-is not achieved yet. Differences in hardware, architecture, and missing standardizations are just some reasons for this. We think that existing research is not versatile enough and too tailored to either single applications, hardware, or location. We contribute Connichiwa-a versatile framework for creating web applications across multiple devices. We base Connichiwa on four key goals: integration of existing devices, independence of network infrastructure, versatility of application scenario, and usability of its API. Connichiwa runs web applications on off-the-shelf consumer devices. With no external dependencies, such as a server, it enables a great variety of possible scenarios. We tested the technical feasibility of Connichiwa in seven example applications and plan to evaluate the framework and the usability of its API in a one-week Hackathon."
"Malloch J., Sinclair S., Wanderley M.M." $ "Distributed tools for interactive design of heterogeneous signal networks" $ "We introduce libmapper, an open source, cross-platform software library for flexibly connecting disparate interactive media control systems at run-time. This library implements a minimal, openly-documented protocol meant to replace and improve on existing schemes for connecting digital musical instruments and other interactive systems, bringing clarified, strong semantics to system messaging and description. We use automated discovery and message translation instead of imposed system-representation standards to approach “plug-and-play” usability without sacrificing design flexibility. System modularity is encouraged, and data are transported between peers without centralized servers. © 2014, Springer Science+Business Media New York."
"Scheller T., Kühn E." $ "Automated measurement of API usability: The API Concepts Framework" $ "Context Usability is an important software quality attribute for APIs. Unfortunately, measuring it is not an easy task since many things like experienced evaluators, suitable test users, and a functional product are needed. This makes existing usability measurement methods difficult to use, especially for non-professionals. Objective To make API usability measurement easier, an automated and objective measurement method would be needed. This article proposes such a method. Since it would be impossible to find and integrate all possible factors that influence API usability in one step, the main goal is to prove the feasibility of the introduced approach, and to define an extensible framework so that additional factors can easily be defined and added later. Method A literature review is conducted to find potential factors influencing API usability. From these factors, a selected few are investigated more closely with usability studies. The statistically evaluated results from these studies are used to define specific elements of the introduced framework. Further, the influence of the user as a critical factor for the framework's feasibility is evaluated. Results The API Concepts Framework is defined, with an extensible structure based on concepts that represent the user's actions, measurable properties that define what influences the usability of these concepts, and learning effects that represent the influence of the user's experience. A comparison of values calculated by the framework with user studies shows promising results. Conclusion It is concluded that the introduced approach is feasible and provides useful results for evaluating API usability. The extensible framework easily allows to add new concepts and measurable properties in the future. © 2015 Elsevier B.V. All rights reserved."
"Rama G.M., Kak A." $ "Some structural measures of API usability" $ "In this age of collaborative software development, the importance of usable APIs is well recognized. There already exists a rich body of literature that addresses issues ranging from how to design usable APIs to assessing qualitatively the usability of a given API. However, there does not yet exist a set of general-purpose metrics that can be pressed into service for a more quantitative assessment of API usability. The goal of this paper is to remedy this shortcoming in the literature. Our work presents a set of formulas that examine the API method declarations from the perspective of several commonly held beliefs regarding what makes APIs difficult to use.We validate the numerical characterizations of API usability as produced by our metrics through the APIs of several software systems. Copyright © 2013 John Wiley & Sons, Ltd."
"[No author name available]" $ "2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering, SANER 2015 - Proceedings" $ "The proceedings contain 84 papers. The topics discussed include: modeling the evolution of development topics using dynamic topic models, understanding developers' natural language queries with interactive clarification, an observational study on API usage constraints and their documentation, an observational study on API usage constraints and their documentation, measuring the quality of design pattern detection results, JCHARMING: a bug reproduction approach using crash traces and directed model checking, towards a common metamodel for traces of high performance computing systems to enable software analysis tasks, automated extraction of failure reproduction steps from user interaction traces, misery loves company: crowdstacking traces to aid problem detection, and who should review my code? a file location-based code-reviewer recommendation approach for modern code review."
"Pigula P., Nosál M." $ "Unified compile-time and runtime Java annotation processing" $ "Java provides two different options for processing source code annotations. One of them is the annotation processing API used in compile time, and the other is the Reflection API used in runtime. Both options provide different API for accessing program metamodel. In this paper, we examine the differences between those representations and we discuss options on how to unify these models along with advantages and disadvantages of this approach. Based on this proposal, we design a unified Java language model and present a prototype tool which can populate a unified model during both compilation and runtime. The paper includes the designed API of this unified language model. To verify our approach, we have performed experiments to show the usability of the unified metamodel. © 2015, IEEE."
"Businge J., Serebrenik A., van den Brand M.G.J." $ "Eclipse API usage: the good and the bad" $ "Today, when constructing software systems, many developers build their systems on top of frameworks. Eclipse is such a framework that has been in existence for over a decade. Like many other evolving software systems, the Eclipse platform has both stable and supported interfaces (“good”) and unstable, discouraged and unsupported interfaces (“bad”). In this study, we investigate Eclipse interface usage by Eclipse third-party plug-ins (ETPs) based on whether they use bad interfaces or not. The investigations, based on empirical analysis present the following observations. First, we discovered that 44 % of the 512 analyzed Eclipse third-party plug-ins depend on “bad” interfaces and that developers continue to use “bad” interfaces. Second, we have observed that plug-ins that use or extend at least one “bad” interface are comparatively larger and use more functionality from Eclipse than those that use only “good” interfaces. Third, the findings show that the ETPs use a diverse set of “bad” interfaces. Fourth, we observed that the reason why the bad interfaces are being eliminated from the ETPs’ source code is, because (ETP developers believe) these non-APIs will cause incompatibilities when a version of the ETP is ported to new Eclipse SDK release. Finally, we observed that when developers eliminate problematic “bad” interfaces, they either re-implement the same functionality in their own API, find equivalent SDK good interfaces, or completely delete the entities in the ETPs’ source code that use the functionality from the “bad” interfaces. © 2013, Springer Science+Business Media New York."
"Aibin M., Blazejewski M." $ "Complex Elastic Optical Network Simulator (CEONS)" $ "This paper presents the features of an advanced software simulator for the Elastic Optical Network (EON) - Complex Elastic Optical Networks Simulator (CEONS). The CEONS is as a test environment for solving three main issues addressed in EON: Routing and Spectrum Assignment (RSA) problems, Routing, Modulation and Spectrum Assignment (RMSA) problems, and addressing regenerator placement problem. With a universal API, users can design their own algorithms in any programming language and implement them in the simulator as plugins to solve the problems mentioned above. The ease and versatility of implementing the algorithms allows usage of the CEONS in advanced problems and for the introduction of EON technology. © 2015 IEEE."
"González-Burgueño A., Santiago S., Escobar S., Meadows C., Meseguer J." $ "Analysis of the PKCS#11 API using the maude-NPA tool" $ "Cryptographic Application Programmer Interfaces (Crypto APIs) are designed to allow a secure interoperation between applications and cryptographic devices such as smartcards and Hardware Security Modules (HSMs). However, several Crypto APIs have been shown to be subject to attacks in which sensitive information is disclosed to an attacker, such as the RSA Laboratories Public Key Standards PKCS#11, an API widely adopted in industry. Recently, there has been a growing interest on applying automated crypto protocol analysis methods to formally analyze APIs. However, the PKCS#11 has been proven difficult to analyze using such methods since it involves non-monotonic mutable global state. In this paper we specify and analyze the PKCS#11 in Maude-NPA, a general purpose crypto protocol analysis tool. © Springer International Publishing Switzerland 2015."
"George J.A., Hemalatha M." $ "Improving authentication and authorization for identity based cloud environment using oauth with fuzzy based blowfish algorithm" $ "Cloud computing involves group of remote servers, software, networks, centralized storage, which allows different number of online services and resources to virtualized business environment, individual users and educational institutions. But the main challenges are security between the user information, trust between the user and service provider. In business environment, Private Cloud Model (PCM) provides tight security of the application data even though in cloud, security issues such as authorization, confidentiality still exist. Therefore, the paper focuses on security, authentication and authorization using OAuth protocol. OAuth protocol authorizes the user while accessing the data from one application via another application for managing identities. OAuth HTTP based protocol is used for authorization and security is implemented using Fuzzy based blowfish encryption algorithm (FBFE). In OAuth, authorization is granted in four different ways like authorization code, implicit, resource owner password credential and client credential. OAuth establishes authorization between application and API user using token and redirect URI. © 2015 Praise Worthy Prize S.r.l. - All rights reserved."
"Kapre N." $ "Sparse graph processing with soft-processors" $ "Modern FPGAs can be configured to exploit the large amount of on chip parallelism possible from the distributed SRAM memory blocks for algorithms operating on large sparse graphs. To simplify the programming and configuration of such memory-centric organizations, we can customize an array of soft processors for these graph algorithms. In particular, we can deliver significant performance improvements for bulk synchronous graph algorithms with a custom processor that implements a graph-specific ISA. We develop a C++ API using Vivado High-Level Synthesis to describe graph computations and generate custom soft processors from these high-level descriptions. Our preliminary experiments suggest that our soft processor outperform Micro blaze and NIOS-II/f soft processors by ≈6×. While not the focus of this work, this design can scale out to a cluster of 16 - 32 low-power, energy-efficient Zed boards and Microzed boards to compete with server-class x86 nodes. © 2015 IEEE."
"Miller M.A., Schwartz T., Hoover P., Yoshimoto K., Sivagnanam S., Majumdar A." $ "The CIPRES workbench: A flexible framework for creating science gateways" $ "Here we describe the CIPRES Workbench (CW), an open source software framework for creating new science gateways with minimal overhead. The CW is a web application that can be deployed on a modest server, and can be configured to submit command line instructions to any resource where the application has submission privileges. It is designed to be highly configurable / customizable, and supports GUI-based access to HPC resources through a web browser interface as well as programmatic access via a ReSTful API. Using browser access, the CW architecture creates an environment with secure user accounts where user input data, job results, and job provenance are stored. The ReSTful API allows users with a registered a client application to deliver command lines to analytical codes and retrieve results from remote compute resources. A development effort is underway to allow the CW to submit jobs via the Science Gateways as a Platform (SciGaP) services hosted at Indiana University. Copyright © 2015 ACM."
"Tang X." $ "Attention, test code is low-quality!" $ "In this paper, we describe the formatting guidelines for ACM SIG Proceedings. Software testing is an essential process during software development and maintenance for improving software quality. Test code, the artefact during software testing, has been widely used in many software quality assurance techniques. Traditionally, software quality assurance techniques, e.g., automatic bug repair, fault localization, test case prioritization, and mining API usage from test code are based on the hypothesis of a sound quality of the test code. However, via empirical study on four open source projects, we found that the quality of test code is quite low comparing with corresponding source code, and this might hurt the above software quality assurance techniques. In this paper, we studied more than 140,000 LOC(lines of code) test code from four large scale and widely used open source projects and found that it is common for test code to be unregulated and of low-quality in open source projects. First, the comment clone ratio, unreleased resource ratio and clone code ratio of test code is much higher than that of corresponding source code, second, bug-fixed coverage is down to 0. We have learned the following lessons: the quality of test code is quite low comparing with corresponding source code, and the low quality test code may misguide existing software quality assurance techniques. Categories and Subject Descriptors D.2.5 [Software Engineering]: [Testing and Debugging] General Terms Experimentation, Measurement. © 2015 for this paper by its authors."
"Svajlenko J., Keivanloo I., Roy C.K." $ "Big data clone detection using classical detectors: an exploratory study" $ "Big data analysis is an emerging research topic in various domains, and clone detection is no exception. The goal is to create big data inter-project clone corpora across open-source or corporate-source code repositories. Such corpora can be used to study developer behavior and to reduce engineering costs by extracting globally duplicated efforts into new APIs and as a basis for code completion and API usage support. However, building scalable clone detection tools is challenging. It is often impractical to use existing state-of-the-art tools to analyze big data because the memory and execution time required exceed the average user's resources. Some tools have inherent limitations in their data structures and algorithms that prevent the analysis of big data even when extraordinary resources are available. These limitations are impossible to overcome if the source code of the tool is unavailable or if the user lacks the time or expertise to modify the tool without harming its performance or accuracy. In this research, we have investigated the use of our shuffling framework for scaling classical clone detection tools to big data. The framework achieves scalability on commodity hardware by partitioning the input dataset into subsets manageable by the tool and computing resources. A non-deterministic process is used to randomly ‘shuffle’ the contents of the dataset into a series of subsets. The tool is executed for each subset, and its output for each is merged into a single report. This approach does not require modification to the subject tools, allowing their individual strengths and precision to be captured at an acceptable loss of recall. In our study, we explored the performance and applicability of the framework for the big data dataset, IJaDataset 2.0, which consists of 356 million lines of code from 25,000 open-source Java projects. We begin with a computationally inexpensive version of our framework based on pure random shuffling. This version was successful at scaling the tools to IJaDataset but required many subsets to achieve a desirable recall. Using our findings, we incrementally improved the framework to achieve a satisfactory recall using fewer resources. We investigated the use of efficient file tracking and file-similarity heuristics to bias the shuffling algorithm toward subsets of the dataset that contain undetected clone pairs. These changes were successful in improving the recall performance of the framework. Our study shows that the framework is able to achieve up to 90–95% of a tool's native recall using standard hardware. Copyright © 2014 John Wiley & Sons, Ltd. Copyright © 2014 John Wiley & Sons, Ltd."
"Alotaibi H.M., Alamer R.A., Al-Khalifa H.S." $ "MLab: A mobile language learning lab system for language learners" $ "This paper describes the design and development of a mobile language lab system called MLab. The MLab system aims to replace the traditional language lab—which typically has a restrictive layout and lacks interaction—with a more user-friendly, low-cost mobile language lab. The target users of MLab are language teachers and students, and the system offers them the freedom to move around and use their own devices at any time and in any place. The MLab system was developed using several web technologies and Application Programming Interface (API) to provide a fast and convenient method of accessing required content. To evaluate the MLab system, a pilot test was conducted with a class of 15 students and their teacher. The results showed high usability rates and generally positive attitudes toward using the system. © 2015, J.UCS."
"Joe W., Lee J., Jeong K." $ "CSN: The conceptually manageable sensor network" $ "For the last decade, computer science and information technology have been rapidly expanding their application areas from computation and data processing inside computers to the real time monitoring and management of the real world outside computers. For those emerging applications such as Internet of Things, the flexible, scalable, and interoperable, collaborating sensor networks are crucial. In this paper, we present a sensor network system called the conceptually manageable sensor network (CSN). CSN is intended to support the conceptual management and integration of sensor networks and to provide well-defined and logical APIs for the facilitation of application development. The CSN design is based on the simple and intuitive conceptual model: sets and message queues. In order to minimize the system development efforts and to inherit the system quality of production level open source software, the CSN system is intentionally implemented as a set of extensions to the open source messaging system called ActiveMQ. We conducted some preliminary usability and performance tests for the current CSN implementation. For the usability test, we used data sets from a real world project for the energy-efficient management of Indoor Air Quality in subway stations. Both usability and performance tests showed promising results. © 2015 Woojin Joe et al."
"Brown J., Knepley M.G., Smith B.F." $ "Run-time extensibility and librarization of simulation software" $ "Build-time configuration and environment assumptions are hampering progress and usability in scientific software. This situation, which would be utterly unacceptable in nonscientific software, somehow passes for the norm in scientific packages. The scientific software community needs reusable, easy-to-use software packages that are flexible enough to accommodate next-generation simulation and analysis demands. © 1999-2011 IEEE."
"Arora R., Chen K., Gupta M., Clark S., Song C." $ "Leveraging diagrid hub for interactively generating and running parallel programs" $ "Interactive Parallelization Tool (IPT) is a semi-automatic tool that can be used by domain experts and students for transforming certain classes of existing applications into multiple parallel variants. An end-user of IPT provides existing application and high-level specifications for parallelization as input. On the basis of the specifications provided by the end-user, IPT carries out the code changes in the given existing application to generate parallel variants that can be run on different High Performance Computing (HPC) platforms. The parallel programming paradigms that are currently supported by IPT are MPI, OpenMP, and CUDA. The supported base languages are C and C++. Though IPT is still under active development, it has been recently made available on a web-enabled platform, named DiaGrid Hub, with the support from the XSEDE Extended Collaborative Support Service (ECSS). While the main goal of IPT is to make parallel programming easy for its end-users, the main goal of DiaGrid Hub is to enable the research community with instant access to HPC and High Throughput Computing platforms through a user-friendly web-interface. By deploying IPT on DiaGrid Hub, our goal is to enable the end-users to generate parallel versions of their existing applications without having to install IPT locally. They can also immediately compile and run the generated applications on Purdue and XSEDE resources that are available through DiaGrid Hub. Hence, the collaborative project that is reported in this paper lowers the entry-barriers to parallel programming and the usage of the national CyberInfrastructure (CI). In this paper, we present our ongoing work on deploying IPT over DiaGrid and testing the usability of IPT through a web-interface. Copyright © 2015 ACM."
"Toegl R., Winter J., Gissing M., Winkler T., Nauman M., Hong T.W." $ "Programming interfaces for the TPM" $ "The paradigm of Trusted Computing promises a new approach to improve the security of embedded and mobile systems. The core functionality, based on a hardware component known as Trusted Platform Module (TPM), is widely available. However, integration and application in embedded systems remains limited at present, simply because of the extremely steep learning curve involved in using the programmer–facing interfaces. In this chapter, we describe the current state of the Trusted Computing Group's software architecture and present previous approaches to improve usability. We report on a novel design of a high–level API for Trusted Computing for Java which has been optimized for ease–of–use and clear abstraction of Trusted Computing concepts. We derive requirements and design goals and outline the API design. Finally, we show the application and benchmarks in embedded systems. The result of this effort has been standardized as Java Specification Request 321. © Springer International Publishing Switzerland 2015."
"Giancarlo R., Scaturro D., Utro F." $ "ValWorkBench: An open source Java library for cluster validation, with applications to microarray data analysis" $ "The prediction of the number of clusters in a dataset, in particular microarrays, is a fundamental task in biological data analysis, usually performed via validation measures. Unfortunately, it has received very little attention and in fact there is a growing need for software tools/libraries dedicated to it. Here we present ValWorkBench, a software library consisting of eleven well known validation measures, together with novel heuristic approximations for some of them. The main objective of this paper is to provide the interested researcher with the full software documentation of an open source cluster validation platform having the main features of being easily extendible in a homogeneous way and of offering software components that can be readily re-used. Consequently, the focus of the presentation is on the architecture of the library, since it provides an essential map that can be used to access the full software documentation, which is available at the supplementary material website [1]. The mentioned main features of ValWorkBench are also discussed and exemplified, with emphasis on software abstraction design and re-usability. A comparison with existing cluster validation software libraries, mainly in terms of the mentioned features, is also offered. It suggests that ValWorkBench is a much needed contribution to the microarray software development/algorithm engineering community. For completeness, it is important to mention that previous accurate algorithmic experimental analysis of the relative merits of each of the implemented measures [19,23,25], carried out specifically on microarray data, gives useful insights on the effectiveness of ValWorkBench for cluster validation to researchers in the microarray community interested in its use for the mentioned task. © 2014 Elsevier Ireland Ltd."
"Bukhari A.C., Nagy M.L., Krauthammer M., Ciccarese P., Baker C.J.O." $ "ICyrus: A semantic framework for biomedical image discovery" $ "Images have an irrefutably central role in scientific discovery and discourse. However, the issues associated with knowledge management and utility operations unique to image data are only recently gaining recognition. In our previous work, we have developed Yale Image finder (YIF), which is a novel Biomedical image search engine that indexes around two million biomedical image data, along with associated metadata. While YIF is considered to be a veritable source of easily accessible biomedical images, there are still a number of usability and interoperability challenges that have yet to be addressed. To overcome these issues and to accelerate the adoption of the YIF for next generation biomedical applications, we have developed a publically accessible semantic API for biomedical images with multiple modalities. The core API called iCyrus is powered by a dedicated semantic architecture that exposes the YIF content as linked data, permitting integration with related information resources and consumption by linked data-aware data services. To facilitate the adhoc integration of image data with other online data resources, we also built semantic web services for iCyrus, such that it is compatible with the SADI semantic web service framework. The utility of the combined infrastructure is illustrated with a number of compelling use cases and further extended through the incorporation of Domeo, a well known tool for open annotation. Domeo facilitates enhanced search over the images using annotations provided through crowdsourcing. The iCyrus triplestore currently holds more than thirty-five million triples and can be accessed and operated through syntactic or semantic query interfaces. Core features of the iCyrus API, namely: data reusability, system interoperability, semantic image search, automatic update and dedicated semantic infrastructure make iCyrus a state of the art resource for image data discovery and retrieval. © Copyright 2015 for the individual papers by the papers' authors."
"[No author name available]" $ "11th International Conference on Security and Privacy in Communication Networks, SecureComm 2015" $ "The proceedings contain 48 papers. The special focus in this conference is on Mobile, System and Software Security. The topics include: Enforcing permissions with system-wide application execution context, detection, classification and characterization of android malware using API data dependency, improving security and usability for provider independent login architectures with mobile devices, using provenance patterns to vet sensitive behaviors in android apps, isolated execution of sensitive components for mobile applications, intrinsic code attestation by instruction chaining for embedded devices, defeating kernel driver purifier, kernel data attack is a realistic security threat, cloud-based anti-malware via reversible sketch, mining network traffic anomalies with hadoop, a secure interface for isolated execution environment to dynamically use external services, authenticating top-k results of secure multi-keyword search in cloud computing, resource efficient privacy preservation of online social media conversations, real-time privacy leakage monitoring without system modification for android, practicality of using side-channel analysis for software integrity checking of embedded systems, remote activation of hardware trojans via a covert temperature channel, route leaks identification by detecting routing loops, stateful black-box fuzzing of proprietary network protocols, deriving behavioral fingerprints from DNS traffic, enhancing traffic analysis resistance for tor hidden services with multipath routing, an improved method for anomaly-based network scan detection, an attribute-based signcryption scheme to secure attribute-defined multicast communications, generation of transmission control rules compliant with existing access control policies and a markov random field approach to automated protocol signature inference."
"Nguyen H.A., Dyer R., Nguyen T.N., Rajan H." $ "Mining preconditions of APIs in large-scale code corpus" $ "Modern software relies on existing application programming interfaces (APIs) from libraries. Formal specifications for the APIs enable many software engineering tasks as well as help developers correctly use them. In this work, we mine large-scale repositories of existing open-source software to derive potential preconditions for API methods. Our key idea is that APIs' preconditions would appear frequently in an ultra-large code corpus with a large number of API usages, while project-specific conditions will occur less frequently. First, we find all client methods invoking APIs. We then compute a control dependence relation from each call site and mine the potential conditions used to reach those call sites. We use these guard conditions as a starting point to automatically infer the preconditions for each API. We analyzed almost 120 million lines of code from SourceForge and Apache projects to infer preconditions for the standard Java Development Kit (JDK) library. The results show that our technique can achieve high accuracy with recall from 75-80% and precision from 82-84%. We also found 5 preconditions missing from human written specifications. They were all confirmed by a specification expert. In a user study, participants found 82% of the mined preconditions as a good starting point for writing specifications. Using our mining result, we also built a benchmark of more than 4,000 precondition-related bugs. Copyright 2014 ACM."
"David Hincapié-Ramos J., Ivanchuk L., Sridharan S.K., Irani P." $ "SmartColor: Real-time color correction and contrast for optical see-through head-mounted displays" $ "Users of optical see-through head-mounted displays (OHMD) perceive color as a blend of the display color and the background. Color-blending is a major usability challenge as it leads to loss of color encodings and poor text legibility. Color correction aims at mitigating color blending by producing an alternative color which, when blended with the background, more closely approaches the color originally intended. To date, approaches to color correction do not yield optimal results or do not work in real-time. This paper makes two contributions. First, we present QuickCorrection, a realtime color correction algorithm based on display profiles. We describe the algorithm, measure its accuracy and analyze two implementations for the OpenGL graphics pipeline. Second, we present SmartColor, a middleware for color management of userinterface components in OHMD. SmartColor uses color correction to provide three management strategies: correction, contrast, and show-up-on-contrast. Correction determines the alternate color which best preserves the original color. Contrast determines the color which best warranties text legibility while preserving as much of the original hue. Show-up-on-contrast makes a component visible when a related component does not have enough contrast to be legible. We describe the SmartColor's architecture and illustrate the color strategies for various types of display content. © 2014 IEEE."
"Akbar R.J., Omori T., Maruyama K." $ "Mining API usage patterns by applying method categorization to improve code completion" $ "Developers often face difficulties while using APIs. API usage patterns can aid them in using APIs efficiently, which are extracted from source code stored in software repositories. Previous approaches have mined repositories to extract API usage patterns by simply applying data mining techniques to the collection of method invocations of API objects. In these approaches, respective functional roles of invoked methods within API objects are ignored. The functional role represents what type of purpose each method actually achieves, and a method has a specific predefined order of invocation in accordance with its role. Therefore, the simple application of conventional mining techniques fails to produce API usage patterns that are helpful for code completion. This paper proposes an improved approach that extracts API usage patterns at a higher abstraction level rather than directly mining the actual method invocations. It embraces a multilevel sequential mining technique and uses categorization of method invocations based on their functional roles. We have implemented a mining tool and an extended Eclipse's code completion facility with extracted API usage patterns. Evaluation results of this tool show that our approach improves existing code completion. © 2014 The Institute of Electronics, Information and Communication Engineers."
"Zhu Z., Zou Y., Xie B., Jin Y., Lin Z., Zhang L." $ "Mining API usage examples from test code" $ "Lack of effective usage examples in API documents has been proven to be a great obstacle to API learning. To deal with this issue, several approaches have been proposed to automatically extract usage examples from client code or related web pages, which are unfortunately not available for newly released API libraries. In this paper, we propose a novel approach to mining API usage examples from test code. Although test code can be a good source of usage examples, the issue of multiple test scenarios might lead to repetitive and interdependent API usages in a test method, which make it complicated and difficult to extract API usage examples. To address this issue, we study the JUnit test code and summarize a set of test code patterns. We employ a code pattern based heuristic slicing approach to separate test scenarios into code examples. Then we cluster the similar usage examples for recommendation. An evaluation on four open source software libraries demonstrates that the accuracy of our approach is much higher than the state-of-art approach eXoaDoc on test code. Furthermore, we have developed an Eclipse plug in tool UsETeC. © 2014 IEEE."
"Cardoso B., Romão T." $ "The timeline as a programming interface" $ "The task of implementing meaningful reactive behavior in mobile applications is not trivial. To abstract over platform-specific details while writing expressive and legible code, we've developed EveWorks, a framework for context awareness that interfaces with the rest of the application code through statements written in a simple, interpreted language. In this work, we explain the conceptualization that stands at the core of our framework's language, inspired by one of the most ubiquitous representations of temporality, the timeline."
"Nguyen A.T., Nguyen H.A., Nguyen T.T., Nguyen T.N." $ "Statistical learning approach for mining API usage mappings for code migration" $ "The same software product nowadays could appear in multiple platforms and devices. To address business needs, software companies develop a software product in a programming language and then migrate it to another one. To support that process, semi-automatic migration tools have been proposed. However, they require users to manually define the mappings between the respective APIs of the libraries used in two languages. To reduce such manual effort, we introduce StaMiner, a novel data-driven approach that statistically learns the mappings between APIs from the corpus of the corresponding client code of the APIs in two languages Java and C#. Instead of using heuristics on the textual or structural similarity between APIs in two languages to map API methods and classes as in existing mining approaches, StaMiner is based on a statistical model that learns the mappings in such a corpus and provides mappings for APIs with all possible arities. Our empirical evaluation on several projects shows that StaMiner can detect API usage mappings with higher accuracy than a state-of-the-art approach. With the resulting API mappings mined by StaMiner, Java2CSharp, an existing migration tool, could achieve a higher level of accuracy. © 2014 ACM."
"Petersen P., Hanenberg S., Robbes R." $ "An empirical comparison of static and dynamic type systems on API usage in the presence of an IDE: Java vs. Groovy with eclipse" $ "Several studies have concluded that static type systems offer an advantage over dynamic type systems for programming tasks involving the discovery of a new API. However, these studies did not take into account modern IDE features, the advanced navigation and code completion techniques available in modern IDEs could drastically alter their conclusions. This study describes an experiment that compares the usage of an unknown API using Java and Groovy using the IDE Eclipse. It turns out that the previous finding that static type systems improve the usability of an unknown API still holds, even in the presence of a modern IDE. Copyright © 2014 ACM."
"Linares-Vásquez M., Bavota G., Bernal-Cárdenas C., Oliveto R., Di Penta M., Poshyvanyk D." $ "Mining energy-greedy API usage patterns in android apps: An empirical study" $ "Energy consumption of mobile applications is nowadays a hot topic, given the widespread use of mobile devices. The high demand for features and improved user experience, given the available powerful hardware, tend to increase the apps' energy consumption. However, excessive energy consumption in mobile apps could also be a consequence of energy greedy hardware, bad programming practices, or particular API usage patterns. We present the largest to date quantitative and qualitative empirical investigation into the categories of API calls and usage patterns that-in the context of the Android development framework-exhibit particularly high energy consumption profiles. By using a hardware power monitor, we measure energy consumption of method calls when executing typical usage scenarios in 55 mobile apps from different domains. Based on the collected data, we mine and analyze energy-greedy APIs and usage patterns. We zoom in and discuss the cases where either the anomalous energy consumption is unavoidable or where it is due to suboptimal usage or choice of APIs. Finally, we synthesize our findings into actionable knowledge and recipes for developers on how to reduce energy consumption while using certain categories of Android APIs and patterns. Copyright 2014 ACM."
"Chen C., Zhang K." $ "Who asked what: Integrating crowdsourced FAQs into API documentation" $ "Documentation is important for learning Application Pro-gramming Interfaces (APIs). In addition to official docu-ments, much crowdsourced API knowledge is available on the Web. Crowdsourced API documentation is fragmented, scattered around the Web, and disconnected from official doc-umentation. Developers often rely on Web search to retrieve additional programming help. We propose to connect these two types of documentation by capturing developers' Web browsing behavior in the context of document reading and integrating crowdsourced frequently asked questions (FAQs) into API documents. Such an integration not only provides relevant API help more conveniently, but also opens a new approach to promoting knowledge collaboration and studying API users' information needs. Copyright © 2014 ACM."
"[No author name available]" $ "11th Working Conference on Mining Software Repositories, MSR 2014 - Proceedings" $ "The proceedings contain 63 papers. The topics discussed include: mining energy-greedy API usage patterns in android apps: an empirical study, greenminer: a hardware based mining software repositories software energy consumption framework, mining questions about software energy consumption, prediction and ranking of co-change candidates for clones, incremental origin analysis of source code files, characterizing and predicting blocking bugs in open source projects, the promises and perils of mining GitHub, mining questions asked by web developers, MUX: algorithm selection for software model checkers, finding patterns in static analysis alerts, an empirical study of just-in-time defect prediction using cross-project models, and the impact of code review coverage and code review participation on software quality."
"Lorenzon A.F., Filho A.C.S.B., Cera M.C." $ "The impact of different multi-threading interfaces on embedded systems" $ "The popularity of multicore embedded systems brings new challenges to the development of parallel applications: at the same time it is necessary to exploit the availability of multiple cores, it is also mandatory to consume less energy. To speed up the development process and make it as more transparent as possible to the programmer, parallelism is exploited through the use of Application Programming Interfaces (API). Each one of these API implements different ways to exchange data. However, data exchange occurs between the threads in shared memory regions, which have higher energy consumption. Therefore, each API will present different energy costs to communicate. In this paper, we present the first step to show that different APIs have different impacts on energy consumption, through the analysis of the communication mechanism that each one employs, the number of memory accesses necessary for the communication, and the number of executed instructions according to the API used. Our results show that OpenMP presents a higher communication overhead, with more memory accesses and instructions executed, when compared to Pthreads. © 2013 IEEE."
"Khan M.A., Muhammad S., Muhammad T." $ "Identifying performance issues based on method invocation patterns of an API" $ "Software systems use many third party libraries by invoking their APIs. A software system may potentially use an API in an inefficient manner, for example, by creating unnecessary or a large number of short-lived objects. This can cause performance degradation in terms of memory usage and latency in critical applications. In this paper we use an object invocation model based on object creation and their method invocations from different code locations. We use a framework to extract the model features from a running software system. The extracted features are then used in a clustering based mechanism to identify problematic code locations within the software system. We demonstrate our approach by analyzing Java Collection API objects in a Java-based open source editor JEdit. We have successfully identified interesting code locations and discussed their impact on software performance. Copyright is held by the owner/author(s)."
"De Roover C., Stevens R." $ "Building development tools interactively using the EKEKO meta-programming library" $ "EKEKO is a Clojure library for applicative logic meta-programming against an Eclipse workspace. EKEKO has been applied successfully to answering program queries (e.g., ""does this bug pattern occur in my code?""), to analyzing project corpora (e.g., 'how often does this API usage pattern occur in this corpus?'), and to transforming programs (e.g., ""change occurrences of this pattern as follows"") in a declarative manner. These applications rely on a seamless embedding of logic queries in applicative expressions. While the former identify source code of interest, the latter associate error markers with, compute statistics about, or rewrite the identified source code snippets. In this paper, we detail the logic and applicative aspects of the EKEKO library. We also highlight key choices in their implementation. In particular, we demonstrate how a causal connection with the Eclipse infrastructure enables building development tools interactively on the Clojure read-eval-print loop. © 2014 IEEE."
"Wu W., Adams B., Gueheneuc Y.-G., Antoniol G." $ "ACUA: API change and usage auditor" $ "Modern software uses frameworks through their Application Programming Interfaces (APIs). Framework APIs may change while frameworks evolve. Client programs have to upgrade to new releases of frameworks if security vulnerabilities are discovered in the used releases. Patching security vulnerabilities can be delayed by non-security-related API changes when the frameworks used by client programs are not up to date. Keeping frameworks updated can reduce the reaction time to patch security leaks. Client program upgrades are not cost free, developers need to understand the API usages in client programs and API changes between framework releases before conduct upgrading tasks. In this paper, we propose a tool ACUA to generate reports containing detailed API change and usage information by analyzing the binary code of both frameworks and clients programs written in Java. Developers can use the API change and usage reports generated by ACUA to estimate the work load and decide when to starting upgrading client programs based on the estimation. © 2014 IEEE."
"Steele G.L., Jr., Lea D., Flood C.H." $ "Fast splittable pseudorandom number generators" $ "We describe a new algorithm SPLITMIX for an objectoriented and splittable pseudorandom number generator (PRNG) that is quite fast: 9 64-bit arithmetic/logical operations per 64 bits generated. A conventional linear PRNG object provides a generate method that returns one pseudorandom value and updates the state of the PRNG, but a splittable PRNG object also has a second operation, split, that replaces the original PRNG object with two (seemingly) independent PRNG objects, by creating and returning a new such object and updating the state of the original object. Splittable PRNG objects make it easy to organize the use of pseudorandom numbers in multithreaded programs structured using forkjoin parallelism. No locking or synchronization is required (other than the usual memory fence immediately after object creation). Because the generate method has no loops or conditionals, it is suitable for SIMD or GPU implementation. Copyright 2014 ACM.We derive SPLITMIX from the DOTMIX algorithm of Leiserson, Schardl, and Sukha by making a series of program transformations and engineering improvements. The end result is an object-oriented version of the purely functional API used in the Haskell library for over a decade, but SPLITMIX is faster and produces pseudorandom sequences of higher quality, it is also far superior in quality and speed to Java.util.Random, and has been included in Java JDK8 as the class Java.util.SplittableRandom. We have tested the pseudorandom sequences produced by SPLITMIX using two standard statistical test suites (DieHarder and TestU01) and they appear to be adequate for ""everyday"" use, such as in Monte Carlo algorithms and randomized data structures where speed is important."
"Padhye R., Mukherjee D., Sinha V.S." $ "API as a social glue" $ "The rapid growth of social platforms such as Facebook, Twit-ter and LinkedIn underscores the need for people to connect to existing and new contacts for recreational and profes-sional purposes. A parallel of this phenomenon exists in the software development arena as well. Open-source code shar-ing platforms such as GitHub provide the ability to follow people and projects of interest. However, users are manu-ally required to identify projects or other users whom they might be interested in following. We observe that most soft-ware projects use third-party libraries and that developers who contribute to multiple projects often use the same li-brary APIs across projects. Thus, the library APIs seem to be a good fingerprint of their skill set. Hence, we argue that library APIs can form the social glue to connect people and projects having similar interests. We propose APINet, a system that mines API usage profiles from source code version management systems and create a social network of people, projects and libraries. We describe our initial im-plementation that uses data from 568 open-source projects hosted on GitHub. Our system recommends to a user new projects and people that they may be interested in, suggests communities of people who use related libraries and finds experts for a given topic who are closest in a user's social graph. Copyright © 2014 ACM."
"Diprose J.P., Plimmer B., Macdonald B.A., Hosking J.G." $ "A human-centric API for programming socially interactive robots" $ "Whilst robots are increasingly being deployed as social agents, it is still difficult to program them to interact socially. This is because current programming tools either require programmers to work at a low level or lack features needed to create certain aspects of social interaction. High level, domain specific tools with features designed specifically to meet the requirements of social interaction have the potential to ease the creation of social applications. We present a domain specific application programming interface (API) that is designed to meet the requirements of social interaction. The Cognitive Dimensions Framework was used as a design tool during the design process and the API was validated by implementing an exemplar application. The evaluation of the API showed that programmers with no robotics knowledge were positively impressed by the notation and that its organization, domain specific interfaces and object oriented nature positively affected several Cognitive Dimensions. © 2014 IEEE."
"Lee S., Lee S., Lim S., Jung J., Choi S., Kim N., Lee J.-B." $ "An API design process in terms of usability: A case study on building more usable apis for smart TV platform" $ "Products are released based on various platforms. An Application programing interface (API) is important to develop platform based applications effectively. Previously, we had some difficulties in developing applications using our platform APIs. Their name was ambiguous, and their functions were not primitive, and even their documentation was not enough to refer to. Therefore, we had to maintain our platform APIs. In this paper, we propose an API design process and API evaluation guidelines. 'API Analysts' elicit functions from requirement documents. 'API designer' design APIs for the functions following the guidelines. 'Technical writers' produce documentation for the APIs. 'API reviewers' evaluate the APIs and API documentation conforming to the proposed guidelines. Proposed process made our platform APIs more convenient to use for developing applications. © 2014 IEEE."
"Nagaraju S." $ "Shapers: Capturing free form shapes for bendable device interactions" $ "Future mobile and wearable devices are heavily influenced by advances in materials which make the devices flexible to interact. In this paper, we propose a system to capture the shape of bent device at graphics framework and make use of the shape to develop novel user interactions for native and app store downloadable applications on consumer electronic devices. We further detail the API, parameters and prototype on Android for shape generation along with OpenGL based emulation for bendable device deformation, followed by usability study results. © 2014 The Authors. Published by Elsevier B.V."
"Ramakrishnan L., Poon S., Hendrix V., Gunter D., Pastorello G.Z., Agarwal D." $ "Experiences with user-centered design for the tigres workflow API" $ "Scientific data volumes have been growing exponentially. This has resulted in the need for new tools that enable users to operate on and analyze data. Cyber infrastructure tools, including workflow tools, that have been developed in the last few years has often fallen short if user needs and suffered from lack of wider adoption. User-centered Design (UCD) process has been used as an effective approach to develop usable software with high adoption rates. However, UCD has largely been applied for user-interfaces and there has been limited work in applying UCD to application program interfaces and cyber infrastructure tools. We use an adapted version of UCD that we refer to as Scientist-Centered Design (SCD) to engage with users in the design and development of Tigres, a workflow application programming interface. Tigres provides a simple set of programming templates (e.g., sequence, parallel, split, merge) that can be can used to compose and execute computational and data transformation pipelines. In this paper, we describe Tigres and discuss our experiences with the use of UCD for the initial development of Tigres. Our experience-to-date is that the UCD process not only resulted in better requirements gathering but also heavily influenced the architecture design and implementation details. User engagement during the development of tools such as Tigres is critical to ensure usability and increase adoption. © 2014 IEEE."
"Danelutto M., Torquati M." $ "Loop parallelism: A new skeleton perspective on data parallel patterns" $ "Traditionally, skeleton based parallel programming frameworks support data parallelism by providing the programmer with a comprehensive set of data parallel skeletons, based on different variants of map and reduce patterns. On the other side, more conventional parallel programming frameworks provide application programmers with the possibility to introduce parallelism in the execution of loops with a relatively small programming effort. In this work, we discuss a ""ParallelFor"" skeleton provided within the FastFlow framework and aimed at filling the usability and expressivity gap between the classical data parallel skeleton approach and the loop parallelisation facilities offered by frameworks such as OpenMP and Intel TBB. By exploiting the low run-time overhead of the FastFlow parallel skeletons and the new facilities offered by the C++11 standard, our ParallelFor skeleton succeeds to obtain comparable or better performance than both OpenMP and TBB on the Intel Phi many-core and Intel Nehalem multi-core for a set of benchmarks considered, yet requiring a comparable programming effort. © 2014 IEEE."
"Spliet R., Howes L., Gaster B.R., Varbanescu A.L." $ "KMA: A dynamic memory manager for OpenCL" $ "OpenCL is becoming a popular choice for the parallel programming of both multi-core CPUs and GPGPUs. One of the features missing in OpenCL, yet commonly required in irregular parallel applications, is dynamic memory allocation. In this paper, we propose KMA, a first dynamic memory allocator for OpenCL. KMA's design is based on a thorough analysis of a set of 11 algorithms, which shows that dynamic memory allocation is a necessary commodity, typically used for implementing complex data structures (arrays, lists, trees) that need constant restructuring at runtime. Taking into account both the survey findings and the status- quo of OpenCL, we design KMA as a two-layer memory manager that makes smart use of the patterns we identified in our application analysis: its basic functionality provides generic malloc() and free() APIs, while the higher layer provides support for building and efficiently managing dynamic data structures. Our experiments measure the performance and usability of KMA, using both microbenchmarks and a real-life case-study. Results show that when dynamic allocation is mandatory, KMA is a competitive allocator. We conclude that embedding dynamic memory allocation in OpenCL is feasible, but it is a complex, delicate task due to the massive parallelism of the platform and the portability issues between different OpenCL implementations. Copyright 2014 ACM."
"Viyanon W." $ "Bus search: Development and evaluation of performance and usability of mobile application for blind or visually impaired" $ "This paper describes the design and development of a mobile application supporting independent travel in accessing public buses for people who are blind or visually impaired. The key objective is to develop solutions that are low cost, have an intuitive and easy to use interface. The Android architecture was used with speech recognition (SR) technology in order to assist blind or visually impaired users. With the help of A-GPS in phones and through Web Services using GPRS, Location Based Services can be implemented on android based on smart phones to provide value-added services: retrieving current traffic conditions, providing routing information, getting estimated wait time for users. The mobile application supports two languages, English and Thai as voice inputs using open-source CMU Sphinx for Thai and Google speech recognition API for English. Empirical analysis under various environments such as indoor, outdoor, and building surrounded and usability studies were performed to illustrate the efficacy of the application. The results of average of application response time are acceptable according to SOASTA's survey. Improved feedback was added based on usability study results."
"Dickinson A.W.L., Abolmaesumi P., Gobbi D.G., Mousavi P." $ "SimITK: Visual programming of the ITK image-processing library within simulink" $ "The Insight Segmentation and Registration Toolkit (ITK) is a software library used for image analysis, visualization, and image-guided surgery applications. ITK is a collection of C++ classes that poses the challenge of a steep learning curve should the user not have appropriate C++ programming experience. To remove the programming complexities and facilitate rapid prototyping, an implementation of ITK within a higher-level visual programming environment is presented: SimITK. ITK functionalities are automatically wrapped into ""blocks"" within Simulink, the visual programming environment of MATLAB, where these blocks can be connected to form workflows: visual schematics that closely represent the structure of a C++ program. The heavily templated C++ nature of ITK does not facilitate direct interaction between Simulink and ITK, an intermediary is required to convert respective data types and allow intercommunication. As such, a SimITK ""Virtual Block"" has been developed that serves as a wrapper around an ITK class which is capable of resolving the ITK data types to native Simulink data types. Part of the challenge surrounding this implementation involves automatically capturing and storing the pertinent class information that need to be refined from an initial state prior to being reflected within the final block representation. The primary result from the SimITK wrapping procedure is multiple Simulink block libraries. From these libraries, blocks are selected and interconnected to demonstrate two examples: a 3D segmentation workflow and a 3D multimodal registration workflow. Compared to their pure-code equivalents, the workflows highlight ITK usability through an alternative visual interpretation of the code that abstracts away potentially confusing technicalities. © 2014 Society for Imaging Informatics in Medicine."
"Kührer M., Hoffmann J., Holz T." $ "CloudSylla: Detecting suspicious system calls in the cloud" $ "To protect computer systems against the tremendous number of daily malware threats, security software is typically installed on individual end hosts and the responsibility to keep this software updated is often assigned to (inexperienced) users. A critical drawback of this strategy, especially in enterprise networks, is that a single unprotected client system might lead to severe attacks such as industrial espionage. To overcome this problem, a potential approach is to move the responsibility to utilize the latest detection mechanisms to a centralized, continuously maintained network service to identify suspicious behavior on end hosts and perform adequate actions once a client invokes malicious activities. In this paper, we propose a security approach called CloudSylla (Cloud-based SY scaLL Analysis) in which we utilize a centralized network service to analyze the clients’ activities directly at the API and system call level. This enables, among other advantages, a centralized management of signatures and a unified security policy. To evaluate the applicability of our approach, we implemented prototypes for desktop computers and mobile devices and found this approach to be applicable in practice as no substantial limitations of usability are caused on the client side. © Springer International Publishing Switzerland 2014."
"Shimizu Y." $ "Incorporating Green into Production and Consumption Behaviours toward Sustainable Logistics Optimization in Process Systems" $ "Recently, realizing low carbon society has attracted a great interest under a provision for essential infrastructure aligned with sustainable development. Deployment of green logistics incorporating co-existence of manufacturers and consumers will be a new key issue for such technologies. Noticing such circumstance, in this paper, we have extended our approaches for logistics optimization to cope with green logistics associated with production and consumption behaviours in process systems. Taking a multi-layer logistics network, we have developed a novel approach that tries to evaluate the minimum total cost and CO2 emission under appropriate constraints through adjusting prone and aversion consciousness on sustainability among the logistics members. Numerical experiment has been carried out to validate effectiveness of the proposed approach. Moreover, to enhance usability toward real-world applications, we provide a system development aimed at using Google map API. © 2014 Elsevier B.V."
"Chang K.S.-P., Myers B.A., Cahill G.M., Simanta S., Morris E., Lewis G." $ "A plug-in architecture for connecting to new data sources on mobile devices" $ "A key use for mobile devices is to search and view online information while on the go. As a result, many mobile applications serve as front ends for online databases. While there are many thousands of data sources that provide web service APIs giving access to their databases, creating mobile applications to use those sources requires significant mobile programming knowledge and a significant amount of time. We introduce Spinel, a plug-in architecture for Android, and a set of web-based configuration tools that together enable users to connect mobile applications to new data sources without programming. Spinel also provides APIs that make it easy for developers to create new applications that use those data sources. We provide three demonstration Android applications that use such data: Listpad for entering personal lists, Listviewer for viewing results of data queries, and Mapviewer for displaying query results on a map. An informal usability study showed that users could successfully attach new data sources to those applications. © 2013 IEEE."
"Zhu Z., Zou Y., Jin Y., Xie B." $ "Generating API-usage example for project developers" $ "Usage examples have been shown very helpful for API learning in software reuse. Nowadays, many approaches have been proposed to automatically extract usage examples from client code or web pages for API users. However, they overlooked the benefit of API developers in example publishing and few works paid attention to help API developers to generate usage examples automatically. In this paper, we proposed an approach to generate API-usage example based on test code before the project are released. It analyzed which parts in test code are important for indicating APIusage and summarized some test code patterns, then a heuristic slice algorithm are proposed to extract referential test code as APIusage example based on these patterns. In the experiments, we gave some case studies on the commons-lang3 open source software library. It proved that our approach can provide good assistance for developers in APIs usage example generation."
"[No author name available]" $ "2013 10th Working Conference on Mining Software Repositories, MSR 2013 - Proceedings" $ "The proceedings contain 63 papers. The topics discussed include: why so complicated? simple term filtering and weighting for location-based bug report assignment recommendation, bug report assignee recommendation using activity profiles, retrieving and analyzing mobile apps feature requests from online reviews, Gerrit software code review data from android, why, when, and what: analyzing stack overflow questions by topic, type, and code, deficient documentation detection: a methodology to locate deficient project documentation using topic analysis, detecting API usage obstacles: a study of iOS and Android developer questions, a discriminative model approach for suggesting tags automatically for stack overflow questions, a study of innovation diffusion through link sharing on stack overflow, building reputation in stackoverflow: an empirical investigation, and intensive metrics for the study of the evolution of open source projects: case studies from apache software foundation projects."
"Gascon H., Yamaguchi F., Arp D., Rieck K." $ "Structural detection of Android malware using embedded call graphs" $ "The number of malicious applications targeting the Android system has literally exploded in recent years. While the security community, well aware of this fact, has proposed several methods for detection of Android malware, most of these are based on permission and API usage or the identification of expert features. Unfortunately, many of these approaches are susceptible to instruction level obfuscation techniques. Previous research on classic desktop malware has shown that some high level characteristics of the code, such as function call graphs, can be used to find similarities between samples while being more robust against certain obfuscation strategies. However, the identification of similarities in graphs is a non-trivial problem whose complexity hinders the use of these features for malware detection. In this paper, we explore how recent developments in machine learning classification of graphs can be efficiently applied to this problem. We propose a method for malware detection based on efficient embeddings of function call graphs with an explicit feature map inspired by a linear-time graph kernel. In an evaluation with 12,158 malware samples our method, purely based on structural features, outperforms several related approaches and detects 89% of the malware with few false alarms, while also allowing to pin-point malicious code structures within Android applications. © 2013 ACM."
"McDonnell T., Ray B., Kim M." $ "An empirical study of API stability and adoption in the android ecosystem" $ "When APIs evolve, clients make corresponding changes to their applications to utilize new or updated APIs. Despite the benefits of new or updated APIs, developers are often slow to adopt the new APIs. As a first step toward understanding the impact of API evolution on software ecosystems, we conduct an in-depth case study of the co-evolution behavior of Android API and dependent applications using the version history data found in github. Our study confirms that Android is evolving fast at a rate of 115 API updates per month on average. Client adoption, however, is not catching up with the pace of API evolution. About 28% of API references in client applications are outdated with a median lagging time of 16 months. 22% of outdated API usages eventually upgrade to use newer API versions, but the propagation time is about 14 months, much slower than the average API release interval (3 months). Fast evolving APIs are used more by clients than slow evolving APIs but the average time taken to adopt new versions is longer for fast evolving APIs. Further, API usage adaptation code is more defect prone than the one without API usage adaptation. This may indicate that developers avoid API instability. © 2013 IEEE."
"Freitas A., O'Riain S., Curry E." $ "A distributional semantic search infrastructure for linked dataspaces" $ "This paper describes and demonstrates a distributional semantic search service infrastructure for Linked Dataspaces. The center of the approach relies on the use of a distributional semantics infrastructure to provide semantic search and query services over data for users and applications, improving data accessibility over the Dataspace. By accessing the services through a REST API, users can semantically index and search over data using the distributional semantic knowledge embedded in the reference corpus. The use of distributional semantic models, which rely on the automatic extraction from large corpora, supports a comprehensive and approximative semantic matching mechanism with a low associated adaptation cost for the inclusion of new data sources. © Springer-Verlag 2013."
"Sankhe P., Kuriakose S., Lahiri U." $ "A step towards a robotic system with smartphone working as its brain: An assistive technology" $ "This paper describes a novel smartphone based navigation application. The smartphone based robotic system is sensitive to both the tactile and head-movement input commands from a user. Here we present our design used for developing a prototype of the robotic system as a proof-of-concept of an assistive technology that could facilitate partially disabled people to navigate effectively. Additionally we designed a usability study where our prototype was validated by seven healthy participants. Such an intelligent robotic system controlled by a smartphone can find a variety of applications based on navigation systems for disabled persons, educational tools especially for children with autism, surveillance and social telepresence. The hardware prototype could then be further used for development purposes to build a variety of applications using Application Program Interfaces (APIs) that can program the robot to do a custom task. © 2013 IEEE."
"Lin H., Jia J., Wu X., Cai L." $ "TalkingAndroid: An interactive, multimodal and real-time talking avatar application on mobile phones" $ "In this paper, we present a novel interactive, multimodal and real-time 3D talking avatar application, on mobile platforms. The application is based on a novel network independent, stand-alone framework using cross-platform JNI and OpenGL ES library. In this framework, we implement the audio synthesis, facial animation rendering and the audio-visual synchronization process on the mobile client using the native APIs to optimize the render performance and power consumption. We also utilize the existing interactive APIs on the mobile devices to extend the usability of the application. Experiment results show that the proposed framework for mobile platforms can run smoothly on the current mobile devices with real-time multimodal interaction. Compared to the traditional video streaming method and the client-server framework, the proposed framework has much lower network requirement, with much shorter interaction delay and more efficient power consumption. The presented application can be used in entertainment, education and many other interactive areas. © 2013 APSIPA."
"Elangovan V.K., Badia R.M., Parra E.A." $ "OmpSs-OpenCL programming model for heterogeneous systems" $ "The advent of heterogeneous computing has forced programmers to use platform specific programming paradigms in order to achieve maximum performance. This approach has a steep learning curve for programmers and also has detrimental influence on productivity and code re-usability. To help with this situation, OpenCL an open-source, parallel computing API for cross platform computations was conceived. OpenCL provides a homogeneous view of the computational resources (CPU and GPU) thereby enabling software portability across different platforms. Although OpenCL resolves software portability issues, the programming paradigm presents low programmability and additionally falls short in performance. In this paper we focus on integrating OpenCL framework with the OmpSs task based programming model using Nanos run time infrastructure to address these shortcomings. This would enable the programmer to skip cumbersome OpenCL constructs including OpenCL plaform creation, compilation, kernel building, kernel argument setting and memory transfers, instead write a sequential program with annotated pragmas. Our proposal mainly focuses on how to exploit the best of the underlying hardware platform with greater ease in programming and to gain significant performance using the data parallelism offered by the OpenCL run time for GPUs and multicore architectures. We have evaluated the platform with important benchmarks and have noticed substantial ease in programming with comparable performance. © © Springer-Verlag Berlin Heidelberg 2013."
"Kalavri V., Vlassov V." $ "MapReduce: Limitations, optimizations and open issues" $ "MapReduce has recently gained great popularity as a programming model for processing and analyzing massive data sets and is extensively used by academia and industry. Several implementations of the MapReduce model have emerged, the Apache Hadoop framework being the most widely adopted. Hadoop offers various utilities, such as a distributed file system, job scheduling and resource management capabilities and a Java API for writing applications. Hadoop's success has intrigued research interest and has led to various modifications and extensions to the framework. Implemented optimizations include performance improvements, programming model extensions, tuning automation and usability enhancements. In this paper, we discuss the current state of the Hadoop framework and its identified limitations. We present, compare and classify Hadoop/MapReduce variations, identify trends, open issues and possible future directions. © 2013 IEEE."
"Song F., Touili T." $ "Model-checking software library API usage rules" $ "Modern software increasingly relies on using libraries which are accessed via Application Programming Interfaces (APIs). Libraries usually impose constraints on how API functions can be used (API usage rules) and programmers have to obey these API usage rules. However, API usage rules often are not well-documented or documented informally. In this work, we show how to use the SCTPL logic to precisely specify API usage rules in libraries, where SCTPL can be seen as an extension of the branching-time temporal logic CTL with variables, quantifiers, and predicates over the stack. This allows library providers to formally describe API usage rules without knowing how their libraries will be used by programmers. We also propose an approach to automatically check whether programs using libraries violate or not the corresponding API usage rules. Our approach consists in modeling programs as pushdown systems (PDSs), and checking API usage rules on programs using SCTPL model checking for PDSs. To make the model-checking procedure more efficient, we propose an abstraction that reduces drastically the size of the program model. Moreover, we characterize a sub-logic rSCTPL of SCTPL preserved by the abstraction. rSCTPL is sufficient to precisely specify all the API usage rules we met. We implemented our techniques in a tool and applied it to check several API usage rules. Our tool detected several previously unknown errors in well-known programs, such as Nssl, Verbs, Acacia+, Walksat and Getafix. Our experimental results are encouraging. © 2013 Springer-Verlag Berlin Heidelberg."
"[No author name available]" $ "Integrated Formal Methods - 10th International Conference, IFM 2013, Proceedings" $ "The proceedings contain 29 papers. The topics discussed include: systems design guided by progress concerns, assume-guarantee specifications of state transition diagrams for behavioral refinement, automated anonymity verification of the ThreeBallot voting system, compositional verification of software product lines, deductive verification of state-space algorithms, inductive verification of hybrid automata with strongest postcondition calculus, priced timed automata and statistical model checking, improved reachability analysis in DTMC via divide and conquer, solving games using incremental induction, model-checking software library API usage rules, detecting vulnerabilities in Java-card bytecode verifiers using model-based testing, integrating formal predictions of interactive system behaviour with user evaluation, integrating proved state-based models for constructing correct distributed algorithms, and a compositional automata-based semantics for property patterns."
"Linares-Vásquez M., Bavota G., Bernal-Cárdenas C., Di Penta M., Oliveto R., Poshyvanyk D." $ "API change and fault proneness: A threat to the success of android apps" $ "During the recent years, the market of mobile software applications (apps) has maintained an impressive upward trajectory. Many small and large software development companies invest considerable resources to target available opportunities. As of today, the markets for such devices feature over 850K+ apps for Android and 900K+ for iOS. Availability, cost, functionality, and usability are just some factors that determine the success or lack of success for a given app. Among the other factors, reliability is an important criteria: users easily get frustrated by repeated failures, crashes, and other bugs, hence, abandoning some apps in favor of others. This paper reports a study analyzing how the fault- and change-proneness of APIs used by 7, 097 (free) Android apps relates to applications' lack of success, estimated from user ratings. Results of this study provide important insights into a crucial issue: making heavy use of fault- and change-prone APIs can negatively impact the success of these apps. Copyright 2013 ACM."
"Herbold S., Harms P." $ "AutoQUEST - Automated quality engineering of event-driven software" $ "In this paper, we present Auto QUEST, a testing platform for Event-Driven Software (EDS) that decouples the implementation of testing techniques from the concrete platform they should be applied to. Auto QUEST provides the means to define testing techniques against an abstract Application Programming Interface (API) and provides plug-ins to port the testing techniques to distinct platforms. The requirements on plug-in implementations for Auto QUEST are kept low to keep the porting effort low. We implemented several testing techniques on top of Auto QUEST and provide five plug-ins for concrete software platforms, which demonstrates the capabililities of our approach. © 2013 IEEE."
"Sangeetha R." $ "Detection of malicious code in user mode" $ "A particular type of executable malware code is malicious code that harms the computer or networks without the user intervention. Static analysis is used to identify the location of system calls from service request and monitor the executables at runtime, but difficult to determine the obfuscated code because code uses dynamic code generation and obfuscation techniques. This technique hides the win32 API calls at runtime. Malicious code can interact with operating system through Win32 API usage. Malicious executables can hide their win32 API usage during Static analysis. Our proposed approach is used to distinguish the software executables and analyze the virtual address and API names of instructions from system calls are recorded to match with the interrupt address table. The recorded instructions are found in Address table, the services are forwarded to kernel mode. Filter is mainly focus on separating the address belongs to its local id and remote id for validating the dispatch id in system service dispatch table. Through filter using the process creation algorithm to finalize it service request from legitimate user. The overall processing is done by user mode before the injected code entering into the kernel mode. © 2013 IEEE."
"Scheller T., Kühn E." $ "Usability evaluation of configuration-based API design concepts" $ "Usability is an important quality attribute for designing APIs, but usability-related decision factors are often unknown. This is also the case when looking at APIs for configuration tasks, like for dependency injection or object-relational mapping. In these areas three different API design concepts can be found, which are annotations, fluent interfaces, and XML. There exists no research concerning usability-related characteristics and differences between these concepts. In this paper, we present a usability study that identifies such characteristics and differences between the three concepts, by comparing three different variants of an API for dependency injection. From the study results we evaluate advantages and disadvantages in different use cases, and show how to build more usable configuration-based APIs. © 2013 Springer-Verlag."
"Hofmeyr S., Colmenares J.A., Iancu C., Kubiatowicz J." $ "Juggle: Addressing extrinsic load imbalances in SPMD applications on multicore computers" $ "We investigate proactive dynamic load balancing on multicore systems, in which threads are continually migrated to reduce the impact of processor/thread mismatches. Our goal is to enhance the flexibility of the SPMD-style programming model and enable SPMD applications to run efficiently in multiprogrammed environments. We present Juggle, a practical decentralized, user-space implementation of a proactive load balancer that emphasizes portability and usability. In this paper we assume perfect intrinsic load balance and focus on extrinsic imbalances caused by OS noise, multiprogramming and mismatches of threads to hardware parallelism. Juggle shows performance improvements of up to 80 % over static load balancing for oversubscribed UPC, OpenMP, and pthreads benchmarks. We also show that Juggle is effective in unpredictable, multiprogrammed environments, with up to a 50 % performance improvement over the Linux load balancer and a 25 % reduction in performance variation. We analyze the impact of Juggle on parallel applications and derive lower bounds and approximations for thread completion times. We show that results from Juggle closely match theoretical predictions across a variety of architectures, including NUMA and hyper-threaded systems. © 2012 Springer Science + Business Media, LLC (outside the USA)."
"Aigner W., Hoffmann S., Rind A." $ "EvalBench: A software library for visualization evaluation" $ "It is generally acknowledged in visualization research that it is necessary to evaluate visualization artifacts in order to provide empirical evidence on their effectiveness and efficiency as well as their usability and utility. However, the difficulties of conducting such evaluations still remain an issue. Apart from the required know-how to appropriately design and conduct user studies, the necessary implementation effort for evaluation features in visualization software is a considerable obstacle. To mitigate this, we present EvalBench, an easy-to-use, flexible, and reusable software library for visualization evaluation written in Java. We describe its design choices and basic abstractions of our conceptual architecture and demonstrate its applicability by a number of case studies. EvalBench reduces implementation effort for evaluation features and makes conducting user studies easier. It can be used and integrated with third-party visualization prototypes that need to be evaluated via loose coupling. EvalBench supports both, quantitative and qualitative evaluation methods such as controlled experiments, interaction logging, laboratory questionnaires, heuristic evaluations, and insight diaries. © 2013 The Author(s) Computer Graphics Forum © 2013 The Eurographics Association and Blackwell Publishing Ltd."
"Othman A.T., Khan S., Nauman M., Musa S." $ "Towards a high-level trusted computing API for android software stack" $ "Smartphone platforms are fast becoming the de-facto method of online communication. Android is one of the most promising smartphone platforms with backing of both the finances of industry leaders and the technical skills and expertise of the open source community. These two factors combined with the usability of application design on the Android platform has propelled the platform in the fore-front of technological innovations. However, along with this wide acceptance by the community come large risks associated with privacy, security and trust. Users share very sensitive data of a very personal nature on their smartphones. Protection of this data is of immense importance if the adoption of smartphones is to be continued. Similar threats on the pc have been countered using the concepts of Trusted Computing - a highly flexible trust mechanism with strong security properties. The Android platform has yet to see any Trusted Computing applications primarily because of the difficulty in adopting the relatively new paradigm of security. In this paper, we present the design of a high-level api that allows existing Android developers to adopt Trusted Computing and use it in their applications without having to learn the intricate details of how Trusted Computing works. The api will help the developers to increase the security of their applications and the data that they consume. Copyright © 2013 ACM."
"Parashar H.J., Sachdeva S., Batra S." $ "Enhancing access to standardized clinical application for mobile interfaces" $ "As Electronic Health Records (EHRs) become more prevalent in health care, research is needed to understand the efficacy within clinical contexts for a standard based health application. The current research explores 'Opereffa' to be used for handheld moveable devices. Opereffa stands for openEHR REFerence Framework and Application. It is a project for creating an open source clinical application, which will be driven by the Clinical Review Board of openEHR [2]. It is based on openEHR standard which combines structure of archetypes and terminology codes. This is the first effort for its exploration on mobile devices. The aim is to generate an application programming interface for Android based mobile for its testing on a sample set of archetypes. Later, we will extend this research to other mobile operating systems. The study has been done for increasing the usability and reach ability of EHRs. It enhances data sharing through mobile for standardized EHRs (through use of archetypes). © 2013 Springer-Verlag Berlin Heidelberg."
"Earls J.C., Eddy J.A., Funk C.C., Ko Y., Magis A.T., Price N.D." $ "AUREA: An open-source software system for accurate and user-friendly identification of relative expression molecular signatures" $ "Background: Public databases such as the NCBI Gene Expression Omnibus contain extensive and exponentially increasing amounts of high-throughput data that can be applied to molecular phenotype characterization. Collectively, these data can be analyzed for such purposes as disease diagnosis or phenotype classification. One family of algorithms that has proven useful for disease classification is based on relative expression analysis and includes the Top-Scoring Pair (TSP), k-Top-Scoring Pairs (k-TSP), Top-Scoring Triplet (TST) and Differential Rank Conservation (DIRAC) algorithms. These relative expression analysis algorithms hold significant advantages for identifying interpretable molecular signatures for disease classification, and have been implemented previously on a variety of computational platforms with varying degrees of usability. To increase the user-base and maximize the utility of these methods, we developed the program AUREA (Adaptive Unified Relative Expression Analyzer)-a cross-platform tool that has a consistent application programming interface (API), an easy-to-use graphical user interface (GUI), fast running times and automated parameter discovery.Results: Herein, we describe AUREA, an efficient, cohesive, and user-friendly open-source software system that comprises a suite of methods for relative expression analysis. AUREA incorporates existing methods, while extending their capabilities and bringing uniformity to their interfaces. We demonstrate that combining these algorithms and adaptively tuning parameters on the training sets makes these algorithms more consistent in their performance and demonstrate the effectiveness of our adaptive parameter tuner by comparing accuracy across diverse datasets.Conclusions: We have integrated several relative expression analysis algorithms and provided a unified interface for their implementation while making data acquisition, parameter fixing, data merging, and results analysis 'point-and-click' simple. The unified interface and the adaptive parameter tuning of AUREA provide an effective framework in which to investigate the massive amounts of publically available data by both 'in silico' and 'bench' scientists. AUREA can be found at http://price.systemsbiology.net/AUREA/. © 2013 Earls et al, licensee BioMed Central Ltd."
"Ameddah H., Assas M." $ "Three-dimensional (3D) bio-cad modeling of human knee" $ "In the past three decades, the fast growing technology of Computer-Aided Design and Computer-Aided Manufac- turing (CAD/CAM) has been continuously developed and applied to many fields in engineering, manufacturing, entertainment, and medicine. While maturing in some of the fields, CAD/CAM is still in developing stages in the medical and prototyping arena. Medical images (X-ray, CT, MR) of human organs are widely used in the everyday clinical praxis. A deeper insight of the anatomical properties can be obtained by building a three dimensional computer model from the images. In order to properly evaluate the 2D images and also the 3D objects engineers need efficient and robust graphical and geometrical tools. The purpose of this paper was to establish a procedure for attaining 3D solid models of the human knee. Solid models of the distal end of the femur and the tibial plateau were created to approximate the human knee (tibio-femoral joint). To create these models, points taken from magnetic resonance images (MRI) were first processing by methods for edge detect- ing using Matlab toolbox image processing and then converted to a point cloud in each cross section. From here, B-spline was created points in each cross section. Finally, these B-spline were lofted together to form a 3D solid model. The results of this paper are the first to develop image processing 3D visualization in Solidworks Application Programming Interface (API) using Visual Basic Language. The system performance is tested using MRI data, and 3D physical models Knee for MRP are created directly from Solidworks. © 2013 American Scientific Publishers All rights reserved."
"Lord P." $ "The Semantic Web takes wing: Programming ontologies with Tawny-OWL" $ "The Tawny-OWL library provides a fully-programmatic environment for ontology building, it enables the use of a rich set of tools for ontology development by recasting development as a form of programming. It is built in Clojure - a modern Lisp dialect, and is backed by the OWL API. Used simply, it has a similar syntax to OWL Manchester syntax, but it provides arbitrary extensibility and abstraction. It builds on existing facilities for Clojure, which provides a rich and modern programming tool chain, for versioning, distributed development, build, testing and continuous integration. In this paper, we describe the library, this environment and the its potential implications for the ontology development process."
"Rabkin A., Reiss C., Katz R., Patterson D." $ "Using clouds for MapReduce measurement assignments" $ "We describe our experiences teaching MapReduce in a large undergraduate lecture course using public cloud services and the standard Hadoop API. Using the standard API, students directly experienced the quality of industrial big-data tools. Using the cloud, every student could carry out scalability benchmarking assignments on realistic hardware, which would have been impossible otherwise. Over two semesters, over 500 students took our course. We believe this is the first large-scale demonstration that it is feasible to use pay-as-you-go billing in the cloud for a large undergraduate course. Modest instructor effort was sufficient to prevent students from overspending. Average per-pupil expenses in the Cloud were under $45. Students were excited by the assignment: 90% said they thought it should be retained in future course offerings. © 2013 ACM."
"Hoxha J., Maleshkova M., Korevaar P." $ "Knowledge discovery meets linked APIs" $ "Knowledge Discovery and Data Mining (KDD) is a very wellestablished research field with useful techniques that explore patterns and regularities in large relational, structured and unstructured datasets. Theoretical and practical development in this field have led to useful and scalable solutions for the tasks of pattern mining, clustering, graph mining, and predictions. In this paper, we demonstrate that these approaches represent great potential to solve a series of problems and make further optimizations in the setting of Web APIs, which have been significantly increasing recently. In particular, approaches integrating Web APIs and Linked Data, also referred to as Linked APIs, provide novel opportunities for the application of synergy approaches with KDD methods. We give insights on several aspects that can be covered through such synergy approach, then focus, specifically, on the problem of API usage mining via statistical relational learning.We propose a Hidden Relational Model, which explores the usage of Web APIs to enable analysis and prediction. The benefit of such model lies on its ability to capture the relational structure of API requests. This approach might help not only to gain insights about the usage of the APIs, but most importantly to make active predictions on which APIs to link together for creating useful mashups, or facilitating API composition. Copyright © 2013 for the individual papers by the papers' authors."
"Agarwal D., Prasad S.K." $ "Azure BOT: A framework for bag-of-tasks applications on the azure cloud platform" $ "Windows Azure is an emerging cloud platform that provides application developers with APIs to write scientific and commercial applications. However, the steep learning curve to understand the unique architecture of the cloud platforms in general and continuously changing Azure APIs specifically, make it difficult for the application developers to write cloud based applications. During our extensive experience with Azure cloud platform over the past few years, we have identified the need of a framework to abstract the complexities of working with the Azure cloud platform. Such a framework is essential for adoption of cloud technologies. Therefore, we have created AzureBOT-A framework for the Azure cloud platform to write bag-of-tasks class of distributed applications. Azure provides a straightforward and general interface that permits developers to concentrate on their application logic rather than cloud interaction. While we have implemented AzureBOT on Azure cloud platform, our framework design is generic to most of the cloud platforms. In this paper, we present the detailed design of our framework's internal architecture, the APIs in brief, and the usability of our framework. We also discuss the implementation of two different applications and their scalability results over 100Azure worker processors. © 2013 IEEE."
"Cao Y., Hua Y., Zhao J., Guo S." $ "Design and implementation of surrounding transaction plotting and management system based on Google map API" $ "With China's rapid economic development and comprehensive national strength growing, Border work has become a long-term and important task in China's diplomatic work. How to implement rapid plotting, real-time sharing and mapping surrounding affairs has taken great significance for government policy makers and diplomatic staff. However, at present the already exists Boundary information system are mainly have problems of Geospatial data update is heavily workload, plotting tools are in a state of serious lack of, Geographic events are difficult to share, this phenomenon has seriously hampered the smooth development of the border task. The development and progress of Geographic information system technology especially the development of Web GIS offers the possibility to solve the above problems, this paper adopts four layers of B/S architecture, with the support of Google maps service, uses the free API which is offered by Google maps and its features of openness, ease of use, sharing characteristics, highresolution images to design and implement the surrounding transaction plotting and management system based on the web development technology of ASP.NET, C#, Ajax. The system can provide decision support for government policy makers as well as diplomatic staff's real-time plotting and sharing of surrounding information. The practice has proved that the system has good usability and strong real-time."
"Szydzik T., Nunez A., De Paepe L., Albani L." $ "Contributions to visualization algorithm enabling GPU-accelerated image displaying for dual panel high dynamic range LCD display" $ "High dynamic range displays based on dual panel LCD are a viable option for building a low-cost solution for providing high bit depth visualization systems. One of the factors limiting the usability of this type of displays are the computation requirements of the algorithm necessary for correct visualization using the two stacked panels. In this work we present the methodology and the results of mapping this algorithm on a CPU+GPU platform using the OpenCL 1.1 API. Visualization of a 2048×2048 image when executed on a CPU+GPU (AMD Radeon V7800) platform is performed up to 7.6 times faster then when only the CPU is used. The first results are promising and encourage the use of GPUs (or APUs) for acceleration of this kind of processing. © 2013 University of Trieste and University of Zagreb."
"Thung F., Lo D., Jiang L." $ "Detecting similar applications with collaborative tagging" $ "Detecting similar applications are useful for various purposes ranging from program comprehension, rapid prototyping, plagiarism detection, and many more. McMillan et al. have proposed a solution to detect similar applications based on common Java API usage patterns. Recently, collaborative tagging has impacted software development practices. Various sites allow users to give various tags to software systems. In this study, we would like to complement the study by McMillan et al. by leveraging another source of information aside from API usage patterns, namely software tags. We have performed a user study involving several participants and the results show that collaborative tagging is a promising source of information useful for detecting similar software applications. © 2012 IEEE."
"Dai S., Wei T., Zou W." $ "DroidLogger: Reveal suspicious behavior of Android applications via instrumentation" $ "As the mobile devices increased rapidly in recent years, mobile malware is becoming a severe threat to users. Traditional malware detection uses signature-based methods, but these methods can be evaded by obfuscation or polymorphism. So the behavior-based detection techniques were proposed recently. To capture the apps' behavior, previous works either use OS level tool such as strace to capture system call, or intercept high level API by modifying the virtual machine. However, the information retrieved from the former method is too difficult to understand the program's behavior, and the technique used in latter method requires to modify the emulator, which it is not compatible when the Android version upgrade. In this paper, we proposed a new light-weight method to understand the applications' behavior by logging program's API and corresponding arguments. We build the logging system DroidLogger, which instruments the logging code into the application binary, and prints out the API usage information at run time. We analyzed several malware and show DroidLogger can reveal the malicious behavior effectively. © 2012 AICIT."
"Groce A., Fern A., Pinto J., Bauer T., Alipour A., Erwig M., Lopez C." $ "Lightweight automated testing with adaptation-based programming" $ "This paper considers the problem of testing a container class or other modestly-complex API-based software system. Past experimental evaluations have shown that for many such modules, random testing and shape abstraction based model checking are effective. These approaches have proven attractive due to a combination of minimal requirements for tool/language support, extremely high usability, and low overhead. These ""lightweight"" methods are therefore available for almost any programming language or environment, in contrast to model checkers and concolic testers. Unfortunately, for the cases where random testing and shape abstraction perform poorly, there have been few alternatives available with such wide applicability. This paper presents a generalizable approach based on reinforcement learning (RL), using adaptation-based programming (ABP) as an interface to make RL-based testing (almost) as easy to apply and adaptable to new languages and environments as random testing. We show how learned tests differ from random ones, and propose a model for why RL works in this unusual (by RL standards) setting, in the context of a detailed large-scale experimental evaluation of lightweight automated testing methods. © 2012 IEEE."
"Andersch M., Chi C.C., Juurlink B." $ "Using OpenMP superscalar for parallelization of embedded and consumer applications" $ "In the past years, research and industry have introduced several parallel programming models to simplify the development of parallel applications. A popular class among these models are task-based programming models which proclaim ease-of-use, portability, and high performance. A novel model in this class, OpenMP Superscalar, combines advanced features such as automated runtime dependency resolution, while maintaining simple pragma-based programming for C/C++. OpenMP Superscalar has proven to be effective in leveraging parallelism in HPC workloads. Embedded and consumer applications, however, are currently still mainly parallelized using traditional thread-based programming models. In this work, we investigate how effective OpenMP Superscalar is for embedded and consumer applications in terms of usability and performance. To determine the usability of OmpSs, we show in detail how to implement complex parallelization strategies such as ones used in parallel H.264 decoding. To evaluate the performance we created a collection of ten embedded and consumer benchmarks parallelized in both OmpSs and Pthreads. © 2012 IEEE."
"Ghosh S., Liao T., Calandra H., Chapman B.M." $ "Experiences with OpenMP, PGI, HMPP and OpenACC directives on ISO/TTI kernels" $ "GPUs are slowly becoming ubiquitous devices in High Performance Computing, as their capabilities to enhance the performance per watt of compute intensive algorithms as compared to multicore CPUs have been identified. The primary shortcoming of a GPU is usability, since vendor specific APIs are quite different from existing programming languages, and it requires a substantial knowledge of the device and programming interface to optimize applications. Hence, lately a growing num- ber of higher level programming models are targeting GPUs to alleviate this problem. The ultimate goal for a high-level model is to expose an easy-to-use interface for the user to offload compute intensive portions of code (kernels) to the GPU, and tune the code according to the target accelerator to maximize overall performance with a reduced development effort. In this paper, we share our experiences of three of the notable high-level directive based GPU programming models - PGI, CAPS and OpenACC (from CAPS and PGI) on an Nvidia M2090 GPU. We analyze their performance and programmability against Isotropic (ISO)/Tilted Transversely Isotropic (TTI) finite differ- ence kernels, which are primary components in the Reverse Time Migration (RTM) application used by oil and gas exploration for seismic imaging of the sub-surface. When ported to a single GPU using the mentioned directives, we observe an average 1.5-1.8x improvement in performance for both ISO and TTI kernels, when compared with optimized multi-threaded CPU implementations using OpenMP. © 2012 IEEE."
"Martioli E., Teeple D., Manset N., Devost D., Withington K., Venne A., Tannock M." $ "Open source pipeline for ESPaDOnS reduction and analysis" $ "OPERA is a Canada-France-Hawaii Telescope (CFHT) open source collaborative software project currently under development for an ESPaDOnS echelle spectro-polarimetric image reduction pipeline. OPERA is designed to be fully automated, performing calibrations and reduction, producing one-dimensional intensity and polarimetric spectra. The calibrations are performed on two-dimensional images. Spectra are extracted using an optimal extraction algorithm. While primarily designed for CFHT ESPaDOnS data, the pipeline is being written to be extensible to other echelle spectrographs. A primary design goal is to make use of fast, modern object-oriented technologies. Processing is controlled by a harness, which manages a set of processing modules, that make use of a collection of native OPERA software libraries and standard external software libraries. The harness and modules are completely parametrized by site configuration and instrument parameters. The software is open-ended, permitting users of OPERA to extend the pipeline capabilities. All these features have been designed to provide a portable infrastructure that facilitates collaborative development, code re-usability and extensibility. OPERA is free software with support for both GNU/Linux and MacOSX platforms. The pipeline is hosted on SourceForge under the name ""opera-pipeline"". This article concentrates on the design and software development of OPERA, whereas a forthcoming paper will present the details of the scientific methods employed by OPERA. © 2012 SPIE."
"Zeidler C., Müller J., Lutteroth C., Weber G." $ "Comparing the usability of grid-bag and constraint-based layouts" $ "While the usability of GUI design methods has been studied in general, the usability of layout specification methods is largely unexplored. In this paper we provide an empirical comparison of two popular GUI layout models, grid-bag layout and constraint-based layout. While the grid-bag layout is a powerful layout model, the constraint-based layout is able to generate even more general and flexible layout configurations. We performed a controlled experiment with postgraduate students of Computer Science and Software Engineering, measuring efficiency, accuracy and preference for typical layout specification and editing tasks. The results show significant differences between both layout models: the initial specification of GUIs is faster with a grid-bag layout whereas editing of existing complex layouts is faster and more accurate with a constraint-based layout. The study shows that constraint-based layout, although it may seem more complicated at first glance, can compete with and in some cases even outperform more conventional techniques in terms of their usability. © 2012 ACM."
"Podziewski A., Litwiniuk K., Legierski J." $ "E-health oriented application for mobile phones" $ "This paper presents the idea of using mobile operators APIs with an e-health usage scenario. Since numerous elderly people are going missing every year, proposed emergency location service presents a way in which mobile operators' networks, the Internet and possibilities given by rapid improvement of phones' functionalities can converge in order to relieve the problem. The description of presented solution is supplemented with sets of accuracy measurements and usability tests, conducted during test deployment. The results confirm usability potential of the service, giving green light for further research and development. Still, in order to make the service reliable, the algorithms used to determine location and detect falls need to be improved. The article presents a method, which may be used to improve the location accuracy."
"Mayer C., Hanenberg S., Robbes R., Tanter É., Stefik A." $ "An empirical study of the influence of static type systems on the usability of undocumented software" $ "Although the study of static and dynamic type systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems in languages such as Java or C++ is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease flexibility, which may make them harder to use. While these arguments are found in the literature, rigorous empirical evidence is lacking. We report on a controlled experiment where 27 subjects performed programming tasks on an undocumented API with a static type system (requiring type annotations) as well as a dynamic type system (which does not). Our results show that for some tasks, programmers had faster completion times using a static type system, while for others, the opposite held. We conduct an exploratory study to try and theorize why."
"[No author name available]" $ "Human-Centered Software Engineering - 4th International Conference, HCSE 2012, Proceedings" $ "The proceedings contain 28 papers. The topics discussed include: a compositional model for gesture definition, a development process for usable large scale interactive critical systems: application to satellite ground segments, agile user experience development in a large software organization: good expertise but limited impact, smartphone applications usability evaluation: a hybrid model and its implementation, methods towards API usability: a structural analysis of usability problem categories, putting dementia into context: a selective literature review of assistive applications for users with dementia and their caregivers, puzzle: a visual-based environment for end user development in touch-based mobile phones, towards conflict management in user interface composition driven by business needs, a model for assessing organizational learning in software development organizations, and a personality based design approach using subgroup discovery."
"Farhadi-Niaki F., GhasemAghaei R., Arya A." $ "Empirical study of a vision-based depth-sensitive human-computer interaction system" $ "This paper proposes the results of a user study on vision-based depth-sensitive input system for performing typical desktop tasks through arm gestures. We have developed a vision-based HCI prototype to be used for our comprehensive usability study. Using the Kinect 3D camera and OpenNI software library we implemented our system with high stability and efficiency by decreasing the ambient disturbing factors such as noise or light condition dependency. In our prototype, we designed a capable algorithm using NITE toolkit to recognize arm gestures. Finally, through a comprehensive user experiment we compared our natural arm gestures to the conventional input devices (mouse/keyboard), for simple and complicated tasks, and in two different situations (small and big-screen displays) for precision, efficiency, ease-of-use, pleasantness, fatigue, naturalness, and overall satisfaction to verify the following hypothesis: on a WIMP user interface, the gesture-based input is superior to mouse/keyboard when using big-screen. Our empirical investigation also proves that gestures are more natural and pleasant to be used than mouse/keyboard. However, arm gestures can cause more fatigue than mouse. Copyright 2012 ACM."
"Selmeci A., Orosz T." $ "SAP remote communications" $ "SAP implemented a very deep level synchronous connection type based on industry standards, but early enough, in the first releases SAP enhanced this to Remote Function Call protocol and technology. The Remote Function Call technology opened the system to other SAP systems or external applications. Remote function call (RFC) is the fundamental technique for many different communication approaches within SAP solutions. Our document tries to uncover the different capabilities and usability of the SAP communication types like CPI-C, RFC, Q-API, tRFC, etc. In our study we figured out that main points of remote communication usage in a heterogeneous environment where SAP also in place are the business level communication from other SAP system or external application via business application programming interface (BAPI), and the loosely coupled distributed system environment, the ALE (application link enabling) communications based on RFCs. ©2012 IEEE."
"Mayer C., Hanenberg S., Robbes R., Tanter E., Stefik A." $ "An empirical study of the influence of static type systems on the usability of undocumented software" $ "Although the study of static and dynamic type systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems in languages such as Java or C++ is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease flexibility, which may make them harder to use. While these arguments are found in the literature, rigorous empirical evidence is lacking. We report on a controlled experiment where 27 subjects performed programming tasks on an undocumented API with a static type system (requiring type annotations) as well as a dynamic type system (which does not). Our results show that for some tasks, programmers had faster completion times using a static type system, while for others, the opposite held. We conduct an exploratory study to try and theorize why. Copyright © 2012 ACM."
"Mishima H., Aerts J., Katayama T., Bonnal R.J.P., Yoshiura K.-I." $ "The Ruby UCSC API: Accessing the UCSC genome database using Ruby" $ "Background: The University of California, Santa Cruz (UCSC) genome database is among the most used sources of genomic annotation in human and other organisms. The database offers an excellent web-based graphical user interface (the UCSC genome browser) and several means for programmatic queries. A simple application programming interface (API) in a scripting language aimed at the biologist was however not yet available. Here, we present the Ruby UCSC API, a library to access the UCSC genome database using Ruby.Results: The API is designed as a BioRuby plug-in and built on the ActiveRecord 3 framework for the object-relational mapping, making writing SQL statements unnecessary. The current version of the API supports databases of all organisms in the UCSC genome database including human, mammals, vertebrates, deuterostomes, insects, nematodes, and yeast.The API uses the bin index-if available-when querying for genomic intervals. The API also supports genomic sequence queries using locally downloaded *.2bit files that are not stored in the official MySQL database. The API is implemented in pure Ruby and is therefore available in different environments and with different Ruby interpreters (including JRuby).Conclusions: Assisted by the straightforward object-oriented design of Ruby and ActiveRecord, the Ruby UCSC API will facilitate biologists to query the UCSC genome database programmatically. The API is available through the RubyGem system. Source code and documentation are available at https://github.com/misshie/bioruby-ucsc-api/ under the Ruby license. Feedback and help is provided via the website at http://rubyucscapi.userecho.com/. © 2012 Mishima et al., licensee BioMed Central Ltd."
"Andersch M., Chi C.C., Juurlink B." $ "Programming parallel embedded and consumer applications in OpenMP superscalar" $ "In this paper, we evaluate the performance and usability of the parallel programming model OpenMP Superscalar (OmpSs), apply it to 10 different benchmarks and compare its performance with corresponding POSIX threads implementations. Copyright © 2012 ACM."
"Uddin G., Dagenais B., Robillard M.P." $ "Temporal analysis of API usage concepts" $ "Software reuse through Application Programming Interfaces (APIs) is an integral part of software development. The functionality offered by an API is not always accessed uniformly throughout the lifetime of a client program. We propose Temporal API Usage Pattern Mining to detect API usage patterns in terms of their time of introduction into client programs. We detect concepts as distinct groups of API functionality from the change history of a client program. We locate those concepts in the client change history and detect temporal usage patterns, where a pattern contains a set of concepts that were added into the client program in a specific temporal order. We investigated the properties of temporal API usage patterns through a multiple-case study of three APIs and their use in up to 19 client software projects. Our technique was able to detect a number of valuable patterns in two out of three of the APIs investigated. Further investigation showed some patterns to be relatively consistent between clients, produced by multiple developers, and not trivially derivable from program structure or API documentation. © 2012 IEEE."
"Zhang C., Yang J., Zhang Y., Fan J., Zhang X., Zhao J., Ou P." $ "Automatic parameter recommendation for practical API usage" $ "Programmers extensively use application programming interfaces (APIs) to leverage existing libraries and frameworks. However, correctly and efficiently choosing and using APIs from unfamiliar libraries and frameworks is still a non-trivial task. Programmers often need to ruminate on API documentations (that are often incomplete) or inspect code examples (that are often absent) to learn API usage patterns. Recently, various techniques have been proposed to alleviate this problem by creating API summarizations, mining code examples, or showing common API call sequences. However, few techniques focus on recommending API parameters. In this paper, we propose an automated technique, called Precise, to address this problem. Differing from common code completion systems, Precise mines existing code bases, uses an abstract usage instance representation for each API usage example, and then builds a parameter usage database. Upon a request, Precise queries the database for abstract usage instances in similar contexts and generates parameter candidates by concretizing the instances adaptively. The experimental results show that our technique is more general and applicable than existing code completion systems, specially, 64% of the parameter recommendations are useful and 53% of the recommendations are exactly the same as the actual parameters needed. We have also performed a user study to show our technique is useful in practice. © 2012 IEEE."
"Pradel M., Jaspan C., Aldrich J., Gross T.R." $ "Statically checking API protocol conformance with mined multi-object specifications" $ "Programmers using an API often must follow protocols that specify when it is legal to call particular methods. Several techniques have been proposed to find violations of such protocols based on mined specifications. However, existing techniques either focus on single-object protocols or on particular kinds of bugs, such as missing method calls. There is no practical technique to find multi-object protocol bugs without a priori known specifications. In this paper, we combine a dynamic analysis that infers multi-object protocols and a static checker of API usage constraints into a fully automatic protocol conformance checker. The combined system statically detects illegal uses of an API without human-written specifications. Our approach finds 41 bugs and code smells in mature, real-world Java programs with a true positive rate of 51%. Furthermore, we show that the analysis reveals bugs not found by state of the art approaches. © 2012 IEEE."
"Schreckling D., Posegga J., Hausknecht D." $ "Constroid: Data-centric access control for android" $ "We introduce Constroid, a data-centric security policy management framework for Android. It defines a new middleware which allows the developer to specify well defined data items of fine granularity. For these data items, Constroid administrates security policies which are based on the usage control model. They can only be modified by the user of an application not by the applications itself. We use Con-stroid's middle-ware to protect the security policies, ensure consistency between a data item and its corresponding security policy, and describe how our prototype implementation can enforce a subset of possible usage control policies. In this way, our contribution shows how we overcome the rigid API-driven approach to security in Android. The structure and implementation of our framework is presented and discussed in terms of security, performance, and usability. © 2012 ACM."
"Wu Y., Shao P." $ "Middleware-based distributed data acquisition and control in smart home networks" $ "For each of the networking techniques widely adopted in the field of home appliance control has its strength and weakness, it is more desirable to use multiple network technologies at the same time. Multi-platform smart home system would be an objective existence. In general point to point method, with the increasing of underlying hardware units and upper applications, the complexity of the central control unit will increase linearly. By using a universal home control middleware adapter, we decouple the application layer from the hardware layer, and make it possible to enable distributed data acquisition and control in a multi-platform smart home system. Many validated methods efficient to implement distributed data acquisition and control are discussed under this architecture, like using a timer or special thread with the unified API of the middleware adapter, redefinition callback or delegation functions for one type of the application interface, or using middleware integrated database to directly save the collected data. For each of these discussed methods, higher quality and usability both of devices and user interfaces, higher performance, lower production costs and loose-coupled hardware networks of different technologies are concerned. © 2012 Springer-Verlag GmbH."
"Gruetz R., Focke N.K., Hoheisel A., Krefting D., Loehnhardt B., Viezens F., Dickmann F." $ "Enabling parallel computing of a brain connectivity map using the MediGRID-infrastructure and FSL" $ "The non-invasive method to track fibers of the human brain by analyzing diffusion weighted magnetic resonance images improves research of human brain structures and becomes therefore increasingly important. With fiber tracking, a connectivity map which depicts the degree of connectivity of the single voxels can be generated and used to improve knowledge about the human brain. Several tools exist to produce connectivity maps. One of them is part of the FMRIB Software Library (FSL) and free for non-commercial purposes. Due to long and therefore impracticable computing time on small computer cluster solutions, a GUI and the necessary software were implemented for the German MediGRID infrastructure. This was achieved by using wrapper scripts and a workflow for the Generic Workflow Execution Service (GWES). The solution is about 15 times faster than a small local cluster installation, depending on the number of employed MediGRID resources. This enables processing of connectivity maps for practical use in biomedical research. By using the D-Grid infrastructure, this solution is also suitable for small institutes without compute center capacities. For usability reasons, the GUI ConBrain was developed. © 2012 IEEE."
"Lo D., Ramalingam G., Ranganath V.-P., Vaswani K." $ "Mining quantified temporal rules: Formalism, algorithms, and evaluation" $ "Libraries usually impose constraints on how clients should use them. Often these constraints are not well-documented. In this paper, we address the problem of recovering such constraints automatically, a problem referred to as specification mining. Given some client programs that use a given library, we identify constraints on the library usage that are (almost) satisfied by the given set of clients. The class of rules we target for mining combines simple binary temporal operators with state predicates (composed of equality constraints) and quantification. This is a simple yet expressive subclass of temporal properties (LTL formulae) that allows us to capture many common API usage rules. We focus on recovering rules from execution traces and apply classical data mining concepts to be robust against bugs (API usage rule violations) in clients. We present new algorithms for mining rules from execution traces. We show how a propositional rule mining algorithm can be generalized to treat quantification and state predicates in a unified way. Our approach enables the miner to be complete (i.e. , mine all rules within the targeted class that are satisfied by the given traces) while avoiding an exponential blowup. We have implemented these algorithms and used them to mine API usage rules for several Windows APIs. Our experiments show the efficiency and effectiveness of our approach. © 2010 Elsevier B.V. All rights reserved."
"Bauer V., Heinemann L." $ "Understanding API usage to support informed decision making in software maintenance" $ "Reuse of third-party libraries promises significant productivity improvements in software development. However, dependencies on external libraries and their APIs also introduce risks to a project and impact strategic decisions during development and maintenance. Informed decision making therefore requires a thorough understanding of the extent and nature of dependencies on external APIs. As realistically sized applications are often heavily entangled with various external APIs, gaining this understanding is infeasible with manual inspections only. To address this, we present an automated approach to analyze the dependencies of software projects on external APIs. The approach is supported by a static analysis tool featuring a visualization of the analysis results. We evaluate the approach as well as the tooling on multiple open source Java systems. © 2012 IEEE."
"Mühlberg J.T., Lüttgen G." $ "Verifying compiled file system code" $ "This article presents a case study on retrospective verification of the Linux Virtual File System (VFS), which is aimed at checking violations of API usage rules and memory properties. Since VFS maintains dynamic data structures and is written in a mixture of C and inlined assembly, modern software model checkers cannot be applied. Our case study centres around our novel automated software verification tool, the SOCA Verifier, which symbolically executes and analyses compiled code.We describe how this verifier deals with complex features such as memory access, pointer aliasing and computed jumps in the VFS implementation, while reducing manual modelling to a minimum. Our results show that the SOCA Verifier is capable of analysing the complex Linux VFS implementation reliably and efficiently, thereby going beyond traditional testing tools and into niches that current software model checkers do not reach. This testifies to the SOCA Verifier's suitability as an effective and efficient bug-finding tool during the development of operating system components. © 2011 BCS."
"Andersch M., Chi C.C., Juurlink B." $ "Programming parallel embedded and consumer applications in openmp superscalar" $ "In this paper, we evaluate the performance and usability of the parallel programming model OpenMP Superscalar (OMPSS), apply it to 10 different benchmarks and compare its performance with corresponding POSIX threads implementations."
"Kim I.-H., Jeong G.-M., Park E.-C., Chung K.-D." $ "A WPAN platform design in mobile phone considering application development and usability" $ "In this paper, we propose a WPAN (Wireless Personal Area Network) platform for converged network services integrating a cellular network and a WPAN. We mainly focus on an easy-to-develop and easy-to-use WPAN platform for wireless communication services using both networks. The proposed WPAN platform consists of a WPAN handset platform, a WPAN connection scheme, and a WPAN server platform. The WPAN handset platform provides abstract WPAN API (Application Programming Interface) set and application management module. Using the WPAN connection scheme, the user can enjoy converged network services in a convenient way. The WPAN server platform manages the overall services and digital devices that are connected to the handset. Compared to the existing WPAN related platform, we consider the need for the integrated service components allowing for the development of WPAN applications in the handset and their convenience for the user. Also, illustrative services and devices are implemented using the proposed method, which show the applicability of the proposed WPAN platform. © 2006-2012 by CCC Publications."
"Wang L., Zou Y., Fang L., Xie B., Yang F." $ "An exploratory study of API usage examples on the web" $ "Usage examples are helpful for programmers learning to use APIs from third-party frameworks or libraries. There are lots of usage examples scattered in web pages on the Web, such as tutorials, blogs, and forums. A few researches have proposed approaches to leveraging these usage examples to improve programming. However, due to the lack of comprehensive understanding on the current situation of usage examples on the web, the work is still at the very beginning. Many concerns are reserved, for instance, how many usage examples can be found on the Web? how well do such examples support programmers on earth? what factors have impact on these examples' usability? In this paper, we conducted an exploratory study of usage examples on the web, including their distribution, characteristics like content style, correctness, and complexity, as well as their correlations. Through the study, we obtain some insight of how to facilitate utilization of usage examples on the web and what mechanisms could be provided. Possible research directions and problems are proposed at the end. © 2012 IEEE."
"Saulnier A., Courounet P., Viaud M.L." $ "How to increase the role of users in evaluating the quality of use of a system [Comment accroître le rôle des utilisateurs dans l'évaluation de la qualité d'utilisation d'un système]" $ "This paper presents criteria and methods which were used to evaluate the usability of several professional services within the European project ASSETS. A unified approach of user-centered method is proposed to test services at various stages of development according to their GUI or API access. The notion of perceived usability and utility are introduced to increase the user involvement in the evaluation process. In our professional context, we tried to highlight the relevance of the perceived quality of the results. © 2012 ACM 978-1-4503-1846-4/12/10 ...$15.00."
"De Luca V., Epicoco I., Lezzi D., Aloisio G." $ "GRB-WAPI, a RESTful framework for grid portals" $ "Nowadays grid portals are characterized by various and different features and are implemented in very differing programming languages and technologies, still having many structural aspects in common. This paper describes a RESTful Web API, named GRB-WAPI, specifically developed for grid computing that encapsulates all grid control and computation logic need to build a grid portal. Through the adoption of this API a portal developer does not have to deal with grid technical details focusing just on the high level design of her system and on some other aspects that concern presentation, such as portal usability and functionality. The idea of developing a traditional library has been discarded in order to free portal developers from a particular implementation technology. Thanks to this choice the portal presentation logic can be implemented in any web technology and can be deployed on a different server. Traditional Web Services and SOAP protocol approach has been discarded in order to adopt a RESTful approach to make the Web APIs lighter and also to take advantage of some other aspects illustrated in the paper. © 2012 Published by Elsevier Ltd."
"Alnusair A., Zhao T." $ "Retrieving reusable software components using enhanced representation of domain knowledge" $ "This paper describes an ontology-based approach for identifying and retrieving relevant software components in large reuse libraries. Since it is usually difficult to precisely identify exact matches without considering domain knowledge, we exploit the use of domain-specific ontologies to enrich a knowledge base initially populated with multi-faceted ontological descriptions of API components. In addition to pure semantic-based search, this enriched knowledge base supports signature-based search, keyword search, and blended search. However, our experiments show evidence that only semantic search that is backed by reasoning services enables intelligent matchmaking and yields improved precision. Based on a usability case study, we further argue that semantic search is indeed usable and practical. © 2012 Springer-Verlag/Wien."
"Zibran M.F., Eishita F.Z., Roy C.K." $ "Useful, but usable? Factors affecting the usability of APIs" $ "Software development today has been largely dependent on the use of API libraries, frameworks, and reusable components. However, the API usability issues often increase the development cost (e.g., time, effort) and lower code quality. In this regard, we study 1,513 bug-posts across five different bug repositories, using both qualitative and quantitative analysis. We identify the API usability issues that are reflected in the bug-posts from the API users, and distinguish relative significance of the usability factors. Moreover, from the lessons learned by manual investigation of the bug-posts, we provide further insight into the most frequent API usability issues. © 2011 IEEE."
"Brunet J., Serey D., Figueiredo J." $ "Structural conformance checking with design tests: An evaluation of usability and calability" $ "Verifying whether a software meets its functional requirements plays an important role in software development. However, this activity is necessary, but not sufficient to assure software quality. It is also important to check whether the code meets its design specification. Although there exists substantial tool support to assure that a software does what it is supposed to do, verifying whether it conforms to its design remains as an almost completely manual activity. In a previous work, we proposed design tests - test-like programs that automatically check implementations against design rules. Design test is an application of the concept of test to design conformance checking. To support design tests for Java projects, we developed DesignWizard, an API that allows developers to write and execute design tests using the popular JUnit testing framework. In this work, we present a study on the usability and scalability of DesignWizard to support structural conformance checking through design tests. We conducted a qualitative usability evaluation of DesignWizard using the Think Aloud Protocol for APIs. In the experiment, we challenged eleven developers to compose design tests for an open-source software project. We observed that the API meets most developers' expectations and that they had no difficulties to code design rules as design tests. To assess its scalability, we evaluated DesignWizard's use of CPU time and memory consumption. The study indicates that both are linear functions of the size of software under verification. © 2011 IEEE."
"Uddin G., Dagenais B., Robillard M.P." $ "Analyzing temporal API usage patterns" $ "Software reuse through Application Programming Interfaces (APIs) is an integral part of software development. As developers write client programs, their understanding and usage of APIs change over time. Can we learn from long-term changes in how developers work with APIs in the lifetime of a client program? We propose Temporal API Usage Mining to detect significant changes in API usage. We describe a framework to extract detailed models representing addition and removal of calls to API methods over the change history of a client program. We apply machine learning technique to these models to semi-automatically infer temporal API usage patterns, i.e., coherent addition of API calls at different phases in the life-cycle of the client program. © 2011 IEEE."
"Mar L.W., Wu Y.-C., Jiau H.C." $ "Recommending proper API code examples for documentation purpose" $ "Code examples are important resources for expressing correct application programming interface (API) usages. However, many framework and library APIs fail in offering sufficient code examples in corresponding API documentations. This is because constructing proper code examples for documentation purpose takes significant developers' efforts. To reduce such effort, this work proposes a methodology, PropER-Doc, that recommends proper code examples for documentation purpose. PropER-Doc accepts queries from API developers and utilizes code search engines (CSEs) to collect corresponding code example candidates. The structural and conceptual links between API elements are captured from the API implementation and available API documents to guide candidate recommendation. During recommendation, PropER-Doc groups collected candidates based on involved API types for distinguishing different API usages. To assist API developers in selecting proper candidates, a diagrammatic presentation and three code example appropriateness metrics are also developed in PropER-Doc. Two case studies on Eclipse JDT framework are conducted to confirm the effectiveness of PropER-Doc. © 2011 IEEE."
"Wang L., Fang L., Wang L., Li G., Xie B., Yang F." $ "APIExample: An effective web search based usage example recommendation system for java APIs" $ "Programmers often learn how to use an API by studying its usage examples. There are many usage examples scattered in web pages on the Internet. However, it often takes programmers much effort to find out the desired examples from a large number of web pages by web search. This paper proposes a tool named APIExample that can extract usage examples for java APIs from web pages on the Internet and recommend them to programmers. Given a java API, the tool collects its related web pages from the Internet, extracts java code snippets and their surrounding descriptive texts embedded in the pages, then assembles them into usage examples for programmers. Furthermore, in order to help programmers capture more kinds of usages of the target API by browsing fewer examples, our tool clusters and ranks the listed examples based on the target API's usage. Besides, as a practical tool, APIExample provides multiple aspects of frequently-used information about using the target API in a concise user interface with friendly user experience. Two kinds of user-interaction style, a web search portal and an Eclipse plug-in, are now both publicly available. © 2011 IEEE."
"Lu H.K." $ "Accessing cloud through API in a more secure and usable way" $ "A common method for accessing and managing cloud computing resources is through an Application Programming Interface (API). Each API request from an application must include a client authentication to the cloud service, which proves the possession of a secret key. Securing such keys is critical to the confidentiality, integrity, and availability of the data and services hosted in the cloud. Currently users manually handle these keys, a process that is neither secure nor user-friendly. Where to store the keys and how to access them are still security challenges especially for those applications that reside in the cloud themselves. Furthermore, keys are in clear text at least in a computer's memory. Attackers can find ways to recover them. This paper presents a solution to these problems by using portable security devices. The device securely exchanges keys with the cloud serve, securely stores the keys, and performs cryptographic computations using these keys for the client authentication. The user must have the device and authenticate to it in order use it. The solution enables a two-factor hierarchical security protection of the cloud computing resources. It not only enhances the security but also improves the usability. Copyright © 2011 SciTePress."
"Stefik A., Siebert S., Stefik M., Slattery K." $ "An empirical comparison of the accuracy rates of novices using the quorum, perl, and randomo programming languages" $ "We present here an empirical study comparing the accuracy rates of novices writing software in three programming languages: Quorum, Perl, and Randomo. The first language, Quorum, we call an evidence-based programming language, where the syntax, semantics, and API designs change in correspondence to the latest academic research and literature on programming language usability. Second, while Perl is well known, we call Randomo a Placebo-language, where some of the syntax was chosen with a random number generator and the ASCII table. We compared novices that were programming for the first time using each of these languages, testing how accurately they could write simple programs using common program constructs (e.g., loops, conditionals, functions, variables, parameters). Results showed that while Quorum users were afforded significantly greater accuracy compared to those using Perl and Randomo, Perl users were unable to write programs more accurately than those using a language designed by chance. © 2011 ACM."
"Kocur L.A., Glotzbach R.J., Schulze D.G., Miller C.C." $ "Work in progress - Development and integration of an online soil mapping Web application" $ "Mapping technologies are abundant on the Web as well as through boxed software, however, the ability to overlay ones own maps onto the surface in order to provide enriched detail is not found in most typical software. ""Integrating Spatial Educational Experiences (Isee) into Crop, Soil, and Environmental Science Curricula"" is a USDA-funded project focused on making soil data in the form of maps more accessible and easy-to-use for undergraduate students. The current solution integrates the Google Earth API, GeoWebCache, PHP, MySQL, and JavaScript in the form of a website. Although the differences in GIS software usability are generally unknown, the Isee prototype may serve as a viable model of an approach applicable at other universities. The purpose of the research is to collect quantitative data to determine if differences in software with various interfaces influence a student's satisfaction and performance. The ""Isee"" website will be among the compared software, in which students will attempt to answer questions based on the information they can find with the software. The researcher will record performance data quantitatively throughout the session. Afterwards, students will report preferences and perceptions in a survey. © 2011 IEEE."
"Dentler K., Cornet R., Ten Teije A., De Keizer N." $ "Comparison of reasoners for large ontologies in the OWL 2 EL profile" $ "This paper provides a survey to and a comparison of state-of-the-art Semantic Web reasoners that succeed in classifying large ontologies expressed in the tractable OWL 2 EL profile. Reasoners are characterized along several dimensions: The first dimension comprises underlying reasoning characteristics, such as the employed reasoning method and its correctness as well as the expressivity and worst-case computational complexity of its supported language and whether the reasoner supports incremental classification, rules, justifications for inconsistent concepts and ABox reasoning tasks. The second dimension is practical usability: whether the reasoner implements the OWL API and can be used via OWLlink, whether it is available as Protégé plugin, on which platforms it runs, whether its source is open or closed and which license it comes with. The last dimension contains performance indicators that can be evaluated empirically, such as classification, concept satisfiability, subsumption checking and consistency checking performance as well as required heap space and practical correctness, which is determined by comparing the computed concept hierarchies with each other. For the very large ontology SNOMED CT, which is released both in stated and inferred form, we test whether the computed concept hierarchies are correct by comparing them to the inferred form of the official distribution. The reasoners are categorized along the defined characteristics and benchmarked against well-known biomedical ontologies. The main conclusion from this study is that reasoners vary significantly with regard to all included characteristics, and therefore a critical assessment and evaluation of requirements is needed before selecting a reasoner for a real-life application. © 2011 - IOS Press and the authors. All rights reserved."
"Park P., Jung J., Huh B." $ "Development of CAN-1394 automotive gateway system using designed modular software stack" $ "Recently, software diversity and reuse issues in automotive embedded software development have rapidly increased due to newly released technologies and its standardization. The modular design of software is essential to enhance software re-usability and portability. In this paper, we present a CAN-1394 Automotive gateway system implementation using modular designs of software stacks. We first study and summarize key specifications and their relationships in 1394 Automotive software stack development. Then, we present our modular implementation of software and hardware, which includes 1394 Automotive core stack components such as a communication driver and API library. In addition, we highlight essential functions of the implemented gateway for the 1394 Automotive backbone network and the CAN based in-vehicle network in detail. © 2011 IEEE."
"De Vocht L., Softic S., Ebner M., Mühlburger H." $ "Semantically driven social data aggregation interfaces for research 2.0" $ "We propose a framework to address an important issue in the context of the ongoing adoption of the ""Web 2.0"" in science and research, often referred to as ""Science 2.0"" or ""Research 2.0"". A growing number of people are linked via acquaintances and online social networks such as Twitter1allows indirect access to a huge amount of ideas. These ideas are contained in a massive human information flow [35]. That users of these networks produce relevant data is being shown in many studies [1][2][28][36]. The problem however lies in discovering and verifying such a stream of unstructured data items. Another related problem is locating an expert that could provide an answer to a very specific research question. We are using semantic technologies (RDF2,SPARQL3), common vocabularies(SIOC4, FOAF5,SWRC6) and Linked Data (DBpedia 7, GeoNames8, CoLinDa9) [3][4][5] to extract and mine the data about scientific events out of context of microblogs. Hereby we are identifying persons and organization related to them based on entities of time, place and topic. The framework provides an API that allows quick access to the information that is analyzed by our system. As a proof-of-concept we explain, implement and evaluate such a researcher profiling use case. It involves the development of a framework that focuses on the proposition of researches based on topics and conferences they have in common. This framework provides an API that allows quick access to the analyzed information. A demonstration application: ""Researcher Affinity Browser"" shows how the API supports developers to build rich internet applications for Research 2.0. This application also introduces the concept ""affinity"" that exposes the implicit proximity between entities and users based on the content users produced. The usability of a demonstration application and the usefulness of the framework itself are investigated with an explicit evaluation questionnaire. This user feedback led to important conclusions about successful achievements and opportunities to further improve this effort."
"Khatoon S., Mahmood A., Li G." $ "An evaluation of source code mining techniques" $ "This paper reviews the tools and techniques which rely only on data mining methods to determine patterns from source code such as programming rules, copy paste code segments, and API usage. The work provides comparison and evaluation of the current state-of-the-art in source code mining techniques. Furthermore it identifies the essential strengths and weaknesses of individual tools and techniques to make an evaluation indicative of future potential. The pervious related works only focus on one specific pattern being mined such as special kind of bug detection. Thus, there is a need of multiple tools to test and find potential information from software which increase cost and time of development. Hence there is a strong need of tool which helps in developing quality software by automatically detecting different kind of bugs in one pass and also provides code reusability for the developers. © 2011 IEEE."
"Hou D., Li L." $ "Obstacles in using frameworks and APIs: An exploratory study of programmers' newsgroup discussions" $ "Large software frameworks and APIs can be hard to learn and use, impeding software productivity. But what are the specific challenges that programmers actually face when using frameworks and APIs in practice? What makes APIs hard to use, and what can be done to alleviate the problems associated with API usability and learnability? To explore these questions, we conducted an exploratory study in which we manually analyzed a set of newsgroup discussions about specific challenges that programmers had about a software framework. Based on this set of data, we identified several categories of obstacles in using APIs. We discussed what could be done to help overcome these obstacles. © 2011 IEEE."
"Pankratius V., Knittel F., Masing L., Walser M." $ "OpenMPspy: Leveraging quality assurance for parallel software" $ "OpenMP is widely used in practice to create parallel software, however, software quality assurance tool support is still immature. OpenMPspy introduces a new approach, with a short-term and a long-term perspective, to aid software engineers write better parallel programs in OpenMP. On the one hand, OpenMPspy acts like an online-debugger that statically detects problems with incorrect construct usage and which reports problems while programmers are typing code in Eclipse. We detect simple slips as well as more complex anti-patterns that can lead to correctness problems and performance problems. In addition, OpenMPspy can aggregate statistics about OpenMP language usage and bug patterns from many projects. Insights generated from such data help OpenMP language designers improve the usability of constructs and reduce error potential, thus enhancing parallel software quality in the long run. Using OpenMPspy, this paper presents one of the first detailed empirical studies of over 40 programs with more than 4 million lines of code, which shows how OpenMP constructs are actually used in practice. Our results reveal that constructs believed to be frequently used are actually rarely used. Our insights give OpenMP language and compiler designers a clearer picture on where to focus the efforts for future improvements. © 2011 Springer-Verlag."
"Benmerar T.Z., Boumghar F.O." $ "Toward a cloud architecture for medical imagery grid applications: The Acigna-G project" $ "Acigna-G is a new Grid Computing platform we propose, for hosting and interacting with GNU/Linux Grid applications through a web portal, without or with a minimal API use. It aims to provide a convenient Cloud Service for Medical Imagery Grid applications. It extends our GIC architecture with an implementation of a light version of the Virtually-distribution Parallel Architecture and the Multi-level Services architecture that permit the deployment of distributed Grid applications onto our platform. We propose these architecture as solutions to achieve both the convenience of PaaS Cloud services and the richness of Grid applications. We show how we deploy a MAS segmentation algorithm for Medical Imagery onto our Acigna-G platform. © 2011 IEEE."
"Hofmeyr S., Colmenares J.A., Iancu C., Kubiatowicz J." $ "Juggle: Proactive load balancing on multicore computers" $ "We investigate proactive dynamic load balancing on multicore systems, in which threads are continually migrated to reduce the impact of processor/thread mismatches to enhance the flexibility of the SPMD-style programming model, and enable SPMD applications to run efficiently in multiprogrammed environments. We present Juggle, a practical decentralized, user-space implementation of a proactive load balancer that emphasizes portability and usability. Juggle shows performance improvements of up to 80% over static balancing for UPC, OpenMP, and pthreads benchmarks. We analyze the impact of Juggle on parallel applications and derive lower bounds and approximations for thread completion times. We show that results from Juggle closely match theoretical predictions across a variety of architectures, including NUMA and hyper-threaded systems. We also show that Juggle is effective in multiprogrammed environments with unpredictable interference from unrelated external applications. © 2011 ACM."
"De Luca V., Epicoco I., Lezzi D., Aloisio G." $ "A web API framework for developing grid portals" $ "In this paper we describe a grid problem solving environment we developed for financial applications. We based its development on a portlet framework we have specifically developed and on a set of Web APIs that encapsulate all grid control and computation logic. Even though nowadays grid portals are characterized by various and different features and are implemented in very differing programming languages and technologies, we thought that they have many structural aspects in common. For this reason we decided to design and implement a set of Grid specific Web APIs, that we called GRB WAPI. Through them, a portal developer will not have to deal with grid technical details and will be able to manage a high level design. A portal developer will be able to concentrate on some other aspects that concern presentation, such as portal usability and functionality. We discarded the idea of developing a traditional library in order to free portal developers from a particular implementation technology. Thanks to this choice the portal presentation logic can be implemented in any web technology and can be on a different server. © 2011 Published by Elsevier Ltd."
"Gerken J., Jetter H.-C., Zöllner M., Mader M., Reiterer H." $ "The concept maps method as a tool to evaluate the usability of APIs" $ "Application programming interfaces (APIs) are the interfaces to existing code structures, such as widgets, frameworks, or toolkits. Therefore, they very much do have an impact on the quality of the resulting system. So, ensuring that developers can make the most out of them is an important challenge. However standard usability evaluation methods as known from HCI have limitations in grasping the interaction between developer and API as most IDEs (essentially the GUI) capture only part of it. In this paper we present the Concept Map method to study the usability of an API over time. This allows us to elicit the mental model of a programmer when using an API and thereby identify usability issues and learning barriers and their development over time. Copyright 2011 ACM."
"Membarth R., Hannig F., Teich J., Körner M., Eckert W." $ "Frameworks for multi-core architectures: A comprehensive evaluation using 2D/3D image registration" $ "The development of standard processors changed in the last years moving from bigger, more complex, and faster cores to putting several more simple cores onto one chip. This changed also the way programs are written in order to leverage the processing power of multiple cores of the same processor. In the beginning, programmers had to divide and distribute the work by hand to the available cores and to manage threads in order to use more than one core. Today, several frameworks exist to relieve the programmer from such tasks. In this paper, we present five such frameworks for parallelization on shared memory multi-core architectures, namely OpenMP, Cilk++, Threading Building Blocks, RapidMind, and OpenCL. To evaluate these frameworks, a real world application from medical imaging is investigated, the 2D/3D image registration. In an empirical study, a fine-grained data parallel and a coarse-grained task parallel parallelization approach are used to evaluate and estimate different aspects like usability, performance, and overhead of each framework. © 2011 Springer-Verlag."
"Leal J.P., Dias H." $ "A framework to develop meta web interfaces" $ "Web interfaces are used nowadays for virtually every kind of computer application. The proliferation of web interfaces created the need to collect and analyze data on how users interact with them. Many web applications used for this purpose rely on what can be called a meta web interface. Meta web interfaces are used for different purposes but they share a set of common features: a web interface based on the subject interface with a second layer interface for collecting data, a central repository for persisting the collected data, and an API for retrieving aggregated data on user interaction. This paper describes Z-Web - a framework for developing meta web interfaces that provides these three features. To create a second layer in the meta web interface a Z-Web server is placed as a proxy between the web client and the subject web server and injects modifications while forwarding HTTP requests. These modifications are typically JavaScript libraries that collect and store data related to user interaction. The framework caches the pages it proxies and provides persistent storage for the collected data. An application interface (API) makes this data available to client application supported by Z-Web. This paper presents an overview of Z-Web, with the general architecture of a web application based on this framework, and describes the design and implementation issues of its main components. Two systems developed with Z-Web are also presented to evaluate the applicability of the framework and its overhead when compared with similar systems."
"Nasehi S.M., Maurer F." $ "Unit tests as API usage examples" $ "t This study aims to find out if API unit tests can provide good usage examples, and if so, what prevents developers from finding and using those examples. The results of an experiment we performed with two groups of developers showed that unit tests can be very helpful, especially when the task is complicated and involves multiple classes and methods. Well-written tests proved to be a good source of examples, but finding the relevant examples using the standard tools might be very difficult. We propose to supplement the standard API documentation with relevant examples taken from the unit tests. To further improve the learnability of the API, presentation of the documentation and examples has to be tailored in a way that separates or hides advanced usage scenarios from the commonly used ones. © 2010 IEEE."
"Pradel M., Bichsel P., Gross T.R." $ "A framework for the evaluation of specification miners based on finite state machines" $ "Software maintenance tasks, such as testing and program understanding, can benefit from formal specifications that describe how a program should use an API. Recently, there has been increasing interest in specification miners that automatically extract finite state specifications of method ordering constraints from existing software. However, comparing different mining approaches is difficult, because no common ground to evaluate the effectiveness of specification miners has been established yet. We present a framework for evaluating to which extent specification miners find valid finite state descriptions of API usage constraints. The framework helps in creating reference specifications and includes metrics to compare mined specifications to the reference specifications. The metrics are tailored for evaluating specification miners and account for imprecision and incompleteness in mined specifications. We use the framework to compare the effectiveness of three mining approaches and to show their respective benefits. © 2010 IEEE."
"Bajracharya S.K., Ossher J., Lopes C.V." $ "Leveraging usage similarity for effective retrieval of examples in code repositories" $ "Developers often learn to use APIs (Application Programming Interfaces) by looking at existing examples of API usage. Code repositories contain many instances of such usage of APIs. However, conventional information retrieval techniques fail to perform well in retrieving API usage examples from code repositories. This paper presents Structural Semantic Indexing (SSI), a technique to associate words to source code entities based on similarities of API usage. The heuristic behind this technique is that entities (classes, methods, etc.) that show similar uses of APIs are semantically related because they do similar things. We evaluate the effectiveness of SSI in code retrieval by comparing three SSI based retrieval schemes with two conventional baseline schemes. We evaluate the performance of the retrieval schemes by running a set of 20 candidate queries against a repository containing 222,397 source code entities from 346 jars belonging to the Eclipse framework. The results of the evaluation show that SSI is effective in improving the retrieval of examples in code repositories. © 2010 ACM."
"Zeller A." $ "Learning from 6,000 projects: Mining models in the large" $ "Models-abstract and simple descriptions of some artifact-are the backbone of all software engineering activities While writing models is hard, existing code can serve as a source for abstract descriptions of how software behaves. To infer correct usage, code analysis needs usage examples, though, the more, the better. We have built a lightweight parser that efficiently extracts API usage models from source code-models that can then be used to detect anomalies. Applied on the 200 million lines of code of the Gentoo Linux distribution, we would extract more than 15 million API constraints, encoding and abstracting the ""wisdom of Linux code"" © 2010 IEEE."
"Zibin Y." $ "Jury API: Secure client-side-only multiplayer gaming API" $ "Multiplayer gaming platforms (such as Come2Play, Skype, Nonoba, Oberon) offer game developers an API to develop new games. Having a secure API is critical to prevent hackers from unlawfully winning a game. Until today, to have a secure API, a developer had to write a server-side extension that determines the game outcome. However, a server-side extension is cumbersome to write (because you have to master two programming languages: for the client- and server-side), error-prone, hard to debug, and risky for the gaming platform that runs 3rd party code on its servers. This paper presents the first Secure client-side-only API (for short JuryAPI), i.e., the API is secure (the game outcome cannot be changed by hackers) and the API uses only client-side code (without any server-side extensions). JuryAPI mimics real-life games in which each player verifies that other players follow the game rules. In case of disagreement among the players, the server convenes a jury that finds the hacker. Using JuryAPI, one can develop secure multiplayer games using only client-side code, without using any server-side extensions. JuryAPI is an open-source standard developed by the multiplayer gaming company Come2Play, with an open-source flash emulator1. Come2Play freely hosts 3 rd party flash games and shares the revenues with the game developers."
"Jung G., Lee B." $ "Analysis on social network adoption according to the change of network topology: The impact of ""Open API"" to adoption of facebook" $ "A social network service is one of the most prospering social media in the Web 2.0 era. In SNSs, a massive number of people make online friends and share their interests. In May 2007, Facebook made an announcement of ""Open API"" policy, which allows a third-party to create applications in Facebook. After ""Open API,"" users of Facebook can utilize various interactions other than just messaging. This led to radical increase in user growth of Facebook and threatened Myspace, which was the top SNS at that time. This innovative move gathered an interest of how ""Open API"" affects interactions in social networks. The main objective of our research is to analyze the relationship between the growth of social network adoption and network topology. For this issue, our study conducts both analytical and empirical models. First of all, we adopt the concept of Metcalfe's and Reed's law to model the growth pattern of social network under duopoly competition of two SNSs. Then we apply the growth functions to the empirical analysis. We collect web traffic data of Facebook and Myspace from Alexa and test the structural change after the adoption of ""Open API"" policy. The result of the analytical model shows that social network adoption follows a quadratic growth under Metcalfe's law and an exponential growth under Reed's law. The result also shows the conditions for a SNS to take all new adopters in the market. If the SNS follows Reed's law, it can absorb all new adopters even if that particular SNS is a newcomer in the market. The empirical result confirms that there exists a significant difference in the growth pattern between, before and after ""Open API."" This implies that ""Open API"" transformed Facebook one-to-one communication network into a group forming network. Eventually, this transition increases potential connectivity in social network and leads to exponential growth of social network adoption. Copyright 2012 ACM."
"[No author name available]" $ "Evaluation and Usability of Programming Languages and Tools, PLATEAU'10" $ "The proceedings contain 8 papers. The topics discussed include: using CogTool to model programming tasks, user evaluation of correctness conditions: a case study of cooperability, the API walkthrough method, toward transforming freely available source code into usable learning materials for end-users, staking claims: a history of programming language design claims and evidence, hard-to-answer questions about code, comparing the usability of library vs. language approaches to task parallelism, and GoHotDraw: evaluating the go programming language with design patterns."
"[No author name available]" $ "2010 6th Central and Eastern European Software Engineering Conference, CEE-SECR 2010" $ "The proceedings contain 36 papers. The topics discussed include: adaptation of SCRUM methodology to company business processes, automating programming via concept mining, probabilistic reasoning over semantic knowledge base of SE domain, clone detection: why, what and how?, comparison of two models of success prediction in software development projects, conceptual models of heterogeneous data representation, defect detection for multithreaded programs with semaphore-based synchronization, effective communications for small outsourcing software-engineering projects, expert system for software source code quality analysis, header-driven generation of sanity API tests for shared libraries, implementation by capture with executable UML, implementing usability methods into CMMI-compliant software development process, integrating quality, quality in use, actual usability and user experience, and interactive 3D scene modeling and visualization system."
"Harris W." $ "Functional programming at Freebase" $ "Freebase is a community-built, online database of facts and information, developed by Metaweb Technologies in San Francisco, California [1]. Freebase uses a proprietary graph database technology to store and query a network of over 12 million interrelated topics involving several hundred million individual graph relations. Third-party applications are free to query and update the Freebase database, and do so using the Metaweb Query Language, MQL [2]. MQL queries are expressed with a JSON-based template language which makes them easy to integrate into web applications, particularly the client-side portion which is processed with JavaScript?. Metaweb's first-generation MQL implementation was written as a Python-based middle-tier application that dynamically translates JSON-based queries into a low-level proprietary graph query language and networking protocol [3]. The low-level query language was designed for efficiency rather than for direct usability, and significant effort is required to translate between the two languages. Analysis of the entire Freebase application stack has revealed that as much time was being spent in the MQL query and result translation process as was being spent actually resolving the low-level graph queries. Much of this was attributed to the memory-intensive architecture of the translator, but a large portion was attributed to overhead inherent in the Python 2.6 runtime. We have undertaken developing a second-generation MQL translator written in Ocaml and drawing on a number of pure functional techniques. The core language translation process is expressed in terms of embedded language that implements the graph query protocol. This embedded language is used for both for static queries, e.g. for schema lookups, and for expressing the dynamic translation of MQL queries. The translator operates as a server and uses Lwt (Lightweight Threads library [4]) to interleave both client and graph database requests. A web services API and monitoring console have been developed using the Ocsigen web server and associated Eliom infrastructure [5]. The performance of our reimplemented MQL translator service is very encouraging. One process can sustain over an order of magnitude more simultaneous MQL requests, and service each request in a small fraction of the time consumed by the Python implementation. Moreover, due to the asynchronous nature of the underlying Lwt I/O subsystem, a single processor core can handle several times the capacity of an entire multi-core server machine running the former Apache/WSGI/Python [6] infrastructure. In addition to describing the MQL translator system, I would like to discuss the underlying mechanism by which it batches fragments of I/O requests together into single larger protocol messages, thereby minimizing communication overhead with the underlying graph database. This technique closely resembles monads typically used in functional programming, but also provides some of the benefits of 'arrows' [7]. © 2010 ACM."
"Beach A., Gartrell M., Han R." $ "q-Anon: Rethinking anonymity for social networks" $ "This paper proposes that social network data should be assumed public but treated private. Assuming this rather confusing requirement means that anonymity models such as k-anonymity cannot be applied to the most common form of private data release on the internet, social network APIs. An alternative anonymity model, q-Anon, is presented, which measures the probability of an attacker logically deducing previously unknown information from a social network API while assuming the data being protected may already be public information. Finally, the feasibility of such an approach is evaluated suggesting that a social network site such as Facebook could practically implement an anonymous API using q-Anon, providing its users with an anonymous option to the current application model. © 2010 IEEE."
"Mileva Y.M., Dallmeier V., Zeller A." $ "Mining API popularity" $ "When designing a piece of software, one frequently must choose between multiple external libraries that provide similar services. Which library is the best one to use? We mined hundreds of open source projects and their external dependencies in order to observe the popularity of their APIs and to give recommendations of the kind: ""Projects are moving away from this API element. Consider a change."" Such wisdom of the crowds can provide valuable information to both the API users and the API producers. © 2010 Springer-Verlag."
"Kim J., Lee S., Hwang S.-W., Kim S." $ "Towards an intelligent code search engine" $ "Software developers increasingly rely on information from the Web, such as documents or code examples on Applica tion Programming Interfaces (APIs), to facilitate their devel opment processes. However, API documents of ten do not in clude enough information for developers to fully understand the API usages, while searching for good code examples re quires non-trivial effort. To address this problem, we propose a novel code search engine, combining the strength of browsing documents and searching for code examples, by returning documents embed ded with high-quality code example summaries mined from the Web. Our evaluation results show that our approach pro vides code examples with high precision and boosts program mer productivity. Copyright © 2010, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved."
"Zhang D.-H., Xie B., Chen H.-J., Lv Y., Yu L." $ "Using geodata and geoprocessing web services in embedded device" $ "Using XML web services in embedded system could be able to use the existing geodata and geoprocessing services through wired/wireless network. However, the processing and memory limitations of embedded devices exacerbate the problem in the area of complexity, constraints, and the verbosity of the protocols used in XML web services effect the usability of XML. This paper presents a GPS navigation system, which accesses OGC-compliant geodata and geoprocessing services using gSOAP toolkit. This system composes of hardware platform, embedded operation system and software system. Our experimental result shows gSOAP could provides transparent SOAP API allows embedded system using XML web services. © 2010 IEEE."
"Gimblett A., Thimbleby H." $ "User interface model discovery: Towards a generic approach" $ "UI model discovery is a lightweight formal method in which a model of an interactive system is automatically discovered by exploring the system's state space, simulating the actions of a user, such models are then amenable to automatic analysis targetting structural usability concerns. This paper specifies UI model discovery in some detail, providing a formal, generic and language-neutral API and discovery algorithm. The technique has been implemented in prototype systems on several programming platforms, yielding valuable usability insights. The API described here supports further development of these ideas in a systematic manner. © 2010 ACM."
"Kim I., Lee D., Lee J., Rim K." $ "Extended authorization mechanism in OSGi" $ "As ubiquitous computing technology evolves, open API that is a solution to interconnect heterogeneous devices and services in a more fluid manner has emerged. Among open API solutions, OSGi is a Java-based service platform that is widely used in the service gateway of home network. In home network environments, the user authentication and authorization associated user's information and usability may be important security issue. Although the current OSGi support RBAC-based authorization, it does not support various facilities in the RBAC model. The access control mechanisms for OSGi proposed so far focus on supporting the RBAC conventions with the basic form of role-user-permission mappings. However, these are difficult to support efficient access control. We propose the extended access control mechanism that includes the concepts of relative role and delegate class. We explain the proposed access control mechanism with an example of developing a simple set-top box control service. ©2010 IEEE."
"Lawall J., Laurie B., Hansen R.R., Palix N., Muller G." $ "Finding error handling bugs in OpenSSL using Coccinelle" $ "OpenSSL is a library providing various functionalities relating to secure network communication. Detecting and fixing bugs in OpenSSL code is thus essential, particularly when such bugs can lead to malicious attacks. In previous work, we have proposed a methodology for finding API usage protocols in Linux kernel code using the program matching and transformation engine Coccinelle. In this work, we report on our experience in applying this methodology to OpenSSL, focusing on API usage protocols related to error handling. We have detected over 30 bugs in a recent OpenSSL snapshot, and in many cases it was possible to correct the bugs automatically. Our patches correcting these bugs have been accepted by the OpenSSL developers. This work furthermore confirms the applicability of our methodology to user-level code. © 2010 IEEE."
"Sales L., Teófilo H., Mendonça N.C." $ "G2CL: A generic group communication layer for clustered applications" $ "Generic group communication frameworks offer several benefits to developers of clustered applications, including better software modularity and greater flexibility in selecting a particular group communication system. However, current generic frameworks only support a very limited set of group communication primitives, which has hampered their adoption by many ""real-world"" clustered applications that require higher-level group communication services, such as state transfer, distributed data structures and replicated method invocation. This paper describes the design, implementation and initial evaluation of G2CL, a Generic Group Communication Layer that offers a set of commonly used high-level group communication services implemented on top of an existing generic framework. Compared to current group communication solutions, G2CL offers two main contributions: (i) its services can be configured to run over any group communication system supported by the underlying generic framework, and (ii) it implements the same service API used by JGroups, a popular group communication toolkit, which may reduce its learning curve and make the task of migrating to G2CL particularly attractive for JGroups users. © 2010 Springer-Verlag Berlin Heidelberg."
"Liao Z., Duan X., Lu J., Yue X., Liu W., He Q." $ "The mobile LBS positioning solution based on NRTK and Windows Mobile" $ "In order to meet the requirements of Location-based Service (LBS), there are many proposed positioning solutions that may be able to provide LBS support, such as GPS, Mobile Phone Location, RFID, and so on. With the most widely recognized system being the Global Positioning System (GPS) and Windows Mobile 5.0 system characteristics, this paper first provides three kinds method, i.e. invoking Win32 API, using Ports namespace and calling GPS Intermediate Driver, to receive GPS raw data on Windows Mobile devices. Since internet-based GPS VRS RTK workstation can provide real-time streaming of differential GPS corrections. The following text introduces a high precision Net-based RTK (NRTK) mobile positioning solution which is mainly equipped with a Windows Mobile 5.0 device and an Ashtech Z-Xtreme receiver. With it a rover-side (NtripClient) firstly connects to an NtripCaster which is a part of a VRS workstation, via GPRS /CDMA, using the IP and specified listening Port of the Tongji VRS workstation. Then the rover-side transmits NMEA GGA strings after the HTTP request to the NtripCaster. With that the Windows Mobile device continuously receives RTCM data back from the NtripCaster and instantly sends them out into the Ashtech Z-Xtreme receiver. Finally, the Ashtech Z-Xtreme receiver will work out vector solution information of the rover-side. Thus, this paper provides a multimode mobile LBS positioning solution based on NRTK and Windows Mobile 5.0. © 2010 Copyright SPIE - The International Society for Optical Engineering."
"Jugel U." $ "Generating smart wrapper libraries for arbitrary APIs" $ "Library design is language design [1]. The development of a smart program library is very similar to the creation of a domain specific language (DSL). Both are currently created in an ad-hoc manner
"Resseguie D., Fairgrieve S." $ "Unifying isolated sensor systems using web 2.0 and open standards" $ "Oak Ridge National Laboratory has developed the Sensorpedia program that enables individuals, communities, and enterprises to share, find, and use sensor data online. Sensorpedia networks users based on mutual sensor information interests in place of networking them based on mutual personal interests. The program applies several design principles common to many popular Web 2.0 sites. It is a Web-based application consisting of a Google Maps interface where users can search and explore published sensor data. The interface is designed to be simple and intuitive to use for gathering and exchanging important data online. The Sensorpedia API uses Web services designed to accept and publish data using established standards, such as the Atom Syndication Format and GeoRSS. The API also supports rapid development of customized third-party applications to meet specific needs of users."
"Kim G., Suzuki Y., Nishida A., Takemiya H." $ "Development of APIs for desktop supercomputing" $ "We developed the Script Generator API to support Grid users to develop their own Grid-enabled client application. The Script Generator API automatically generates a Grid-enabled workflow script needed to execute jobs on a Grid system. The Script Generator API enables users to develop their application with the complex job flow which cannot be generated using existing workflow tools. We implemented the Script Generator API in our Grid infrastructure and utilized it to the three-dimensional virtual plant vibration simulator. By developing Grid-enabled client application for the three-dimensional virtual plant vibration simulator, we confirmed the usability of the Script Generator API. © Springer-Verlag Berlin Heidelberg 2010."
"Myers B.A., Jeong S.Y., Xie Y., Beaton J., Stylos J., Ehret R., Karstens J., Efeoglu A., Busse D.K." $ "Studying the Documentation of an API for Enterprise ServiceOriented Architecture" $ "All software today is written using application programming interfaces (APIs). We performed a user study of the online documentation of a large and complex API for Enterprise Service-Oriented Architecture (eSOA), which identified many issues and recommendations for making API documentation easier to use. eSOA is an appropriate testbed because the target users include high-level business experts who do not have significant programming expertise and thus can be classified as ""end-user developers."" Our study showed that the participants' background influenced how they navigated the documentation. Lack of familiarity with business terminology was a barrier for developers without business application experience. Both groups avoided areas of the documentation that had an inconsistent visual design. A new design for the documentation that supports flexible navigation strategies seems to be required to support the wide range of users for eSOA. This paper summarizes our study and provides recommendations for future documentation for APIs. Copyright © 2010, IGI Global."
"Pletcher D.M., Hou D." $ "BCC: Enhancing code completion for better API usability" $ "Nowadays, programmers spend much of their workday dealing with code libraries and frameworks that are bloated with APIs. One common way of interacting with APIs is through Code Completion inside the code editor. By default, Code Completion presents in a scrollable list, in alphabetical order, all accessible members available in the apparent type and supertypes of a receiver expression. This default behavior for Code Completion should and can be further improved because (1) not all public methods are APIs and presenting non-API public members to a programmer is misleading, (2) certain APIs are meant to be accessible only in some limited contexts but not others, and (3) the alphabetical order separates otherwise logically related APIs, making it hard to see their connection. BCC (Better Code Completion) addresses these problems by enhancing Code Completion so that programmers can control how specific API elements should be sorted, filtered, and grouped."
"Mühlberg J.T., Lüttgen G." $ "Verifying compiled file system code" $ "This paper presents a case study on retrospective verification of the Linux Virtual File System (VFS), which is aimed at checking for violations of API usage rules and memory properties. Since VFS maintains dynamic data structures and is written in a mixture of C and inlined assembly, modern software model checkers cannot be applied. Our case study centres around our novel verification tool, the SOCA Verifier, which symbolically executes and analyses compiled code. We describe how this verifier deals with complex program features such as memory access, pointer aliasing and computed jumps, while reducing manual modelling to the bare minimum. Our results show that the SOCA Verifier is capable of reliably analysing complex operating system components such as the Linux VFS, thereby going beyond traditional testing tools and into niches that current software model checkers do not reach. © 2009 Springer-Verlag Berlin Heidelberg."
"Kim K., Lee H., Jo S., Ryu W." $ "Implementation of open web portal service enabler based on service delivery platform" $ "This paper is to provide implementation supporting open web portal service enabler based on Service Delivery Platform(SDP). This technology is for adapter to provide the method for converging web portal Application Program Interface(API) using SDP. It united the specification of protocols and parameters per web site in order to support ""Open Method"". Also for adding the new web site and modifying the existed web site with ease, it utilized database dynamically. © 2009 IEEE."
"Focardi R., Luccio F.L., Steel G." $ "Blunting differential attacks on PIN processing APIs" $ "We propose a countermeasure for a class of known attacks on the PIN processing API used in the ATM (cash machine) network. This API controls access to the tamper-resistant Hardware Security Modules where PIN encryption, decryption and verification takes place. The attacks are differential attacks, whereby an attacker gains information about the plaintext values of encrypted customer PINs by making changes to the non-confidential inputs to a command. Our proposed fix adds an integrity check to the parameters passed to the command. It is novel in that it involves very little change to the existing ATM network infrastructure. © Springer-Verlag 2009."
"Nguyen T.T., Nguyen H.A., Pham N.H., Al-Kofahi J.M., Nguyen T.N." $ "Graph-based mining of multiple object usage patterns" $ "The interplay of multiple objects in object-oriented programming often follows specific protocols, for example certain orders of method calls and/or control structure constraints among them that are parts of the intended object usages. Unfortunately, the information is not always documented. That creates long learning curve, and importantly, leads to subtle problems due to the misuse of objects. In this paper, we propose GrouMiner, a novel graph-based approach for mining the usage patterns of one or multiple objects. GrouMiner approach includes a graph-based representation for multiple object usages, a pattern mining algorithm, and an anomaly detection technique that are efficient, accurate, and resilient to software changes. Our experiments on several real-world programs show that our prototype is able to find useful usage patterns with multiple objects and control structures, and to translate them into user-friendly code skeletons to assist developers in programming. It could also detect the usage anomalies that caused yet undiscovered defects and code smells in those programs. Copyright 2009 ACM."
"Pradel M., Gross T.R." $ "Automatic generation of object usage specifications from large method traces" $ "Formal specifications are used to identify programming errors, verify the correctness of programs, and as documentation. Unfortunately, producing them is error-prone and time-consuming, so they are rarely used in practice. Inferring specifications from a running application is a promising solution. However, to be practical, such an approach requires special techniques to treat large amounts of runtime data. We present a scalable dynamic analysis that infers specifications of correct method call sequences on multiple related objects. It preprocesses method traces to identify small sets of related objects and method calls which can be analyzed separately. We implemented our approach and applied the analysis to eleven real-world applications and more than 240 million runtime events. The experiments show the scalability of our approach. Moreover, the generated specifications describe correct and typical behavior, and match existing API usage documentation. © 2009 IEEE."
"Mentis A.S." $ "A robotics API dialect for type-safe robots: Translating Myro to Ada" $ "In this paper, we present an Ada robotics API designed to be used in teaching undergraduate-level computer science. Our API is inspired by Myro, a Python-based API, but we improve upon Myro's usability, readability, modularity, and documentation by using features of the Ada programming language and the GNAT Programming Studio's documentation generation tool. The encapsulation, abstraction, and data hiding provided by Ada's packages make it easy for beginning programmers to use the API for advanced tasks, while Ada's syntax and readability allow educators to use the underlying code later in a course or curriculum to illustrate more advanced concepts to the same students as their knowledge and experience grow. Copyright 2009 Association for Computing Machinery."
"Wurster G., Van Oorschot P.C." $ "The developer is the enemy" $ "We argue that application developers, while often viewed as allies in the effort to create software with fewer security vulnerabilities, are not reliable allies. They have varying skill sets which often do not include security. Moreover, we argue that it is inefficient and unrealistic to expect to be able to successfully teach all of the world's population of software developers to be security experts. We suggest more efficient and effective alternatives, focusing on those developers who produce core functionality used by other developers (e.g. those who develop popular APIs - Application Programming Interfaces). We discuss the benefits of designing APIs which can be easily used in a secure fashion to encourage security. We also introduce two straw-man proposals which integrate security into the work- ow of an application developer. Data tagging and unsuppressible warnings provide the basis for further work where the most natural use (path of least resistance) results in secure code. We believe there are benefits to co-opting developers into programming securely. Copyright 2008 ACM."
"Dillon R., Bee N.K., Rozner S." $ "The music and emotion driven game engine: Ideas and games" $ "In this paper we describe the ideas behind the Music and Emotion Driven Game Engine (M-EDGE), currently under development at the School of Interactive and Digital Media in Nanyang Polytechnic and fully supported by the Singapore National Research Foundation. The paper will explain a possible method for analyzing emotional content in music in real time and how it can successfully be applied to different game ideas to help defining a new interactive experience and music based gameplay in videogames."
"Donatelli M., Bellocchi G., Habyarimana E., Bregaglio S., Confalonieri R., Baruth B." $ "CLIMA: A weather generator framework" $ "Weather generators (WG) can be defined as collections of models to estimate site specific weather data and derived variables. They are commonly used for providing inputs to a variety of biophysical models or for deriving weather indices. Also, using either global circulation models or local area models inputs, sets of parameters calculated from long term weather series specific to a site can be modified to reproduce via WG synthetic series representing climate change scenarios. Finally, models implemented in WG are used for estimating missing data and to perform quality control on data collected from sensors at weather stations. The scientific foundation of models implemented in WG varies from purely empirical to physically based. Several models exist allowing either the estimate or the generation of specific weather variables, with different input requirements. New models are continuously being proposed, and, although some models to estimate specific variables are commonly accepted as reference methods, the lack of some inputs requires at times using alternate approaches. Currently available WG are applications which implement a predefined set of modelling options, in software implementations which do not allow for independent extensions by third parties. The CLIMA weather generator is a component based application which consist of a set of reusable graphical user interface (GUI) components, and a set of extensible model components. The latter are subdivided into six namespaces to estimate variables related to air temperature, rainfall, solar radiation, evapotranspiration, wind, and leaf wetness. The temporal resolution of the estimated variables varies from a day to ten minutes. Another software library allows the estimation of climatic indices from one year of daily data at the time. The current implementation consists of more than 300 models. Components are usable either via the CLIMA GUI, or via custom developed applications in a client-server architecture. The architecture of components is based on the composite and strategy as keystone design patterns. Models are implemented as single approaches (simple strategies), and as composite models (composite strategies) which are associated to models of finer granularity. Another type of model unit is represented by context strategies, which implement a logic to select within associated models. Finally, the GUI allows building composite models which can be saved as libraries, to be reused both within CLIMA for weather series generation, or independently by other applications. The components are implemented as .NET libraries. They implement a test of pre- and post-conditions, and a scalable tracing via .NET listeners. All variables and parameters are documented by a description, a physical unit and default, maximum and minimum values. Components are extensible: i.e. new models can be added independently by third parties and detected by the CLIMA application, which can also use them for data generation via building new composite libraries. Each component is made available via a software development kit which includes the code of two sample projects, either to extend or to reuse the component. CLIMA and its model components are freely available for reuse in no-profit applications."
"Kim M.S., Wellings A." $ "Refactoring asynchronous event handling in the real-time specification for Java" $ "The primary goal for asynchronous event handling (AEH) in the Real-Time Specification for Java (RTSJ) is to have a lightweight concurrency mechanism. However the RTSJ neither provides a well-defined guideline on how to implement AEH nor requires the documentation of the AEH model used in the implementation. Also the AEH API in the RTSJ are criticised as lacking in configurability as they do not provide any means for programmers to have fine control over the AEH facilities, such as the mapping between real-time threads and handlers. For these reasons, it needs the refactoring of its application programming interface (API) to give programmers more configurability. This paper, therefore, proposes a set of AEH related classes and interfaces to enable flexible configurability over AEH components. We have implemented the refactored configurable AEH API using the new specifications on an existing RTSJ implementation and this paper shows that it allows more configurability for programmers than the current AEH API in the RTSJ does. Consequently programmers are able to specifically tailor the AEH subsystem to fit their applications' particular needs. © 2009 IEEE."
"Chen N.-S., Wei C.-W., Chen W.-S." $ "Developing a GroupNet system to solve groupthink problem" $ "This study proposed the concepts, architecture, and kernel of a GroupNet system to construct a more flexible ubiquitous learning environment. GroupNet is aiming to support small-group face-to-face learning activities anywhere and anytime without sticking in traditional classroom settings and additional infrastructures. We have also implemented the application programming interface (API) for accessing the core functions supported by GroupNet Kernel such that developers can develop GroupNet applications with fewer efforts. A GroupNet application has been developed using the APIs for conducting an experiment on how to reduce groupthink phenomenon in collaborative learning setting using mobile devices to evaluate the usability of GroupNet Kernel and illustrate the effectiveness of GroupNet applications.© 2009 IEEE."
"Kawrykow D., Robillard M.P." $ "Detecting inefficient API usage" $ "Large software projects often rely on third-party libraries, made accessible through Application Programming Interfaces (APIs). We have observed many cases where APIs are used in ways that are not efficient. We developed a technique to automatically detect inefficient API usage in software projects. The main hypothesis underlying the technique is that client code that imitates the behavior of a library method without calling it is likely not to use the library as efficiently as possible. In addition to warning developers of potentially inefficient API usage, our technique also indicates how to improve the use of the API. Application of the technique on Java open-source systems revealed many cases of inefficient API usage, and corresponding recommendations that led to code improvements. © 2009 IEEE."
"De Souza C.R.B., Bentolila D.L.M." $ "Automatic evaluation of API usability using complexity metrics and visualizations" $ "APIs are one of the most important concepts in today's modern software engineering. They allow software developers to work independently and minimize the impact caused by changes in the implementation of software services. Despite their importance, currently there are only a few approaches that guide the design of an API. In this paper, we present an approach, and associated tool, that allows an API client (developer) to evaluate the usability of an API and decide whether to use it (release it). In this aspect, our approach goes beyond previous approaches by performing this complexity and usability API analysis automatically. © 2009 IEEE."
"Zhong H., Xie T., Zhang L., Pei J., Mei H." $ "MAPO: mining and recommending api usage patterns" $ "To improve software productivity, when constructing new software systems, programmers often reuse existing libraries or frameworks by invoking methods provided in their APIs. Those API methods, however, are often complex and not well documented. To get familiar with how those API methods are used, programmers often exploit a source code search tool to search for code snippets that use the API methods of interest. However, the returned code snippets are often large in number, and the huge number of snippets places a barrier for programmers to locate useful ones. In order to help programmers overcome this barrier, we have developed an API usage mining framework and its supporting tool called MAPO (Mining API usage Pattern from Open source repositories) for mining API usage patterns automatically. A mined pattern describes that in a certain usage scenario, some API methods are frequently called together and their usages follow some sequential rules. MAPO further recommends the mined API usage patterns and their associated code snippets upon programmers' requests. Our experimental results show that with these patterns MAPO helps programmers locate useful code snippets more effectively than two state-of-the-art code search tools. To investigate whether MAPO can assist programmers in programming tasks, we further conducted an empirical study. The results show that using MAPO, programmers produce code with fewer bugs when facing relatively complex API usages, comparing with using the two state-of-the-art code search tools. © 2009 Springer Berlin Heidelberg."
"Burns A., Wettings A.J." $ "Concurrency vulnerabilities" $ "Concurrency is a significant issue in the design and implementation of systems, though it brings with it a number of vulnerabilities. Many different concurrency models can be found in programming languages. Vulnerabilities from this simple model include not all tasks start their execution, premature silent termination of a task or tasks, and overflow of task-local data. Some other vulnerabilities include unintentional use of unprotected shared variables, mutual update problem, race conditions, livestocks, and memory caching. The decision not to use a concurrent programming language does not remove these vulnerabilities, many will be present in the operating system (OS) and the API used by the sequential program to gain access to the concurrency features of the OS. It is possible to take an extensive set of language features, such as those provided by Ada tasking, and define a subset so that a profile is defined that has adequate expressive power and a minimum of vulnerabilities."
"Kim G., Suzuki Y., Teshima N., Nishida A., Yamada T., Araya F., Takemiya H., Nakajima N., Kondo M." $ "A script generator API for the full-scale three-dimensional vibration simulation of an entire nuclear power plant within AEGIS" $ "We developed the Script Generator API to support users to develop Grid-enabled client application. The Script Generator API automatically generates a Grid-enabled workflow script needed to execute jobs on a Grid system. Using the Script Generator API enables users to use a Grid environment without consciousness of a Grid computing system. In this paper, we show the implementation of the Script Generator API in our Grid infrastructure and its utilization to the Full-scale 3D Vibration Simulator for an Entire Nuclear Power Plant. By developing a Gridenabled client application for the Full-scale 3D Vibration Simulator, we confirmed the usability of the Script Generator API. © Civil-Comp Press, 2009."
"Sankaranarayanan S., Ivančić F., Gupta A." $ "Mining library specifications using inductive logic programming" $ "Software libraries organize useful functionalities in order to promote modularity and code reuse. A typical library is used by client programs through an application programming interface (API) that hides its internals from the client. Typically, the rules governing the correct usage of the API are documented informally. In many cases, libraries may have complex API usage rules and unclear documentation. As a result, the behaviour of the library under some corner cases may not be well understood by the programmer. Formal specifications provide a precise understanding of the API behaviour. We propose a methodology for learning interface specifications using Inductive Logic Programming (ILP). Our technique runs several unit tests on the library in order to generate relations describing the operation of the library. The data collected from these tests are used by an inductive learner to obtain rich Datalog/Prolog specifications. Such specifications capture essential properties of interest to the user. They may be used for applications such as reverse engineering the library internals or constructing checks on the application code to enforce proper API usage along with other properties of interest. Copyright 2008 ACM."
"Beaton J., Myers B.A., Stylos J., Jeong S.Y., Xie Y." $ "Usability evaluation for Enterprise SOA APIs" $ "SAP recently began offering access to web services through its Enterprise Service-Oriented Architecture (E-SOA) platform. It is in the best interest of SAP that its E-SOA service operations are easier for developers to use and understand, which will contribute to higher E-SOA adoption, and a more effective means of innovation on the part of business customers. To facilitate such a change, Carnegie Mellon University's Human-Computer Interaction Institute is working with SAP's E-SOA and Business Process Renovation Teams to analyze the E-SOA interfaces using HCI techniques and determine means by which developers assigned to create SOA APIs in general, and Enterprise SOA APIs in particular, can design superior interfaces. The identification of usable design patterns, and methodologies to determine these patterns, can streamline SOA projects for API developers and programmers who use SOA APIs. Copyright 2008 ACM."
"Bruch M., Schäfer T., Mezini M." $ "On evaluating recommender systems for API usages" $ "To ease framework understanding, tools have been developed that analyze existing framework instantiations to extract API usage patterns and present them to the user. However, detailed quantitative evaluations of such recommender systems are lacking. In this paper we present an automated evaluation process which extracts queries and expected results from existing code bases. This enables the validation of recommendation systems with large test beds in an objective manner by means of precision and recall measures. We demonstrate the applicability of our approach by evaluating an improvement of an existing API recommender tool that takes into account the framework-method context for recommendations. Copyright 2008 ACM."
"[No author name available]" $ "RSSE '08 - Proc. 2008 International Workshop on Recommendation Systems for Software Engineering, Co-located with the 16th ACM SIGSOFT International Symposium on the Foundations of Software Engineering" $ "The proceedings contain 14 papers. The topics discussed include: recommending method invocation context changes, not all classes are created equal: toward a recommendation system for focusing testing, potentials and challenges of recommendation systems for software development, on evaluating recommender systems for API usages, dimensions of tools for detecting software conflicts, understanding interaction differences between newcomer and expert programmers, what is the long-term impact of changes?, evaluating recommended applications, seven habits of a highly effective smell detector, towards an agent-based framework for guiding design exploration, improving the readability of defect reports, and a recommendation system for security requirements."
"Yeh R.B., Paepcke A., Klemmer S.R." $ "Iterative design and evaluation of an event architecture for pen-and-paper interfaces" $ "This paper explores architectural support for interfaces combining pen, paper, and PC. We show how the eventbased approach common to GUIs can apply to augmented paper, and describe additions to address paper's distinguishing characteristics. To understand the developer experience of this architecture, we deployed the toolkit to 17 student teams for six weeks. Analysis of the developers' code provided insight into the appropriateness of events for paper UIs. The usage patterns we distilled informed a second iteration of the toolkit, which introduces techniques for integrating interactive and batched input handling, coordinating interactions across devices, and debugging paper applications. The study also revealed that programmers created gesture handlers by composing simple ink measurements. This desire for informal interactions inspired us to include abstractions for recognition. This work has implications beyond paper - designers of graphical tools can examine API usage to inform iterative toolkit development."
"Chew B.N., Chang C.W., Salinas S.V., Liew S.C." $ "Remote sensing measurements of aerosol optical thickness and correlation with in-situ air quality parameters during a biomass burning episode in Southeast Asia" $ "Smoke haze related to biomass burning is a recurring environmental problem in Southeast Asia which has affected air quality not only in the source regions, but also in the surrounding areas. Air quality monitoring stations and meteorological stations in the region provide valuable information on the concentrations of criteria pollutants such as sulphur dioxide, nitrogen oxide, carbon monoxide, ozone and particulate mass (PM 10) during the haze episodes. Due to the limited coverage of the air quality monitoring stations, it is difficult to study and monitor the spatial and temporal variability of the smoke haze caused by biomass burning, especially in areas without ground-based instrumentation. As such, in this paper, we combine the standard in-situ measurements of PM 10 with remote sensing imagery obtained from the Moderate Resolution Imaging Spectroradiometer (MODIS) on board the Terra and Aqua satellites. The columnar AOT is first derived from MODIS images for regions where PM 10 measurements are available and a correlation between AOT and PM 10 measurements is then established. Based on this empirical correlation, it is also shown that MODIS AOT can be used to estimate air quality categories as defined in the Air Pollutant Index (API) used by Malaysia's Department of Environment (DOE) and the Pollutant Standards Index (PSI) used by Singapore's National Environment Agency (NEA). With this integrated approach, we hope to complement and enhance current capabilities in monitoring air quality during the haze episodes."
"Stylos J., Myers B.A." $ "The implications of method placement on API learnability" $ "To better understand what makes Application Programming Interfaces (APIs) hard to use and how to improve them, recent research has begun studying programmers' strategies and use of APIs. It was found that method placement - - on which class or classes a method is placed - - can have large usability impact in object-oriented APIs. This was because programmers often start their exploration of an API from one ""main"" object, and were slower finding other objects that were not referenced in the methods of the main object. For example, while mailServer.send(mailMessage) might make sense, if programmers often begin their API explorations from the MailMessage class, then this makes it harder to find the MailServer class than the alternative mailMessage. send(mailServer). This is interesting because many real APIs place methods essential to common objects on other, helper objects. Alternate versions of three different APIs were compared, and it was found that programmers gravitated toward the same starting classes and were dramatically faster - - between 2 to 11 times - - combining multiple objects when a method on the starting class referred to the other class. © 2008 ACM."
"Tan Y.K.A., Kwoh L.K., Ong S.H." $ "Texture mapping of 3-D building models using pose estimation of digital photographs" $ "A virtual 3-D city is a sophisticated application of geo-informatics systems as it is a representation of layouts, activities and functionalities of a real-world community. It is an integrated effort in the fields of computer graphics, remote sensing and engineering to model the appearance and dynamics of the real world. The primary aim is to introduce a feasible, yet compelling representation of the city in the virtual world. It will be an attractive option to view and explore the building architecture of the past, present and future without being encumbered by the constraints of reality. Visualization of city models in a virtual environment is a combination of many challenging and laborious tasks, one of which is the texturing of building models façade. To improve the overall photo-realistic quality and usability of the visualization platform, we can texture the building façade with oblique-view terrestrial digital photographs taken using commercially available cameras. This paper will show that we can automatically extract the building façade textures after pose estimation of the acquired image is done. The OpenGL camera must be properly initialized with the intrinsic parameters of the actual camera before pose estimation. After which the actual camera's location and orientation can be estimated directly by matching the relative pose between the rendered 3-D scene geometry and the information from the acquired image. It is important to obtain a good estimate of the camera's pose as the recovered parameters would affect the accuracy of extracted façade textures. A test example will be used to demonstrate the system of performing texture mapping using series of close-range photographs after pose estimation was carried out."
"Beaton J., Jeong S.Y., Xie Y., Stylos J., Myers B.A." $ "Usability challenges for enterprise service-oriented architecture APIs" $ "An important part of many programming tasks is the use of libraries and other forms of Application Programming Interfaces (APIs). Programming via web services using a Service-Oriented Architecture (SOA) is an emerging form of API usage. Web services in a business context (called enterprise SOA or E-SOA) add additional complexity in terms of the number of the services, the variety of internal data structures, and service interdependencies. After altering existing Human-Computer Interaction (HCI) methodologies to address the unique context of software development for SOA, we evaluated a large E-SOA API and identified many usability challenges. Prominent results include difficulties developers encountered while assembling data structures in web service parameters, cycles of errors due to unclear control parameters within data structures, and difficulties with understanding long identifier names. We recommend a tolerance for unspecified objects in automatically-generated web service proxy code, consistent data structures in parameters across services, and encoding optional namespace schemes into WSDL files. © 2008 IEEE."
"Ratiu D., Jürjens J." $ "Evaluating the reference and representation of domain concepts in APIs" $ "As libraries are the most widespread form of software reuse, the usability of their APIs substantially influences the productivity of programmers in all software development phuses. In this paper we develop a framework to characterize domain-specific APIs along two directions: 1) how can the API users reference the domain concepts implemented by the API, 2) how are the domain concepts internally represented in the API. We define metrics that allow the API developer for example to assess the conceptual complexity of his API and the non-uniformity and ambiguities introduced by the API's internal representations of domain concepts, which makes developing and maintaining software that uses the library difficult and error-prone. The aim is to be able to predict these difficulties already during the development of the API, and based on this feedback be able to develop better APIs up front, which will reduce the risks of these difficulties later. © 2008 IEEE."
"Bellotti F., Berta R., Margarone M., De Gloria A." $ "oDect: an RFID-based object detection API to support applications development on mobile devices" $ "The RFID technology is becoming ever more popular in the development of ubiquitous computing applications. A full exploitation of the RFID potential requires the study and implementation of human-computer interaction (HCI) modalities to be able to support wide usability by the target audience. This implies the need for programming methodologies specifically dedicated to support the easy and efficient prototyping of applications to have feedback from early tests with users. On the basis of our field-working experience, we have designed oDect, a high-level language and platform-independent application programming interface (API), ad hoc designed to meet the needs of typical applications for mobile devices (smart phones and PDAs). oDect aims at allowing application developers to create their prototypes focusing on the needs of the final users, without having to care about the low-level software that interacts with the RFID hardware. Further, in an end-user developing (EUD) approach, oDect provides specific support for the application end-user herself to cope with typical problems of RFID applications in detecting objects. We describe in detail the features of the API and discuss the findings of a test with four programmers, where we analyse and evaluate the use of the API in four sample applications. We also present results of an end-user test, which investigated strengths and weaknesses of the territorial agenda (TA) concept. The TA is an RFID-based citizen guide that aids-through time- and location-based reminders-users in their daily activities in a city. The TA directly exploits EUD features of oDect, in particular concerning the possibility of linking detected objects with custom actions. Copyright © 2008 John Wiley & Sons, Ltd."
"Ivanyukovich A., Marchese M., Giunchiglia F." $ "ScienceTreks: An autonomous digital library system" $ "Purpose - The purpose of this paper is to provide support for automation of the annotation process of large corpora of digital content. Design/methodology/approach - The paper presents and discusses an information extraction pipeline from digital document acquisition to information extraction, processing and management. An overall architecture that supports such an extraction pipeline is detailed and discussed. Findings - The proposed pipeline is implemented in a working prototype of an autonomous digital library (A-DL) system called ScienceTreks that: supports a broad range of methods for document acquisition, does not rely on any external information sources and is solely based on the existing information in the document itself and in the overall set in a given digital archive, and provides application programming interfaces (API) to support easy integration of external systems and tools in the existing pipeline. Practical implications - The proposed A-DL system can be used in automating end-to-end information retrieval and processing, supporting the control and elimination of error-prone human intervention in the process. Originality/value - High quality automatic metadata extraction is a crucial step in the move from linguistic entities to logical entities, relation information and logical relations, and therefore to the semantic level of digital library usability. This in turn creates the opportunity for value-added services within existing and future semantic-enabled digital library systems. © Emerald Group Publishing Limited."
"Krumsiek J., Friedel C.C., Zimmer R." $ "ProCope - Protein complex prediction and evaluation" $ "Recent advances in high-throughput technology have increased the quantity of available data on protein complexes and stimulated the development of many new prediction methods. In this article, we present ProCope, a Java software suite for the prediction and evaluation of protein complexes from affinity purification experiments which integrates the major methods for calculating interaction scores and predicting protein complexes published over the last years. Methods can be accessed via a graphical user interface, command line tools and a Java API. Using ProCope, existing algorithms can be applied quickly and reproducibly on new experimental results, individual steps of the different algorithms can be combined in new and innovative ways and new methods can be implemented and integrated in the existing prediction framework. © The Author 2008. Published by Oxford University Press. All rights reserved."
"Balakrishnan G., Reps T." $ "Analyzing stripped device-driver executables" $ "This paper sketches the design and implementation of Device-Driver Analyzer for x86 (DDA/x86), a prototype analysis tool for finding bugs in stripped Windows device-driver executables (i.e., when neither source code nor symbol-table/debugging information is available), and presents a case study. DDA/x86 was able to find known bugs (previously discovered by source-code-based analysis tools) along with useful error traces, while having a reasonably low false-positive rate. This work represents the first known application of automatic program verification/analysis to stripped industrial executables, and allows one to check that an executable does not violate known API usage rules (rather than simply trusting that the implementation is correct). © 2008 Springer-Verlag Berlin Heidelberg."
"Kurzyniec D., Sunderam V., Sławińska M." $ "REVENTS: Facilitating event-driven distributed HPC applications" $ "Modern scientific applications that need to share geographically scattered resources and dynamically adapt to changes in the environment pose challenges to traditional parallel and distributed programming paradigms. Distributed component frameworks attempt to address the demands of contemporary HPC applications by enabling coarse-grained decomposition and loose coupling. Nonetheless, components usually communicate via synchronous RPC, which is not suitable for interactive applications. This paper introduces a novel distributed event notification system, called REVENTS, which enables both synchronous and decentralized asynchronous component interactions. The REVENTS system is based on a topic-list publisher-subscriber model. It integrates and enhances common technologies for messaging, events, and group communication. The article introduces the REVENTS API, its reference implementation, and its application in the H2O metacomputing framework. Presented experimental results confirm REVENTS' usability in distributed HPC scenarios. © 2008 Springer-Verlag Berlin Heidelberg."
"Yang Y., Chen X., Gopalakrishnan G., Kirby R.M." $ "Distributed dynamic partial order reduction based verification of threaded software" $ "Runtime (dynamic) model checking is a promising verification methodology for real-world threaded software because of its many features, the prominent ones being: (i) it avoids the need to extract a model and instead runs the actual code, and (ii) the precision of information available at run-time allows techniques such as dynamic partial order reduction (DPOR) [1] to dramatically cut down the number of interleavings examined. Unfortunately, DPOR does not have many implementations for real thread libraries such as POSIX Pthreads, and suffers from high computational overheads due to a stateless search that requires re-executions. In our previous work [2], we designed a runtime model checker, inspect, that overcomes the first of these drawbacks. Inspect has been shown capable of detecting data races, deadlocks and other incorrect API usages in real-world PThreads C programs. In this paper, we describe a distributed version of inspect, which implements an extended DPOR algorithm. Our two key contributions are: (i) a practical algorithm for distributed dynamic partial order reduction, (ii) the innovations that helped distributed inspect attain nearly linear (with respect to the number of CPUs) speedup on realistic examples. © Springer-Verlag Berlin Heidelberg 2007."
"Jian S., Wei G." $ "Development of routing application of SCA-based software defined radio" $ "Software Communications Architecture (SCA) has become the standard framework followed by the current developing software defined radios (SDR) all over the world. So it is significant for us to develop some essential applications in such an SCA-based SDR. In this paper, we propose an implementation scheme of routing application based on SCA. First, the framework and functions of SCA are introduced briefly. In the following, routing technology is discussed in such a software radio network with multi-layer dynamic topology. Based on SCA, the system architecture on which the routing application depends is presented. We put emphasis on the design of routing components and application program interface (API). Using a sequence diagram, the interaction among Routing Selection Component, Adaptive Channel Selection Component and MAC Components, is shown clearly. ©2006 IEEE."
"Kitagawa H., Watanabe Y." $ "Stream data management based on integration of a stream processing engine and databases" $ "Recent developments in network and sensor device technologies enable us to easily obtain real-world information, such as locations of moving objects, weather information, news, and stock prices. These data are continuously supplied, and they are regarded as data streams. Because of the dramatical increase of streaming data, their management and utilization has become more and more important. This paper describes a data stream management system named Harmonica. Harmonica employs an architecture combining our stream processing engine named Stream-Spinner and relational DBMSs. Based on the architecture, the system processes both continuous queries and traditional one-shot queries. Moreover, Harmonica supports continuous persistence requirements for streaming data as well as queries including selection, join, projection, and user-defined functions over data streams. Users can also specify continuous queries that integrate streaming data and persistent data stored in databases. Using the Harmonica API, users can develop a variety of applications coping with different continuous steaming data and data stored in databases. Our system can be deployed in network environments to achieve efficient and dependable distributed stream processing. © 2007 IEEE."
"Stylos J., Myers B." $ "Mapping the space of API design decisions" $ "When creating new application programming interfaces (APIs), designers must make many decisions. These decisions affect the quality of the resulting APIs in terms of performance (such as speed and memory usage), power (expressiveness, extensibility and evolvability) and usability (learnability, productivity and error prevention). Experienced API designers have written recommendations on how to design APIs, offering their opinions on various API design decisions. Additionally, empirical research has begun to measure the usability tradeoffs of specific design decisions. While previous work has offered specific suggestions, there has not been a clear description of the design space of all possible API design decisions, or the quality attributes that these decisions affect. This paper puts existing API design recommendations into context by mapping out the space of API design decisions and API quality attributes. © 2007 IEEE."
"Lim S.C., Lowe S., Koempel J." $ "Application of visual programming to Web mash up development" $ "The ongoing adoption of the latest Web development patterns such as AJAX is helping to enhance the user experience on the Web. Moreover, there is now API-based support from various vendors that allow seamless fusion of disparate data sources into a single application. However, the barrier for Web designers to integrate such features into their Web applications remains high. This hampers a wider proliferation of such novel Web applications. In this paper, we conduct an experiment to see whether visual programming is appropriate for allowing Web designers integrate the aforementioned features. For the experiment, we have developed a prototype, tentatively named WIPER that allows Web designers to incorporate pre-built JavaScript components into live Web pages using drag-and-drop. We combined rapid revision with usability testing to iteratively advance our prototype. Working with users, we have learned that with some targeted refinements, visual programming paradigm can be very effective in achieving our goal. © Springer-Verlag Berlin Heidelberg 2007."
"Juanjuan J., Koskinen J., Ruokonen A., Systä T." $ "Constructing usage scenarios for API redocumentation" $ "Software development relies heavily on reusable libraries and software components. For correct use of the provided API, proper documentation is needed. API usage is often demonstrated by giving example applications and code samples. In this paper we propose an approach for mining such usage scenarios from run-time communication between sample applications and the API. This is done automatically by first monitoring the API usage of sample applications, then filtering the generated traces, and finally synthesizing the sequence diagrams and illustrating them in a well-formed way as UML2 sequence diagrams. Such usage scenarios support the software engineer in comprehending the usage of the API. With proper tool support they can also be used for validating other applications ' API usage and for generating code for a new application using the same API. ©2007 IEEE."
"Nirnimesh, Harish P., Narayanan P.J." $ "Garuda: A scalable tiled display wall using commodity PCs" $ "Cluster-based tiled display walls can provide cost-effective and scalable displays with high resolution and a large display area. The software to drive them needs to scale too if arbitrarily large displays are to be built. Chromium is a popular software API used to construct such displays. Chromium transparently renders any OpenGL application to a tiled display by partitioning and sending individual OpenGL primitives to each client per frame. Visualization applications often deal with massive geometric data with millions of primitives. Transmitting them every frame results in huge network requirements that adversely affect the scalability of the system. In this paper, we present Garuda, a client-server-based display wall framework that uses off-the-shelf hardware and a standard network. Garuda Is scalable to large tile configurations and massive environments. It can transparently render any application built using the Open Scene Graph (OSG) API to a tiled display without any modification by the user. The Garuda server uses an object-based scene structure represented using a scene graph. The server determines the objects visible to each display tile using a novel adaptive algorithm that culls the scene graph to a hierarchy of frustums. Required parts of the scene graph are transmitted to the clients, which cache them to exploit the interframe redundancy. A multicast-based protocol is used to transmit the geometry to exploit the spatial redundancy present in tiled display systems. A geometry push philosophy from the server helps keep the clients in sync with one another. Neither the server nor a client needs to render the entire scene, making the system suitable for interactive rendering of massive models. Transparent rendering is achieved by intercepting the cull, draw, and swap functions of OSG and replacing them with our own. We demonstrate the performance and scalability of the Garuda system for different configurations of display wall. We also show that the server and network loads grow sublinearly with the increase in the number of tiles, which makes our scheme suitable to construct very large displays. © 2007 IEEE."
"Rich C., Sidner C.L." $ "DiamondHelp: A generic collaborative task guidance system" $ "DiamondHelp is a generic collaborative task guidance system motivated by the current usability crisis in high-tech home products. It combines an application-independent conversational interface (adapted from online chat programs) with an application-specific direct-manipulation interface. DiamondHelp is implemented in Java and uses Collagen for representing and using task models. Copyright © 2007, Association for the Advancement of Artificial Intelligence. All rights reserved."
"Ball T., Bounimova E., Cook B., Levin V., Lichtenberg J., McGarvey C., Ondrusek B., Rajamani S.K., Ustuner A." $ "Thorough static analysis of device drivers" $ "Bugs in kernel-level device drivers cause 85% of the system crashes in the Windows XP operating system [44]. One of the sources of these errors is the complexity of the Windows driver API itself: programmers must master a complex set of rules about how to use the driver API in order to create drivers that are good clients of the kernel. We have built a static analysis engine that finds API usage errors in C programs. The Static Driver Verifier tool (SDV) uses this engine to find kernel API usage errors in a driver. SDV includes models of the OS and the environment of the device driver, and over sixty API usage rules. SDV is intended to be used by driver developers ""out of the box."" Thus, it has stringent requirements: (1) complete automation with no input from the user, (2) a low rate of false errors. We discuss the techniques used in SDV to meet these requirements, and empirical results from running SDV on over one hundred Windows device drivers."
"[No author name available]" $ "Proceedings of the 2006 International Workshop on Mining Software Repositories, MSR '06, Co-located with the 28th International Conference on Software Engineering, ICSE 2006" $ "The proceedings contain 41 papers. The topics discussed include: mining large software compilations over time: another perspective of software evolution, scenarios for mining the software architecture evolution, productivity analysis of Japanese enterprise software development projects, coupling and cohesion measures for evaluation of component reusability, the evolution radar: visualizing integrated logical coupling information, an open framework for CVS repository querying, analysis and visualization, mining sequences of changed-files from version histories, MAPO: mining API usages from open sourch repositories, detecting similar java classes using tree algorithms, mining version archives for co-changed lines, concern based mining of heterogeneous software repositories, mining eclipse for cross-cutting concerns, predicting defect densities in source code files with decision tree learners, and mining email social networks."
"Stylos J." $ "Informing API design through usability studies of API design choices: A research abstract" $ "Using APIs is a common and often difficult task for developers. Successful API designs can guide users of an API and reduce their dependence on documentation, however API design is far from a science. Usability lab studies have been shown to be successful at improving the usability of specific APIs, however these are expensive and not always possible to run for every API. This paper describes an approach to generalize from studies of specific APIs to investigate the usability impact of design choices that commonly arise in the creation of APIs. Based on these results we will inform the design of many new APIs. A preliminary usability study of whether or not to require constructor parameters confirms our belief that the answer to common design decisions is not always obvious, and making the wrong choice can have a strong negative impact on usability for large groups of API users. © 2006 IEEE."
"Fink S., Yahav E., Dor N., Ramalingam G., Geav E." $ "Effective typestate verification in the presence of aliasing" $ "This paper addresses the challenge of sound typestate verification, with acceptable precision, for real-world Java programs. We present a novel framework for verification of typestate properties, including several new techniques to precisely treat aliases without undue performance costs. In particular, we present a flow-sensitive, context-sensitive, integrated verifier that utilizes a parametric abstract domain combining typestate and aliasing information. To scale to real programs without compromising precision, we present a staged verification system in which faster verifiers run as early stages which reduce the workload for later, more precise, stages. We have evaluated our framework on a number of real Java programs, checking correct API usage for various Java standard libraries. The results show that our approach scales to hundreds of thousands of lines of code, and verifies correctness for 93% of the potential points of failure. Copyright 2006 ACM."
"Lobato C., Garcia A., Lucena C., Romanovsky A." $ "A modular implementation framework for code mobility" $ "With the growing popularity of open distributed applications, mobile agents have naturally emerged as the fundamental technique for tackling the complexity of the emerging applications. However, the pervasive nature of code mobility issues implies that their implementation cannot be modularized based only on object-oriented (OO) abstractions and mechanisms. In fact, programmers of complex mobile agent systems frequently evidence the presence of mobility tangling and scattering in the modules of their systems. Despite these modularity breakdowns caused by code mobility, the developers have mostly relied on OO application programming interfaces (APIs) from mobility platforms and on the Java programming language. As a consequence, there is a pressing need for empowering developers with a modular implementation framework that supports a transparent, flexible incorporation of code mobility-specific capabilities into their applications. This paper presents an aspectoriented software framework, called AspectM, that ensures: (1) improved modularization of the code mobility issues, (2) a seamless introduction of code mobility into stationary agents, and (3) overall enhanced variability of the mobile agent systems, such as flexible integration of these systems with distinct mobility platforms. The usefulness and usability of the AspectM framework has been assessed in the context of two medium-sized case studies from different application domains, and through its composition with two mobility platforms. Copyright 2006 ACM."
"Pietsch M., Schlaefke A., Vogl T.J., Bergh B." $ "Development and evaluation of different methods to assess download and display time of image web systems" $ "Objectives: The aim of this study was to develop and verify different methods of measuring time-to-display (TTD) for radiological images with image web systems (IWS). The process should be automatable in order to repeatedly perform a large number of measurements without human interaction. Materials and Methods: Three methods were defined and compared with respect to usability, stability, and quality of results. Method 1 was based on Windows 2000 Performance Monitor, whereas method 2 employed phototransistors taped to the screen and connected to a separate PC. A software tool developed for method 3, which used Windows application programming interface (API) function, calls to read the color code assigned to specific pixels on the screen. Results: Method 3 proved to be the most reliable and easy to automate. The accuracy is practically equivalent to method 2, but it proved to be far more automatable. Method 1 produced the largest mean error, was easily disturbed, but was also easy to set up and provided additional insights into the system's architecture especially if combined with method 3. Conclusions: To measure the performance of image distribution systems, any of these methods can be used, but method 3 proved to be superior. © 2006 SCAR (Society for Computer Applications in Radiology)."
"Storz O., Friday A., Davies N." $ "Supporting content scheduling on situated public displays" $ "There is increasing interest in creating networks of situated public displays that offer novel forms of interaction and rich media content-often as work towards a vision of ubiquitous computing or ambient multimedia. In this paper, we present an infrastructure developed as part of the e-Campus project that is designed to support the coordinated scheduling of rich media content on networks of situated public displays. The design of the system was informed by an iterative process of developing, deploying and evaluating a set of three technology probes. The resulting system provides flexible support for the construction of domain-specific scheduling approaches on top of a common, domain-independent API. Using this approach, we are able to support a combination of both statically scheduled content and interactive content across multiple displays. The API provides support for transactional semantics, allowing developers of schedulers to reliably schedule content across displays in the presence of conflicts and failures without negative impact on running applications. © 2006 Elsevier Ltd. All rights reserved."
"Kim H.-J., Chu W.-S., Ahn S.-H., Kim D.-S., Jun C.-S." $ "Web-based design and manufacturing systems for micromachining: Comparison of architecture and usability" $ "In this paper, web-based micromachining systems are compared with a commercial CAD/CAM system from the point of educational usability. The web-based systems included in this study were Micromachining System (MIMS) and SmartFab. In the MIMS architecture, a 3D model in STL format was read using the web browser, the file was sent to the web server where toolpath planner was located, and the NC code was reviewed by the designer through the web connection. In the SmartFab system, SolidWorks was used as the design interface with modified menus that support input parameters for micromachining. This additional function was available by SolidWorks API that provided links to the same toolpath planner as MIMS. In the commercial CAD/CAM case, without using any web connection, SolidWorks and CATIA were used for design, and PowerMill was used as a CAM tool. For each system, accessibility, user-friendliness, toolpath-reliability, and processing time were compared. Total of 91 students tested these systems In an undergraduate CAD class, and the user's feedback showed better performance of the web-based system in accessibility, user-friendliness, and processing time. However, reliability of the web-based system should be improved to be more useful design and manufacturing system. © 2006 Wiley Periodicals, Inc."
"Kimpe D., Vandewalle S., Poedts S." $ "On the usability of high-level parallel IO in unstructured grid simulations" $ "For this poster, the usability of the two most common IO libraries for parallel IO was evaluated, and compared against a pure MPI-IO implementation. Instead of solely focusing on the raw transfer bandwidth achieved, API issues such as data preparation and call overhead were also taken into consideration. The access pattern resulting from parallel IO in unstructured grid applications, which is also one of the hardest patterns to optimize, was examined. © Springer-Verlag Berlin Heidelberg 2006."
"Ghosh A., Olsson M., Persson P." $ "Open application environments in mobile devices: Focus on JME and Ericsson Mobile Platforms" $ "Advances in hardware in mobile handsets are rapidly overcoming computational constraints. Similarly, handset interfaces are improving in terms of quality and usability. At the same time, wireless operators are offering increasingly faster transmission rates for data communication. The table is thus being set, as it were, to provide a feast of innovative and interesting end-user services. Not all these services are installed in end-user handsets at the time of purchase, but thanks to the adoption of open application environments, more and more handsets can download and upgrade services. Handsets with Java application environments, for example, can download games and other applications over the air. The authors provide an overview of available open application environments. In particular, they focus on the Java for Micro Edition (JME) standard, a highly popular environment being developed through the Java Community Process (JCP). They also introduce Ericsson Mobile Platform's (EMP) middleware architecture and Open Platform API (OPA), putting emphasis on how OPA and JME provide a complete product offering to Ericsson's customers, including a compelling open application environment that meets wireless operator requirements."
"Compton M." $ "Stenning's protocol implemented in UDP and verified in Isabelle" $ "This paper is about the mechanical verification of UDP based network programs. It uses the UDP portion of a formal model of the Internet protocols TCP (Transmission Control Protocol) and UDP (User Datagram Protocol). The model includes asynchronous message passing, message loss and host failure. The model is based around the sockets library, the primary API used for writing UDP and TCP based applications. This paper demonstrates that formal, machine-checked, proof is possible in the UDP model by presenting the proof of a safety property for an implementation of Stenning's Protocol. The protocol is implemented in a fragment of the OCaml language, using the sockets library for UDP network communication. The entire development including the safety proof is carried out in the proof assistant Isabelle, this assures soundness. Thus this paper demonstrates that it is possible to machine verify very concrete representations of distributed programs in a detailed semantics that accurately reflects the programs execution environment. Previously only abstract representations of this protocol have been machine verified. The proof, based on an implementation, provides a contrast to other verifications. © 2005, Australian Computer Society, Inc."
"Czarnul P., Fra̧czak M." $ "New user-guided and ckpt-based checkpointing libraries for parallel MPI applications" $ "We present design and implementation details as well as performance results for two new parallel checkpointing libraries developed by us for parallel MPI applications. The first one, a user-guided library requires from the programmer to support packing and unpacking code with an easy-to-use API using MPI constants. It uses MPI-2 collective I/O calls or a dedicated master process for checkpointing. The other version is a technically advanced parallel implementation of checkpointing based on the user-level ckpt library. It uses wrappers for MPI calls in the user program which enables to run a shadow MPI application just for communication purposes. Communication between original processes and the shadow MPI code is done via shared memory segments to which communication buffers are mapped. We present checkpoint/restart times for the two approaches and subversions proposed by us compared to an available LAMMPI/BLCR checkpointing solution for MPI applications. The performance of all the versions and I/O optimizations are discussed for a 4-node, 16-processor cluster with NFS and specifically for single SMP nodes with a local file system. © Springer-Verlag Berlin Heidelberg 2005."
"Chanda A., Elmeleegy K., Cox A.L., Zwaenepoel W." $ "Causeway: Support for controlling and analyzing the execution of multi-tier applications" $ "Causeway provides runtime support for the development of distributed meta-applications. These meta-applications control or analyze the behavior of multi-tier distributed applications such as multi-tier web sites or web services. Examples of meta-applications include multi-tier debugging, fault diagnosis, resource tracking, prioritization, and security enforcement. Efficient online implementation of these meta-applications requires meta-data to be passed between the different program components. Examples of metadata corresponding to the above meta-applications are request identifiers, priorities or security principal identifiers. Causeway provides the infrastructure for injecting, destroying, reading, and writing such metadata. The key functionality in Causeway is forwarding the metadata associated with a request at so-called transfer points, where the execution of that request gets passed from one component to another. This is done automatically for system-visible channels, such as pipes or sockets. An API is provided to implement the forwarding of metadata at system-opaque channels such as shared memory. We describe the design and implementation of Causeway, and we evaluate its usability and performance. Causeway's low overhead allows it to be present permanently in production systems. We demonstrate its usability by showing how to implement, in 150 lines of code and without modification to the application, global priority enforcement in a multi-tier dynamic web server. © IFIP International Federation for Information Processing 2005."
"Kraj P., McIndoe R.A." $ "caBIONet - A .NET wrapper to access and process genomic data stored at the National Cancer Institute's Center for Bioinformatics databases" $ "Motivation: The National Cancer Institute's Center for Bioinformatics (NCICB) has developed a Java based data management and information system called caCORE. One component of this software suite is the object oriented API (caBIO) used to access the rich biological datasets collected at the NCI. This API can access the data using native Java classes, SOAP requests or HTTP calls. Non-Java based clients wanting to use this API have to use the SOAP or HTTP interfaces with the data being returned from the NCI servers as an XML data stream. Although the XML can be read and manipulated using DOM or SAX parsers, one loses the convenience and usability of an object oriented programming paradigm. caBIONet is a set of .NET wrapper classes (managers, genes, chromosomes, sequences, etc.) capable of serializing the XML data stream into local .NET objects. The software is able to search NCICB databases and provide local objects representing the data that can be manipulated and used by other .NET programs. The software was written in C# and compiled as a .NET DLL. © The Author 2005. Published by Oxford University Press. All rights reserved."
"Greenberg J.P., Mock S., Bhatia K., Katz M., Bruno G., Sacerdoti F., Papadopoulos P., Baldridge K.K." $ "Incorporation of middleware and grid technologies to enhance usability in computational chemistry applications" $ "High performance computing, storage, visualization, and database infrastructures are increasing in complexity as scientists move towards grid-based computing. This evolution of computing infrastructure has the effect of pushing breakthrough computational capabilities beyond the reach of domain scientists. In this work, we discuss a workflow management system that allows portal construction that is fully integrated with emerging grid standards but can be dynamically reconfigured. By defining an XML schema to describe both resources, application codes and interfaces, we will enable a ""pluggable"" event-driven model where grid-enabled services can be composed to form elaborate pipelines of simulation, and visual analysis. © 2004 Elsevier B.V. All rights reserved."
"Pastel R., Skalsky N." $ "Demonstrating information in simple gestures" $ "We introduce the simple gesturing user interface (SGUI), an application programming interface (API) for designing user interfaces utilizing simple gesturing on the personal digital assistant (PDA). SGUI is particularly appropriate for PDA interfaces because the simple gestures are recognized using minimum processing power and reserve all of the small display for user-task specific information. A graphing-software implemented on a PDA using SGUI illustrates the usability of gesturing interfaces and the information conveyed in a single gesture stroke."
"Zheng Z., Sepehri N." $ "A CORBA-based distributed real-time crane simulator with 3D visualization" $ "The development of a simulator for a crane equipped with a claming device is reported in this paper. The real-time simulation is built upon a complete mathematical model of the claming machine with 3D graphics and interactive features. Common Object Request Broker Architecture (CORBA) technology is employed to distribute the calculation of the complex dynamic equations on a more powerful server, while relieving the -client computer to concentrate on graphics rendering, collision detection and control signal collection. The communication methods and concurrency model of both the client and the server are carefully selected to ensure reliability without compromising the speed. The server supports multiple users. Thus, more than one user can share the resource of a single server when they are connected to a network that supports Transmission Control Protocol (TCP) or Internet Protocol (IP). OpenGL is used as the graphics Application Programming Interface (API), Users can select different visual angle to watch the scene while operating the virtual machine."
"Lee H.-C., Kim H.-J., Park K.-S." $ "A flexible transition scheme within a dual stack host in IPv4/IPv6 coexistence phase" $ "In an early transition period, the Internet consists of IPv4-only, IPv6-only or IPv4/IPv6 dual networks. Users want to connect to the Internet without any restriction and also still use their existing applications even after migration from IPv4 to IPv6 networks. Thus, we propose a new flexible transition scheme called GHADH (Coexistence of Heterogeneous Applications within a Dual stack Host). At this scheme, DSTM (Dual Stack Transition Mechanism) is tightly coupled with BIA (Bump In the API). With these coupling, Users can use their existing IPv4 applications to communicate with IPv6 host within IPv6 networks. Furthermore, seamless interworking with IPv4 networks can be also assured. Additionally, it can provide the users with adaptive environments to easily use their terminals in various networks environments. DNSv6 resolving can be also available to the users with the help of CHADH. We have implemented the prototype of CHADH on the Microsoft Windows 2000 and XP platforms. We have verified its usability through various experiments with existing applications and evaluated the performance in each network environments. © Springer-Verlag Berlin Heidelberg 2003."
"Sicilia M.-A., García E., Díaz P., Aedo I." $ "Extending relational data access programming libraries for fuzziness: The fJDBC framework" $ "Fuzzy relational databases have been extensively studied in recent years, resulting in several models and representation techniques, some of which have been implemented as software layers on top of diverse existing database systems. Fuzzy extensions to query languages and end-user query interfaces have also been developed, but the design of programming interfaces has not been properly addressed yet. In this paper, we describe a software framework called fJDBC that extends the Java Database Connectivity API by enabling fuzzy queries on existing relational databases, using externally-stored metadata. Since the main design objective of this extension is usability for existing database programmers, only a restricted subset of extensions (supported also by an extended object modelling notation) has been included. The overall design of the framework and some empirical results are also described. © Springer-Verlag Berlin Heidelberg 2002."
"Ball T., Rajamani S.K." $ "The SLAM project: Debugging system software via static analysis" $ "The goal of the SLAM project is to check whether or not a program obeys ""API usage rules"" that specify what it means to be a good client of an API. The SLAM toolkit statically analyzes a C program to determine whether or not it violates given usage rules. The toolkit has two unique aspects: It does not require the programmer to annotate the source program (invariants are inferred), it minimizes noise (false error messages) through a process known as ""counterexample-driven refinement"". SLAM exploits and extends results from program analysis, model checking and automated deduction. We have successfully applied the SLAM toolkit to Windows XP device drivers, to both validate behavior and find defects in their usage of kernel APIs."
"Aizman A." $ "Easy concurrency" $ "Advances in technology raise expectations. As far as software engineering is concerned, the common expectation is that coding and deploying applications is going to be simple. It seems, though, that software engineering is not getting easier, and the complexity moves to an application domain. One of the sources of complexity is an application concurrency. It is not an uncommon development practice that concurrency and transaction management in multi-user, multi-threaded, event-driven applications are postponed until after most of the required functionality is implemented. This situation has various explanations. On the one hand, business logic may require access and modification of large sets of interconnected application objects. On the other, testing and stress-testing of this logic becomes possible only at advanced stages of product development. At these stages, increasing lock granularities may appear to be less ""ex-pensive"" than debugging race conditions and deadlocks. Coarse-grained locking has, of course, an adverse effect on application scalability. Declaring rules of concurrency outside of the application may solve part of the problem. This paper presents an approach allowing developers to define concurrency in application-specific terms, design it in the early stages of development, and implement it using a documented API of the concurrency engine (CE). Simple notation makes it possible to record concurrency specifications in terms of application operations, relationships between application resources, and synchronization conflicts between operations. These concepts are demonstrated on examples. The final sections include the CE UML diagram, notes on API usage, and performance benchmarks. © Springer-Verlag 2001."
"John B.E., Bass L." $ "Usability and software architecture" $ "The role of software architecture with respect to usability has evolved over the past 20 years. The architectures of the 1980s and early 1990s assumed that usability was primarily a property of the presentation of information. Therefore, simply separating the presentation from the dialogue and application make it easy to modify that presentation after user testing. A more popular belief in the 1990s was that usability concerns greatly affected system functionality as well as the presentation. This emphasis took attention away from architectural support (beyond separation). Achieving the correct functionality for a given system became paramount. It is our observation that even if presentation and functionality of a system are well designed, the usability of a system can be greatly compromised if the underlying architecture does not support human concerns beyond modifiability. This paper will present a new role for software architecture in usability, preliminary research and practice stemming from this role and a research agenda for the future."
"Meijer H., Poll E." $ "Towards a full formal specification of the javacard API" $ "This paper reports on ongoing work to develop a formal specification of the JavaCard API using the specification language JML. It discusses the specification of the JCSystem class, which deals with the JavaCard firewall, (atomic) transactions and transient objects. The JCSystem class seems to be the hardest class in the API to specify, and it is closely connected with some of the peculiarities of JavaCard as opposed to Java. © Springer-Verlag Berlin Heidelberg 2001."
"Braun P., Lötzbeyer H., Schätz B., Slotosch O." $ "Consistent integration of formal methods" $ "The usability of formal concepts for system design depends essentially on their integration in the design process. We discuss several possible levels of integration: technical integration of tools considering APIs and tool interfaces, conceptual integration of metamodels of description formalisms combined with hard and soft constraints, semantical integration of semantics of description techniques using a common semantic model, and finally methodical integration by an embedding in the development process. We show the feasibility of such an integrated approach and its advantages presenting AutoFocus/Quest, a formal method CASE-Tool with its levels of integration. Parts of a banking system model are used as example. © Springer-Verlag Berlin Heidelberg 2000."
"Hoffman D., Strooper P." $ "Prose + test cases = specifications" $ "The rise of component-based software development has created a need for API documentation. Experience has shown that it is hard to create and maintain precise and readable documentation. Prose documentation can provide a good overview but lacks precision. Formal methods offer precision but the resulting documentation is expensive to write and modify. Worse, few developers have the skill or inclination to read formal documentation. We present a pragmatic solution to the problem of API documentation. We augment the current prose documentation with test cases, including expected outputs, and use the prose plus the test cases as the documentation. Typically there are one or two simple test cases for each likely question about API behavior. With this approach, the documentation is precise, albeit partial. Consistency between code and documentation is guaranteed by running the test cases. The readability of the test cases is of paramount importance because communication with API users is their primary purpose. We present a test script language that supports compact, readable test cases and generation of test drivers, and illustrate the approach with a detailed case study."
"Klein K., Sequeira V." $ "The view-cube: An efficient method of view planning for 3D modelling from range data" $ "When aiming at the automated reconstruction of real world scenes from range images, one has to address the problem of planning the image acquisition. Although solutions for small objects in well defined environments are already available, the insufficient scalability of these approaches to large scenes and to a high number of degrees of freedom limits their applicability. In this paper we present a new planning algorithm with emphasis on practical usability in initially unknown, large indoor environments. Using a surface representation of seen and unseen parts of the environment, we propose an objective function based on the analysis of occlusions. In addition to previous approaches, we take into account both a quality criterion and the cost of the next acquisition. By optimising this objective function, the parameters of the next view are computed efficiently for a large search space with eight degrees of freedom (3D position, viewing direction, field of view, and resolution). Our technique exploits hardware-accelerated rendering (OpenGL) in order to perform the expensive visibility computation, which reduces the computation time of one planning step to a couple of minutes. Results are shown for two large indoor scenes-an artificial scene and a real world room-with numerous self occlusions. © 2000 IEEE."
"Martin David H., Martin Johnny" $ "Java and digital images" $ "Interfacing Java applications to a video-capture device poses a special challenge because there is currently no easy way to access the camera from Java. The Java virtual machine presents a barrier between applications and C/C++ application programming interfaces (API) used to access the video camera. To access these APIs from Java, one must not only write JNI methods, but must also address image conversion problems, performance issues, and thread synchronization. The three approaches, no integration, loose integration, and full integration, to incorporate video or image capture into a Java application and their abilities/complexity tradeoffs are discussed."
"McLellan S.G., Roesler A.W., Tempest J.T., Spinuzzi C.I." $ "Building more usable APIs" $ "Imagine hypothetically, just for a moment, that programmers are humans,"" writes Steven Pemberton in a July 1997 magazine devoted to human-computer interaction design and development. ""Now suppose for a moment, also for the sake of the argument, that their chief method of communicating and interacting with computers was with programming languages. What would we, as HCI people, then do? Run screaming in the other direction...."" 1 It is a good question and, unfortunately, an all too common response. It's hard enough for us to ensure that product interfaces, like those for Excel or Word, are easy to use and learn. But programmers are users, too. They need application and system libraries that are just as easy to learn and use as the products they build from these libraries. Listen to this customer: ""I think it would be worthwhile if all developers would spend maybe a couple of hours a year seeing how the[ir] product is used by...customers. Just watching them. And while they're watching ...the customer would say, 'I don't like the way this works....'You need to see how they use it."" 2 Now ask yourself: why is it easier to visualize the customer who's purchased a financial accounting package from a neighborhood computer outlet, rather than a programmer whose company has just purchased a new Java class library? Wouldn't the developer of this library find it worthwhile to watch programmers work with it?"
"Ketchpel S.P., Garcia-Molina H., Paepcke A." $ "Shopping models: a flexible architecture for information commerce" $ "In a digital library, there are many different interaction models between customers and information providers or merchants. Subscriptions, sessions, pay-per-view, shareware, and pro-paid vouchers are different models that each have different properties. A single merchant may use several of them. Yet if a merchant wants to support multiple models, there is a substantial amount of work to implement each one. In this paper, we formalize the shopping models which represent these different modes of consumer to merchant interaction. In addition to developing the overall architecture, we define the application program interfaces (API) to interact with the models. We show how a small number of primitives can be used to construct a wide range of shopping models that a digital library can support, and provide examples of the shopping models in operation, demonstrating their flexibility. Two models have been implemented as part of the Stanford Digital Library Project, to begin validating re-usability of key architectural components."
"Watson Richard W., Coyne Robert A." $ "Parallel I/O architecture of the High-Performance Storage System (HPSS)" $ "Datasets up to terabyte size and petabyte total capacities have created a serious imbalance between I/O and storage-system performance and system functionality. One promising approach is the use of parallel data-transfer techniques for client access to storage, peripheral-to-peripheral transfers, and remote file transfers. This paper describes the parallel I/O architecture and mechanisms, Parallel Transport Protocol (PTP), parallel FTP, and parallel client Application Programming Interface (API) used by the High-Performance Storage System (HPSS). Parallel storage integration issues with a local parallel file system are also discussed."
"Hilgert L.D." $ "Software Reviews: Test plus" $ "TEST PLUS is a software package based on the Adult Personality Inventory (API). It allows the API user to make decisions based on a systematic comparison of 25 personality factors to a database of up to 100 other examinees or to a “referenced model” constructed by the evaluator. This makes TEST PLUS extremely useful in a variety of settings. © 1987, Sage Publications. All rights reserved."
