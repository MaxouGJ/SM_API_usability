Authors $ Title $ Abstract
"Varley R." $ "ExoData: A Python package to handle large exoplanet catalogue data" $ "Exoplanet science often involves using the system parameters of real exoplanets for tasks such as simulations, fitting routines, and target selection for proposals. Several exoplanet catalogues are already well established but often lack a version history and code friendly interfaces. Software that bridges the barrier between the catalogues and code enables users to improve the specific repeatability of results by facilitating the retrieval of exact system parameters used in articles results along with unifying the equations and software used. As exoplanet science moves towards large data, gone are the days where researchers can recall the current population from memory. An interface able to query the population now becomes invaluable for target selection and population analysis. ExoData is a Python interface and exploratory analysis tool for the Open Exoplanet Catalogue. It allows the loading of exoplanet systems into Python as objects (Planet, Star, Binary, etc.) from which common orbital and system equations can be calculated and measured parameters retrieved. This allows researchers to use tested code of the common equations they require (with units) and provides a large science input catalogue of planets for easy plotting and use in research. Advanced querying of targets is possible using the database and Python programming language. ExoData is also able to parse spectral types and fill in missing parameters according to programmable specifications and equations. Examples of use cases are integration of equations into data reduction pipelines, selecting planets for observing proposals and as an input catalogue to large scale simulation and analysis of planets. ExoData is a Python package available freely on GitHub.1 It's open source and community contributions are encouraged. The package can be easily installed using pip install exodata, detailed setup information is provided within. Program summary Program title: ExoData Catalogue identifier: AFAL_v1_0 Program summary URL:http://cpc.cs.qub.ac.uk/summaries/AFAL_v1_0.html Program obtainable from: CPC Program Library, Queen's University, Belfast, N. Ireland Licensing provisions: GNU General Public License, version 3 No. of lines in distributed program, including test data, etc.: 21884 No. of bytes in distributed program, including test data, etc.: 608434 Distribution format: tar.gz Programming language: Python 2.7, 3.4, 3.5. Computer: Any. Operating system: Any. RAM: Less than 200MB Classification: 1.7. External routines: numpy, quantities, matplotlib, requests, astropy, seaborn, pandas, six Nature of problem: Being able to use exoplanet catalogue values in code including where there may be incomplete and incorrectly formatted values. Also being able to use the whole catalogue data at once, both for user querying, visualisation and in large simulation programs. Solution method: An interface to access the catalogue including filling in missing values and parsing of the catalogue data. Creating an API useable by both humans and other code, implementation of commonly used exoplanet equations, a plotting library. Running time: A few seconds depending on task © 2016 The Author(s)"
"Suro F., Ono Y." $ "Japanese EFL learners' uses of text-to-speech technology and their learning behaviors: A pilot study" $ "The purpose of this study is to show how EFL learners work on Text-to-speech (TTS) technology to improve their speaking accuracy. We constructed the system for improving speaking proficiency based on Web-Speech API. Usually, text-to-speech is available on the net or by using TTS applications in education. However, these sounds produced are not generally customized to the diversity of learners' learning strategies. The system constructed in the study makes it possible for learners to choose the words, phrases sentences or the passage they like to listen to for their speaking practice. Major findings that came out from this study are: (i) As to the easier materials, accuracy improvement was observed regardless of their proficiency, (ii) On the contrary, as to the difficult materials, such an improvement was not observed in the experiment, and (iii) there is diversity of how they worked on the system, and there are some patterns in their learning behaviors, Bottom-uppers and Top-downers. These findings suggest the usefulness of the current system for various types of learners in terms of learning strategies and a future possibility from a learning analytic point of view to modify the system. © 2016 IEEE."
"Sawant A.A., Bacchelli A." $ "fine-GRAPE: fine-grained APi usage extractor – an approach and dataset to investigate API usage" $ "An Application Programming Interface (API) provides a set of functionalities to a developer with the aim of enabling reuse. APIs have been investigated from different angles such as popularity usage and evolution to get a better understanding of their various characteristics. For such studies, software repositories are mined for API usage examples. However, many of the mining algorithms used for such purposes do not take type information into account. Thus making the results unreliable. In this paper, we aim to rectify this by introducing fine-GRAPE, an approach that produces fine-grained API usage information by taking advantage of type information while mining API method invocations and annotation. By means of fine-GRAPE, we investigate API usages from Java projects hosted on GitHub. We select five of the most popular APIs across GitHub Java projects and collect historical API usage information by mining both the release history of these APIs and the code history of every project that uses them. We perform two case studies on the resulting dataset. The first measures the lag time of each client. The second investigates the percentage of used API features. In the first case we find that for APIs that release more frequently clients are far less likely to upgrade to a more recent version of the API as opposed to clients of APIs that release infrequently. The second case study shows us that for most APIs there is a small number of features that is actually used and most of these features relate to those that have been introduced early in the APIs lifecycle. © 2016 The Author(s)"
"Landhäußer M., Weigelt S., Tichy W.F." $ "NLCI: a natural language command interpreter" $ "Natural language interfaces are becoming more and more common, because they are powerful and easy to use. Examples of such interfaces are voice controlled navigation devices, Apple’s personal assistant Siri, Google Voice Search, and translation services. However, such interfaces are extremely difficult to build, to maintain, and to port to new domains. We present an approach for building and porting such interfaces quickly. NLCI is a natural language command interpreter that accepts action commands in English and translates them into executable code. The core component is an ontology that models an API. Once the API is “ontologized”, NLCI translates input sentences into sequences of API calls that implement the intended actions. Two radically different APIs were ontologized: openHAB for home automation and Alice for building 3D animations. Construction of the ontology can be automated if the API uses descriptive names for its components. In that case, the language interface can be generated completely automatically. Recall and precision of NLCI on a benchmark of 50 input scripts are 67 and 78 %, resp. Though not yet acceptable for practical use, the results indicate that the approach is feasible. NLCI accepts typed input only. Future work will use a speech front-end to test spoken input. © 2016 Springer Science+Business Media New York,End-user programming, Knowledge-based software engineering, Natural language processing for software engineering, Program synthesis, Programming in natural language"
"Khan S., Nauman M., Othman A.T., Musa S., Syed T.A." $ "TSSDroid: realization of an efficient and usable TSS API for the Android software stack" $ "The advancement in smartphones capabilities has attracted malware writers to build more sophisticated attacks on these devices. Traditional software-based security mechanisms have failed to provide strong security against these attacks. Similar threats on the PC have been countered using the concepts of Trusted Computing—a highly flexible trust mechanism with strong security properties. However, smartphone platforms have yet to see any Trusted Computing applications—primarily because of the difficulty in adopting this relatively new paradigm of security. In this paper, we present the design of a high-level application programming interface (API) that allows Android-based smartphone application developers to adopt Trusted Computing and use it in their applications without having to learn the intricate details of how Trusted Computing works. The API abstracts away the complexity in using Trusted Computing constructs by offering easy-to-use interfaces for complex tasks. The API has enhanced the usability of Trusted Computing development by significantly reducing the number of lines and complexity of code required to perform these diverse tasks. This paper provides a reference implementation for the proposed API in order to show that the API is efficient in terms of performance overhead. Copyright Â© 2016 John Wiley & Sons, Ltd. Copyright Â© 2016 John Wiley & Sons, Ltd."
"Saied M.A., Sahraoui H." $ "A cooperative approach for combining client-based and library-based API usage pattern mining" $ "Software developers need to cope with the complexity of Application Programming Interfaces (APIs) of external libraries or frameworks. Typical APIs provide thousands of methods to their client programs, and these methods are not used independently of each other. Much existing work has provided different techniques to mine API usage patterns based on client programs in order to help developers understanding and using existing libraries. Other techniques propose to overcome the strong constraint of clients' dependency and infer API usage patterns only using the library source code. In this paper, we propose a cooperative usage pattern mining technique (COUPminer) that combines client-based and library-based usage pattern mining. We evaluated our technique through four APIs and the obtained results show that the cooperative approach allows taking advantage at the same time from the precision of client-based technique and from the generalizability of library-based techniques. © 2016 IEEE."
"Myers B.A., Stylos J." $ "Improving API usability" $ "APPLICATION PROGRAMMING INTERFACES (APIs), including libraries, frameworks, toolkits, and software development kits, are used by virtually all code. If one includes both internal APIs (interfaces internal to software projects) and public APIs (such as the Java Platform SDK, the Windows .NET Framework, jQuery for JavaScript, and Web services like Google Maps), nearly every line of code most programmers write will use API calls. APIs provide a mechanism for code reuse so programmers can build on top of what others (or they themselves) have already done, rather than start from scratch with every program. Moreover, using APIs is often required because low-level access to system resources (such as graphics, networking, and the file system) is available only through protected APIs. Organizations increasingly provide their internal data on the Web through public APIs, for example, http://www.programmableweb.com lists almost 15,000 APIs for Web services and https://www.digitalgov. gov/2013/04/30/apis-in-government/promotes use of government data through Web APIs. © 2016 ACM."
"Weidner O., Atkinson M., Barker A., Vicente R.F." $ "Rethinking high performance computing platforms: Challenges, opportunities and recommendations" $ "A growing number of ""second generation"" high-performance computing applications with heterogeneous, dynamic and data-intensive properties have an extended set of requirements, which cover application deployment, resource allocation, -control, and I/O scheduling. These requirements are not met by the current production HPC platform models and policies. This results in a loss of opportunity, productivity and innovation for new computational methods and tools. It also decreases effective system utilization for platform providers due to unsupervised workarounds and ""rogue"" resource management strategies implemented in application space. In this paper we critically discuss the dominant HPC platform model and describe the challenges it creates for second generation applications because of its asymmetric resource view, interfaces and software deployment policies. We present an extended, more symmetric and application-centric platform model that adds decentralized deployment, introspection, bidirectional control and information flow and more comprehensive resource scheduling. We describe cHPC: an early prototype of a non-disruptive implementation based on Linux Containers (LXC). It can operate alongside existing batch queuing systems and exposes a symmetric platform API without interfering with existing applications and usage modes. We see our approach as a viable, incremental next step in HPC platform evolution that benefits applications and platform providers alike. To demonstrate this further, we layout out a roadmap for future research and experimental evaluation. © 2016 ACM."
"Raghothaman M., Wei Y., Hamadi Y." $ "SWIM: Synthesizing what i mean code search and idiomatic snippet synthesis" $ "Modern programming frameworks come with large libraries, with diverse applications such as for matching regular expres-sions, parsing XML files and sending email. Programmers often use search engines such as Google and Bing to learn about existing APIs. In this paper, we describe swim, a tool which suggests code snippets given API-related natural language queries such as\generate md5 hash code"". The query does not need to contain framework-specific trivia such as the type names or methods of interest. We translate user queries into the APIs of interest using clickthrough data from the Bing search engine. Then, based on patterns learned from open-source code repositories, we synthesize idiomatic code describing the use of these APIs. We introduce structured call sequences to capture API-usage patterns. Structured call sequences are a generalized form of method call sequences, with if-branches and while-loops to represent conditional and repeated API usage patterns, and are simple to extract and amenable to synthesis. We evaluated swim with 30 common C# API-related queries received by Bing. For 70% of the queries, the first suggested snippet was a relevant solution, and a relevant solution was present in the top 10 results for all benchmarked queries. The online portion of the workow is also very responsive, at an average of 1:5 seconds per snippet. © 2016 ACM."
"Mindermann K." $ "Are easily usable security libraries possible and how should experts work together to create them?" $ "Due to non-experts also developing security relevant applications it is necessary to support them too. Some improvements in the current research may not reach or impact these developers. Nonetheless these developers use security libraries. There are findings that even their usage is not easily possible and applications are left vulnerable to supposedly treated threats. So it is important to improve the usability of the security libraries. This is itself is not straightforward because of a required maturing process for example. By get- ting together experts of different involved areas, especially cryptographic and API-usability experts, both of the problems can be tackled. © 2016 ACM."
"Qiu D., Li B., Leung H." $ "Understanding the API usage in Java" $ "Context Application Programming Interfaces (APIs) facilitate the use of programming languages. They define sets of rules and specifications for software programs to interact with. The design of language API is usually artistic, driven by aesthetic concerns and the intuitions of language architects. Despite recent studies on limited scope of API usage, there is a lack of comprehensive, quantitative analyses that explore and seek to understand how real-world source code uses language APIs. Objective This study aims to understand how APIs are employed in practical development and explore their potential applications based on the results of API usage analysis. Method We conduct a large-scale, comprehensive, empirical analysis of the actual usage of APIs on Java, a modern, mature, and widely-used programming language. Our corpus contains over 5000 open-source Java projects, totaling 150 million source lines of code (SLoC). We study the usage of both core (official) API library and third-party (unofficial) API libraries. We resolve project dependencies automatically, generate accurate resolved abstract syntax trees (ASTs), capture used API entities from over 1.5 million ASTs, and measure the usage based on our defined metrics: frequency, popularity and coverage. Results Our study provides detailed quantitative information and yield insight, particularly, (1) confirms the conventional wisdom that the usage of APIs obeys Zipf distribution, (2) demonstrates that core API is not fully used (many classes, methods and fields have never been used), (3) discovers that deprecated API entities (in which some were deprecated long ago) are still widely used, (4) evaluates that the use of current compact profiles is under-utilized, (5) identifies API library coldspots and hotspots. Conclusions Our findings are suggestive of potential applications across language API design, optimization and restriction, API education, library recommendation and compact profile construction. © 2016 Elsevier B.V. All rights reserved."
"Fysarakis K., Mylonakis D., Manifavas C., Papaefstathiou I." $ "Node.DPWS: Efficient Web Services for the Internet of Things" $ "Interconnected computing systems in various forms will soon permeate our lives, realizing the Internet of Things (IoT) and letting us enjoy novel, enhanced services that promise to improve our everyday life. Nevertheless, this new reality introduces significant challenges in terms of performance, scaling, usability, and interoperability. Leveraging the benefits of service-oriented architectures (SOAs) can help alleviate many of the issues that developers, implementers, and users alike must face in the context of the IoT. Node.DPWS is a novel implementation of the Devices Profile for Web Services (DPWS) based on the Node.js platform. It comprises the first set of DPWS libraries available to Node.js developers and can be used to deploy lightweight, efficient, and scalable Web services over heterogeneous nodes, including devices with limited resources. A performance evaluation on typical embedded devices validated the benefits of Node.DPWS compared to alternative DPWS libraries. © 2016 IEEE."
"Haydel N., Gesing S., Taylor I., Madey G., Dakkak A., De Gonzalo S.G., Hwu W.-M.W." $ "Enhancing the Usability and Utilization of Accelerated Architectures via Docker" $ "Accelerated architectures such as GPUs (Graphics Processing Units) and MICs (Many Integrated Cores) have been proven to increase the performance of many algorithms compared to their CPU counterparts and are widely available in local, campus-wide and national infrastructures, however, their utilization is not following the same pace as their deployment. Reasons for the underutilization lay partly on the software side with proprietary and complex interfaces for development and usage. A common API providing an extra layer to abstract the differences and specific characteristics of those architectures would deliver a far more portable interface for application developers. This cloud challenge proposal presents such an API that addresses these issues using a container-based approach. The resulting environment provides Docker-based containers for deploying accelerator libraries, such as CUDA Toolkit, OpenCL and OpenACC, onto a wide variety of different platforms and operating systems. By leveraging the container approach, we can overlay accelerator libraries onto the host without needing to be concerned about the intricacies of underlying operating system of the host. Docker therefore provides the advantage of being easily applicable on diverse architectures, virtualizing the necessary environment and including libraries as well as applications in a standardized way. The novelty of our approach is the extra layer for utilization and device discovery in this layer improving the usability and uniform development of accelerated methods with direct access to resources. © 2015 IEEE."
"Ali-Gombe A., Ahmed I., Richard G.G., III, Roussev V." $ "AspectDroid: Android app analysis system" $ "The growing threat to user privacy related to Android applications (apps) has tremendously increased the need for more reliable and accessible app analysis systems. This paper presents AspectDroid, an application-level system designed to investigate Android applications for possible unwanted activities. AspectDroid is comprised of app instrumentation, automated testing and containment systems. By using static bytecode instrumentation, AspectDroid weaves monitoring code into an existing application and provides data flow and sensitive API usage as well as dynamic instrumentation capabilities. The newly repackaged app is then executed either manually or via an automated testing module. Finally, the flexible containment provided by AspectDroid adds a layer of protection so that malicious activities can be prevented from affecting other devices. The accuracy score of Aspect Droid when tested on 105 DroidBench corpus shows it can detect tagged data with 95.29%. We further tested our system on 100 real malware families from the Drebin dataset [1]. The result of our analysis showed AspectDroid incurs approximately 1MB average total memory size overhead and 5.9% average increase in CPU-usage."
"Nakajima A., Ono Y." $ "The Prospect of Open Online e-Learning System Based on the Free Culture Movement - Development of YouTutors as an Auto-Assignment Generator by Utilizing Creative Commons Contents Online" $ "This paper is concerned with the educational potential of open-source contents online, such as the Creative Commons and open Application Programming Interface (API), with the Free Culture movement as backgrounds. As a case study, we propose an open online e-learning system 'You Tutors', which automatically generates language-training materials by utilizing Creative Commons videos and open API of YouTube. As an introduction, we discuss the copy left licensing system and Creative Commons as a representative achievement of the Free Culture movement. To understand the affinity of the interaction between education and the Free Culture movement, we investigate the history of the movement. Furthermore, we examine the concepts structures of some licensing systems born in the context of the movement. We review related case studies especially selected from among practical open educational challenges. Then, we describe the development of an online English e-learning system 'You Tutors' as an original case study. We illustrate a way to re-use the data on the web and a way to adapt the Creative Commons contents into the e-learning system by mash up techniques. We conducted a usability experiment in English classes at the University of Tsukuba and found that students evaluated the auto-generated assignment system using online resources as adequate, after their self-learning application. © 2015 IEEE."
"Nguyen T.T., Pham H.V., Vu P.M., Nguyen T.T." $ "Recommending API usages for mobile apps with hidden Markov model" $ "Mobile apps often rely heavily on standard API frameworks and libraries. However, learning to use those APIs is often challenging due to the fast-changing nature of API frameworks and the insufficiency of documentation and code examples. This paper introduces DroidAssist, a recommendation tool for API usages of Android mobile apps. The core of DroidAssist is HAPI, a statistical, generative model of API usages based on Hidden Markov Model. With HAPIs trained from existing mobile apps, DroidAssist could perform code completion for method calls. It can also check existing call sequences to detect and repair suspicious (i.e. unpopular) API usages. © 2015 IEEE."
"Le Roux P.B., Kroon S., Bester W." $ "DSaaS: A cloud service for persistent data structures" $ "In an attempt to tackle shortcomings of current approaches to collaborating on the development of structured data sets, we present a prototype platform that allows users to share and collaborate on the development of data structures via a web application, or by using language bindings or an API. Using techniques from the theory of persistent linked data structures, the resulting platform delivers automatically version-controlled map and graph abstract data types as a web service. The core of the system is provided by a Hash Array Mapped Trie (HAMT) which is made confluently persistent by path-copying. The system aims to make efficient use of storage, and to have consistent access and update times regardless of the version being accessed or modified. Copyright © 2016 by SCITEPRESS-Science and Technology Publications, Lda. All rights reserved."
"Neville D., Malton A., Brain M., Kroening D." $ "Towards automated bounded model checking of API implementations" $ "We introduce and demonstrate the viability of a novel technique for verifying that implementations of application program interfaces (APIs) are bug free. Our technique applies a new abstract interpretation to extract an underlying model of API usage, and then uses this to synthesise a set of verifiable program fragments. These fragments are evaluated using CBMC and any potentially spurious property violation is presented to a domain expert user. The user's response is then used to refine the underlying model of the API to eliminate false positives. The refinement-analysis process is repeated iteratively. We demonstrate the viability of the technique by showing how it can find an integer underflow within Google's Brotli, an underflow that has been shown to lead directly to allow remote attackers to execute arbitrary code in CVE 2016-1968. © 2016, CEUR-WS. All rights reserved."
"Türpe S." $ "Idea: Usable platforms for secure programming – mining Unix for insight and guidelines" $ "Just as security mechanisms for end users need to be usable, programming platforms and APIs need to be usable for programmers. To date the security community has assembled large catalogs of dos and don’ts for programmers, but rather little guidance for the design of APIs that make secure programming easy and natural. Unix with its setuid mechanism lets us study usable security issues of programming platforms. Setuid allows certain programs to run with higher privileges than the user or process controlling them. Operating across a privilege boundary entails security obligations for the program. Obligations are known and documented, yet developers often fail to fulfill them. Using concepts and vocabulary from usable security and usability of notations theory, we can explain how the Unix platform provokes vulnerabilities in such programs. This analysis is a first step towards developing platform design guidelines to address human factors issues in secure programming. © Springer International Publishing Switzerland 2016."
"Hasegawa K., Kanayama N., Nishide T., Okamoto E." $ "Software library for ciphertext/key-policy functional encryption with simple usability" $ "In traditional public key encryption schemes, data encrypted by a public key pk can be decrypted only by a secret key sk corresponding to pk, and the relation between pk and sk is static. Therefore, the schemes are unsuitable for control of access to a single data by several users. Meanwhile, functional encryption (FE) is an encryption scheme that provides more sophisticated and flexible relations between pk and sk. Thus, FE enables only one pk to encrypt the data with any conditions for decryption, so it is considered a very useful tool for the access control of data on the cloud server. However, implementing the current FE scheme is a non-trivial task because the deep knowledge of the scheme is required. This is an obstacle factor to deploy the FE scheme in the real-world security systems. In this paper, we propose an implementation of the FE (Ciphertext-Policy FE and Key-Policy FE, which are useful classes of FE) library usable even for people who do not have the deep knowledge of these schemes. © 2016 Information Processing Society of Japan."
"Furtado L., Miranda B., Neto N., Meiguins B." $ "IVOrpheus: A proposal for interaction by voice commands in three-dimensional environments of information visualization" $ "IVOrpheus is an information visualization tool for three-dimensional data that allows user's interaction by voice commands, mouse and keyboard input. The visualization technique used was the scatterplot 3D, which was implemented using Jmathplot API, and the speech recognition in Brazilian Portuguese was performed by Coruja software. IVOrpheus was developed in Java following the architectural pattern MVC, design patterns and open technologies. In voice interaction, some usability guidelines have been set in interface building process, making it more intuitive and contributing to lower the user cognitive effort. In addition, initial usability tests with users were performed to evaluate the application interface with and without interaction by voice. The tasks with and without voice interaction have shown similar results of time and completeness. The speech recognizer achieved a word error rate of approximately 17%. © 2015 IEEE."
"Wu W., Khomh F., Adams B., Guéhéneuc Y.-G., Antoniol G." $ "An exploratory study of api changes and usages based on apache and eclipse ecosystems" $ "Frameworks are widely used in modern software development to reduce development costs. They are accessed through their Application Programming Interfaces (APIs), which specify the contracts with client programs. When frameworks evolve, API backward-compatibility cannot always be guaranteed and client programs must upgrade to use the new releases. Because framework upgrades are not cost-free, observing API changes and usages together at fine-grained levels is necessary to help developers understand, assess, and forecast the cost of each framework upgrade. Whereas previous work studied API changes in frameworks and API usages in client programs separately, we analyse and classify API changes and usages together in 22 framework releases from the Apache and Eclipse ecosystems and their client programs. We find that (1) missing classes and methods happen more often in frameworks and affect client programs more often than the other API change types do, (2) missing interfaces occur rarely in frameworks but affect client programs often, (3) framework APIs are used on average in 35 % of client classes and interfaces, (4) most of such usages could be encapsulated locally and reduced in number, and (5) about 11 % of APIs usages could cause ripple effects in client programs when these APIs change. Based on these findings, we provide suggestions for developers and researchers to reduce the impact of API evolution through language mechanisms and design strategies. © 2015 Springer Science+Business Media New York,API changes, API usages, Data mining, Empirical study, Framework ecosystems, Framework evolution"
"Godwin A., Scott T.D., Potvin G., Sonnert G., Sadler P.M." $ "The academic performance index: Creating a more robust and less biased measure of student academic performance" $ "This paper introduces an alternative to singular performance measures through the creation of a scaled index incorporating a variety of performance factors indicating overall student success as well as the creation of similar sub-indices for performances in the particular areas of math, English, and science. These indices have been used in two studies based on nationally representative college student data: the Sustainability and Gender in Engineering (SaGE) and the Outreach Programs and Science Career Intentions (OPSCI) projects. The Academic Performance Index (API) is a scale constructed out of students' weighted high school GPA, available standardized test scores (ACT/SAT), AP test scores (if any), highest levels of various high school coursework taken, and college credit hours earned prior to enrolling in college. Importantly, the API uses any and all available data in these domains, which can be up to 42 different indicators for an individual student in the case of the SaGE project. This index shows less bias regarding race and gender, when compared with commonly-used standardized tests scores. Additionally, this item is psychometrically better at indicating variation across students' performance. © 2015 IEEE."
"Robillard M.P., Chhetri Y.B." $ "Recommending reference API documentation" $ "Reference documentation is an important source of information on API usage. However, information useful to programmers can be buried in irrelevant text, or attached to a non-intuitive API element, making it difficult to discover. We propose to detect and recommend fragments of API documentation potentially important to a programmer who has already decided to use a certain API element. We categorize text fragments in API documentation based on whether they contain information that is indispensable, valuable, or neither. From the fragments that contain knowledge worthy of recommendation, we extract word patterns, and use these patterns to automatically find new fragments that contain similar knowledge in unseen documentation. We implemented our technique in a tool, Krec, that supports both information filtering and discovery. In an evaluation study with randomly-sampled method definitions from ten open source systems, we found that with a training set derived from about 1000 documentation units, we could issue recommendations with 90 % precision and 69 % recall. In a study involving ten independent assessors, indispensable knowledge items recommended for API types were judged useful 57 % of the time and potentially useful an additional 30 % of the time. © 2014, Springer Science+Business Media New York."
"Chen X., Sime G., Lutteroth C., Weber G." $ "OAuthHub-A Service for Consolidating Authentication Services" $ "OAuth has become a widespread authorization protocol to allow inter-enterprise sharing of user preferences and data: A Consumer that wants access to a user's protected resources held by a Service Provider can use OAuth to ask for the user's authorization for access to these resources. However, it can be tedious for a Consumer to use OAuth as a way to organize user identities, since doing so requires supporting all Service Providers that the Consumer would recognize as users' 'identity providers'. Each Service Provider added requires extra work, at the very least, registration at that Service Provider. Different Service Providers may differ slightly in the API they offer, their authentication/authorization process or even their supported version of OAuth. The use of different OAuth Service Providers also creates privacy, security and integration problems. Therefore OAuth is an ideal candidate for Software as a Service, while posing interesting challenges at the same time. We use conceptual modelling to derive new high-level models and provide an analysis of the solution space. We address the aforementioned problems by introducing a trusted intermediary-OAuth Hub-into this relationship and contrast it with a variant, OAuth Proxy. Instead of having to support and control different OAuth providers, Consumers can use OAuth Hub as a single trusted intermediary to take care of managing and controlling how authentication is done and what data is shared. OAuth Hub eases development and integration issues by providing a consolidated API for a range of services. We describe how a trusted intermediary such as OAuth Hub can fit into the overall OAuth architecture and discuss how it can satisfy demands on security, reliability and usability. © 2015 IEEE."
"Shugay M., Bagaev D.V., Turchaninova M.A., Bolotin D.A., Britanova O.V., Putintseva E.V., Pogorelyy M.V., Nazarov V.I., Zvyagin I.V., Kirgizova V.I., Kirgizov K.I., Skorobogatova E.V., Chudakov D.M." $ "VDJtools: Unifying Post-analysis of T Cell Receptor Repertoires" $ "Despite the growing number of immune repertoire sequencing studies, the field still lacks software for analysis and comprehension of this high-dimensional data. Here we report VDJtools, a complementary software suite that solves a wide range of T cell receptor (TCR) repertoires post-analysis tasks, provides a detailed tabular output and publication-ready graphics, and is built on top of a flexible API. Using TCR datasets for a large cohort of unrelated healthy donors, twins, and multiple sclerosis patients we demonstrate that VDJtools greatly facilitates the analysis and leads to sound biological conclusions. VDJtools software and documentation are available at https://github.com/mikessh/vdjtools. © 2015 Shugay et al."
"Fischer L., Hanenberg S." $ "An empirical investigation of the effects of type systems and code completion on API usability using TypeScript and JavaScript in MS visual studio" $ "Recent empirical studies that compared static and dynamic type systems on API usability showed a positive impact of static type systems on developer productivity in most cases. Nevertheless, it is unclear how large this effect is in comparison to other factors. One obvious factor in programming is tooling: It is commonly accepted that modern IDEs have a large positive impact on developers, although it is not clear which parts of modern IDEs are responsible for that. One possible- and for most developers obvious candidate-is code completion. This paper describes a 2×2 randomized trial that compares JavaScript and Microsoft's statically typed alternative TypeScript with and without code completion in MS Visual Studio. While the experiment shows (in correspondence to previous experiments) a large positive effect of the statically typed language TypeScript, the code completion effect is not only marginal, but also just approaching statistical significance. This seems to be an indicator that the effect of static type systems is larger than often assumed, at least in comparison to code completion."
"[No author name available]" $ "DLS 2015 - Proceedings of the 11th Symposium on Dynamic Languages" $ "The proceedings contain 14 papers. The topics discussed include: from APIs to languages: generalizing method names, a formalization of typed Lua, gradual certified programming in coq, message safety in dart, control-flow analysis of dynamic languages via pointer analysis, compiling for multi-language task migration, high-performance cross-language interoperability in a multi-language runtime, Java-to-JavaScript translation via structured control flow reconstruction of compiler IR, language-independent storage strategies for tracing-JIT-based virtual machines, measuring polymorphism in python programs, tracking down performance variation against source code evolution, server-side type profiling for optimizing client-side JavaScript engines, and an empirical investigation of the effects of type systems and code completion on API usability using TypeScript and JavaScript in MS visual studio."
"Papadopoulos P., Loukopoulos T., Anagnostopoulos I., Tziritas N., Vassilakopoulos M." $ "RAC: A remote application calling framework for coordination of mobile apps" $ "Mobile applications (apps) have become part of our everyday life with a constantly increasing market. Of particular interest are apps aiding planning and collaboration among family members, or between co-workers. The architecture of such apps usually involves some Cloud storage medium, through which group members post and retrieve data. Naturally, all participants must have the same app installed in their devices for collaboration to be possible. In this paper we investigate an alternative option instead of app collaboration which is based on remote application calling (RAC). Under the RAC framework, a trusted source is able to invoke application actions at other people's devices, without necessarily owning himself the application it handles. We discuss RAC design and implementation related issues, focusing on Android devices. The usability of our approach is demonstrated through two widely used apps: alarm clock and map. © 2015 ACM."
"Cramer T., Dietrich R., Terboven C., Müller M.S., Nagel W.E." $ "Performance Analysis for Target Devices with the OpenMP Tools Interface" $ "The requirement for large compute capabilities led to a wide use of accelerated high performance computing systems. In order to lower the burden for programming these new architectures, user friendly programming paradigms like OpenACC and OpenMP have come to existence. They offer pragmas to shift effort from the programmer to the compiler and runtime system, particularly for data management. However, for further improvement of the usability an adequate tools support is required as well. In our work we present in detail a general extension to the upcoming OpenMP tools interface (OMPT) with respect to the new OpenMP 4.0 target constructs. This extension aims to be a portable, vendor- and platform independent interface to enable the use of performance analysis tools with OpenMP for Accelerators. Finally, we evaluate the approach in a reference implementation to prove the validity and usability with the help of an instrumented OpenMP runtime and the Score-P measurement infrastructure. © 2015 IEEE."
"Ono Y., Ishii T., Ohnishi A." $ "Construction of a voice-based asynchronous communication system utilizing speech recognition and its potential for EFL learners' speaking ability: A pilot study" $ "The present paper deals with the construction of an asynchronous voice-based computer-mediated communication (CMC) system for less confident English as a Foreign Language learners. The results from this pilot evaluation of the system are discussed in terms of its usability and effectiveness at reducing foreign language anxiety. The proposed system incorporates a browser-driven Automatic Speech Recognition (ASR) into a blog to provide real-time feedback on their pronunciation before posting. With the results from the questionnaire survey conducted in this pilot study, we demonstrate that this system reduces foreign language anxiety in speaking and increases motivation for less motivated learners. © 2015 IEEE."
"En X.D., Zhili Z." $ "A Local Bounding Box Method for Campus Navigation Based on Baidu Map" $ "Baidu Map provides most of the path navigation in the cities, but it has some drawbacks in small regions, such as the incomplete description, updating not timely. Sometimes it will bring misleading for us. In this paper, a campus navigation system is designed based on Baidu map API, using PHP, JavaScript and xml technologies. The system can provide the basic map function and search the path navigation between any two points in the campus. First, draw the campus map in detail and cover it on the Baidu Map by using the Baidu Map API class. Then, reconstruct a campus's geographic information on the local database. At last, call the Baidu Map API Service class to draw the navigation path on the map. In this paper, in order to avoid the path spillover we proposed a method called ""Local Bounding Box (LBB)"", which solves the cross-border issues. © 2015 IEEE."
"Bernal-Cárdenas C." $ "Improving energy consumption in android apps" $ "Mobile applications sometimes exhibit behaviors that can be attributed to energy bugs depending on developer implementation decisions. In other words, certain design decisions that are technically ""correct"" might affect the energy performance of applications. Such choices include selection of color palettes, libraries used, API usage and task scheduling order. We study the energy consumption of Android apps using a power model based on a multi-objective approach that minimizes the energy consumption, maximizes the contrast, and minimizes the distance between the chosen colors by com- paring the new options to the original palette. In addition, the usage of unnecessary resources can also be a cause of energy bugs depending on whether or not these are implemented correctly. We present an opportunity for continuous investigation of energy bugs by analyzing components in the background during execution on Android applications. This includes a potential new taxonomy type that is not covered by state-of-the-art approaches. © 2015 ACM."
"Santos C., Martins F., Vasconcelos V.T." $ "Deductive verification of parallel programs using why3" $ "The Message Passing Interface specification (MPI) defines a portable message-passing API used to program parallel computers. MPI programs manifest a number of challenges on what concerns correctness: sent and expected values in communications may not match, resulting in incorrect computations possibly leading to crashes, and programs may deadlock resulting in wasted resources. Existing tools are not completely satisfactory: model-checking does not scale with the number of processes, testing techniques wastes resources and are highly dependent on the quality of the test set. As an alternative, we present a prototype for a type-based approach to programming and verifying MPI-like programs against protocols. Protocols are written in a dependent type language designed so as to capture the most common primitives in MPI, incorporating, in addition, a form of primitive recursion and collective choice. Protocols are then translated into Why3, a deductive software verification tool. Source code, in turn, is written in Why ML, the language of the Why3 platform, and checked against the protocol. Programs that pass verification are guaranteed to be communication safe and free from deadlocks. We verified several parallel programs from textbooks using our approach, and report on the outcome. © C. Santos, F. Martins & V.T. Vasconcelos."
"Sushine J., Herbsleb J.D., Aldrich J." $ "Searching the State Space: A Qualitative Study of API Protocol Usability" $ "Application Programming Interfaces (APIs) often define protocols - restrictions on the order of client calls to API methods. API protocols are common and difficult to use, which has generated tremendous research effort in alternative specification, implementation, and verification techniques. However, little is understood about the barriers programmers face when using these APIs, and therefore the research effort may be misdirected. To understand these barriers better, we perform a two-part qualitative study. First, we study developer forums to identify problems that developers have with protocols. Second, we perform a think-aloud observational study, in which we systematically observe professional programmers struggle with these same problems to get more detail on the nature of their struggles and how they use available resources. In our observations, programmer time was spent primarily on four types of searches of the protocol state space. These observations suggest protocol-targeted tools, languages, and verification techniques will be most effective if they enable programmers to efficiently perform state search. © 2015 IEEE."
"[No author name available]" $ "IEEE International Conference on Program Comprehension" $ "The proceedings contain 38 papers. The topics discussed include: discovering loners and phantoms in commit and issue data, i know what you did last summer - an investigation of how developers spend their time, generating reproducible and replayable bug reports from android application crashes, searching the state space: a qualitative study of API protocol usability, generating refactoring proposals to remove clones from automated system tests, code, camera, action: how software developers document and share program knowledge using YouTube, two user perspectives in program comprehension: end users and developer users, exploring the use of concern element role information in feature location evaluation, manually locating features in industrial source code: the search actions of software nomads, the plague doctor: a promising cure for the window plague, and polymorphism in the spotlight: studying its prevalence in Java and SmallTalk."
"Perakakis E., Ghinea G." $ "HTML5 Technologies for Effective Cross-Platform Interactive/Smart TV Advertising" $ "Developing an interactive TV Commercial (iTVC) for Internet connected TVs is complicated by the number of different platforms, each with its own operating system and application programming interface (API). To achieve cross-platform compatibility, we propose to use standard web technologies, instead of proprietary APIs for each device. With our approach, only one iTVC was developed, which contained commonly used features of these kinds of advertisements, and used only web technologies (HTML5, CSS, and JavaScript). The iTVC was first developed on a desktop personal computer and was tested on three different smart TV platforms for feature compatibility. After achieving compatibility, a user study with 36 participants evaluated how platform-related differences affect aspects of user experience (UX) and effectiveness of the interactive ad. The measured UX/effectiveness aspects and usability were consistent regardless of the iTVC performance on each device. These results show the potential of web technologies to deliver a uniform (and effective) interactive Ad across a range of heterogeneous devices. © 2013 IEEE."
"Heiland R., Koranda S., Marru S., Pierce M., Welch V." $ "Authentication and authorization considerations for a multi-tenant service" $ "Distributed cyberinfrastructure requires users (and machines) to perform some sort of authentication and authorization (together simply known as auth). In the early days of computing, authentication was performed with just a username and password combination, and this is still prevalent today. But during the past several years, we have seen an evolution of approaches and protocols for auth: Kerberos, SSH keys, X.509, OpenID, API keys, OAuth, and more. Not surprisingly, there are trade-offs, both technical and social, for each approach. The NSF Science Gateway communities have had to deal with a variety of auth issues. However, most of the early gateways were rather restrictive in their model of access and development. The practice of using community credentials (certificates), a well-intentioned idea to alleviate restrictive access, still posed a barrier to researchers and challenges for security and auditing. And while the web portal-based gateway clients offered users easy access from a browser, both the interface and the back-end functionality were constrained in the flexibility and extensibility they could provide. Designing a well-defined application programming interface (API) to fine-grained, generic gateway services (on secure, hosted cyberinfrastructure), together with an auth approach that has a lower barrier to entry, will hopefully present a more welcoming environment for both users and developers. This paper provides a review and some thoughts on these topics, with a focus on the role of auth between a Science Gateway and a service provider."
"Schäfer T., Scheck A., Bruneß D., May P., Koch I." $ "The new protein topology graph library web server" $ "Summary: We present a new, extended version of the Protein Topology Graph Library web server. The Protein Topology Graph Library describes the protein topology on the super-secondary structure level. It allows to compute and visualize protein ligand graphs and search for protein structural motifs. The new server features additional information on ligand binding to secondary structure elements, increased usability and an application programming interface (API) to retrieve data, allowing for an automated analysis of protein topology. © The Author 2015. Published by Oxford University Press."
"Schreiner M., Rädle R., Jetter H.-C., Reiterer H." $ "Connichiwa - A framework for cross-device web applications" $ "While Mark Weiser's vision of ubiquitous computing is getting closer to reality, a fundamental part of it-the interconnection of devices into a ""ubiquitous network"",-is not achieved yet. Differences in hardware, architecture, and missing standardizations are just some reasons for this. We think that existing research is not versatile enough and too tailored to either single applications, hardware, or location. We contribute Connichiwa-a versatile framework for creating web applications across multiple devices. We base Connichiwa on four key goals: integration of existing devices, independence of network infrastructure, versatility of application scenario, and usability of its API. Connichiwa runs web applications on off-the-shelf consumer devices. With no external dependencies, such as a server, it enables a great variety of possible scenarios. We tested the technical feasibility of Connichiwa in seven example applications and plan to evaluate the framework and the usability of its API in a one-week Hackathon."
"Niu H., Keivanloo I., Zou Y." $ "API usage pattern recommendation for software development" $ "Application Programming Interfaces (APIs) facilitate pragmatic reuse and improve the productivity of software development. An API usage pattern documents a set of method calls from multiple API classes to achieve a reusable functionality. Existing approaches often use frequent-sequence mining to extract API usage patterns. However, as reported by earlier studies, frequent-sequence mining may not produce a complete set of usage patterns. In this paper, we explore the possibility of mining API usage patterns without relying on frequent-pattern mining. Our approach represents the source code as a network of object usages where an object usage is a set of method calls invoked on a single API class. We automatically extract usage patterns by clustering the data based on the co-existence relations between object usages. We conduct an empirical study using a corpus of 11,510 Android applications. The results demonstrate that our approach can effectively mine API usage patterns with high completeness and low redundancy. We observe 18% and 38% improvement on F-measure and response time respectively comparing to usage pattern extraction using frequent-sequence mining. © 2016 Elsevier Inc."
"Scheller T., Kühn E." $ "Automated measurement of API usability: The API Concepts Framework" $ "Context Usability is an important software quality attribute for APIs. Unfortunately, measuring it is not an easy task since many things like experienced evaluators, suitable test users, and a functional product are needed. This makes existing usability measurement methods difficult to use, especially for non-professionals. Objective To make API usability measurement easier, an automated and objective measurement method would be needed. This article proposes such a method. Since it would be impossible to find and integrate all possible factors that influence API usability in one step, the main goal is to prove the feasibility of the introduced approach, and to define an extensible framework so that additional factors can easily be defined and added later. Method A literature review is conducted to find potential factors influencing API usability. From these factors, a selected few are investigated more closely with usability studies. The statistically evaluated results from these studies are used to define specific elements of the introduced framework. Further, the influence of the user as a critical factor for the framework's feasibility is evaluated. Results The API Concepts Framework is defined, with an extensible structure based on concepts that represent the user's actions, measurable properties that define what influences the usability of these concepts, and learning effects that represent the influence of the user's experience. A comparison of values calculated by the framework with user studies shows promising results. Conclusion It is concluded that the introduced approach is feasible and provides useful results for evaluating API usability. The extensible framework easily allows to add new concepts and measurable properties in the future. © 2015 Elsevier B.V. All rights reserved."
"Saied M.A., Benomar O., Abdeen H., Sahraoui H." $ "Mining multi-level API usage patterns" $ "Software developers need to cope with complexity of Application Programming Interfaces (APIs) of external libraries or frameworks. However, typical APIs provide several thousands of methods to their client programs, and such large APIs are difficult to learn and use. An API method is generally used within client programs along with other methods of the API of interest. Despite this, co-usage relationships between API methods are often not documented. We propose a technique for mining Multi-Level API Usage Patterns (MLUP) to exhibit the co-usage relationships between methods of the API of interest across interfering usage scenarios. We detect multi-level usage patterns as distinct groups of API methods, where each group is uniformly used across variable client programs, independently of usage contexts. We evaluated our technique through the usage of four APIs having up to 22 client programs per API. For all the studied APIs, our technique was able to detect usage patterns that are, almost all, highly consistent and highly cohesive across a considerable variability of client programs. © 2015 IEEE."
"[No author name available]" $ "2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering, SANER 2015 - Proceedings" $ "The proceedings contain 84 papers. The topics discussed include: modeling the evolution of development topics using dynamic topic models, understanding developers' natural language queries with interactive clarification, an observational study on API usage constraints and their documentation, an observational study on API usage constraints and their documentation, measuring the quality of design pattern detection results, JCHARMING: a bug reproduction approach using crash traces and directed model checking, towards a common metamodel for traces of high performance computing systems to enable software analysis tasks, automated extraction of failure reproduction steps from user interaction traces, misery loves company: crowdstacking traces to aid problem detection, and who should review my code? a file location-based code-reviewer recommendation approach for modern code review."
"Kinash N., Tikhomirov A., Trufanov A., Berestneva O., Boukhanovsky A., Ashurova Z." $ "Analysis of large-scale networks using high performance technology (vkontakte case study)" $ "Case study Vkontakte presents an approach to the analysis of large-scale social networks. The paper describes the API usage to design the friend lists for construction of massive social network. It will avoid errors during the building process and select the most efficient parallel graph frameworks for the large network analysis. The case studied the basic parameters of the network Vkontakte, and determined its topology different from scale-free character. The collected dataset is opened for free public download. © Springer International Publishing Switzerland 2015."
"Businge J., Serebrenik A., van den Brand M.G.J." $ "Eclipse API usage: the good and the bad" $ "Today, when constructing software systems, many developers build their systems on top of frameworks. Eclipse is such a framework that has been in existence for over a decade. Like many other evolving software systems, the Eclipse platform has both stable and supported interfaces (“good”) and unstable, discouraged and unsupported interfaces (“bad”). In this study, we investigate Eclipse interface usage by Eclipse third-party plug-ins (ETPs) based on whether they use bad interfaces or not. The investigations, based on empirical analysis present the following observations. First, we discovered that 44 % of the 512 analyzed Eclipse third-party plug-ins depend on “bad” interfaces and that developers continue to use “bad” interfaces. Second, we have observed that plug-ins that use or extend at least one “bad” interface are comparatively larger and use more functionality from Eclipse than those that use only “good” interfaces. Third, the findings show that the ETPs use a diverse set of “bad” interfaces. Fourth, we observed that the reason why the bad interfaces are being eliminated from the ETPs’ source code is, because (ETP developers believe) these non-APIs will cause incompatibilities when a version of the ETP is ported to new Eclipse SDK release. Finally, we observed that when developers eliminate problematic “bad” interfaces, they either re-implement the same functionality in their own API, find equivalent SDK good interfaces, or completely delete the entities in the ETPs’ source code that use the functionality from the “bad” interfaces. © 2013, Springer Science+Business Media New York."
"Rizzardini R.H." $ "Cloud interoperability service architecture for education environments" $ "MOOC adoption is growing, and several challenges are presented with it. One of them is the use of innovative tools for learning, with a special emphasis in having learners to represent their acquired knowledge in creative forms, therefore, some experiences in that regard will be introduced. Thus, orchestrating the learning experience with cloud-based external tools (realized as Web 2.0 tools) brings interoperability issues such as automated management of tools and interoperability scalability. This paper presents a new version of an architecture that is capable of interoperability with external tools by defining a semantic description of the tools' Web API using linked data. This creates the next generation of tool interoperability for educational environments. Furthermore, it makes machine discovery of the Web API possible, therefore, it does not require custom system interfaces to interoperate. It simplifies the plugging in of new external tools and maintenance of integrated services. Additionally, the architecture makes it possible to automate simple and complex tasks to be performed with the external tools, such as creating thousands of tool instances to be used by MOOC learners. The results are very promising and demonstrate that this approach is innovative, scalable and highly accurate. Currently, no standard, specification or framework has the same type of flexibility, integration simplicity and robust management for external tools. © J.UCS."
"González-Burgueño A., Santiago S., Escobar S., Meadows C., Meseguer J." $ "Analysis of the PKCS#11 API using the maude-NPA tool" $ "Cryptographic Application Programmer Interfaces (Crypto APIs) are designed to allow a secure interoperation between applications and cryptographic devices such as smartcards and Hardware Security Modules (HSMs). However, several Crypto APIs have been shown to be subject to attacks in which sensitive information is disclosed to an attacker, such as the RSA Laboratories Public Key Standards PKCS#11, an API widely adopted in industry. Recently, there has been a growing interest on applying automated crypto protocol analysis methods to formally analyze APIs. However, the PKCS#11 has been proven difficult to analyze using such methods since it involves non-monotonic mutable global state. In this paper we specify and analyze the PKCS#11 in Maude-NPA, a general purpose crypto protocol analysis tool. © Springer International Publishing Switzerland 2015."
"Lozano A., Mens K., Kellens A." $ "Usage contracts: Offering immediate feedback on violations of structural source-code regularities" $ "Developers often encode design knowledge through structural regularities such as API usage protocols, coding idioms and naming conventions. As these regularities express how the source code should be structured, they provide vital information for developers using or extending that code. Adherence to such regularities tends to deteriorate over time because they are not documented and checked explicitly. This paper introduces uContracts, an internal DSL to codify and verify such regularities as 'usage contracts'. Our DSL aims at covering most common usage regularities, while still providing a means to express less common ones. Common regularities are identified based on regularities supported by existing approaches to detect bugs or suggest missing code fragments, techniques that mine for structural regularities, as well as on the analysis of an open-source project. We validate our DSL by documenting the structural regularities of an industrial case study, and analyse how useful the information provided by checking these regularities is for the developers of that case study. © 2015 Elsevier B.V. All rights reserved."
"Kapre N." $ "Sparse graph processing with soft-processors" $ "Modern FPGAs can be configured to exploit the large amount of on chip parallelism possible from the distributed SRAM memory blocks for algorithms operating on large sparse graphs. To simplify the programming and configuration of such memory-centric organizations, we can customize an array of soft processors for these graph algorithms. In particular, we can deliver significant performance improvements for bulk synchronous graph algorithms with a custom processor that implements a graph-specific ISA. We develop a C++ API using Vivado High-Level Synthesis to describe graph computations and generate custom soft processors from these high-level descriptions. Our preliminary experiments suggest that our soft processor outperform Micro blaze and NIOS-II/f soft processors by ≈6×. While not the focus of this work, this design can scale out to a cluster of 16 - 32 low-power, energy-efficient Zed boards and Microzed boards to compete with server-class x86 nodes. © 2015 IEEE."
"De Benedictis A., Rak M., Turtur M., Villano U." $ "REST-based SLA management for cloud applications" $ "In cloud computing, possible risks linked to availability, performance and security can be mitigated by the adoption of Service Level Agreements (SLAs) formally agreed upon by cloud service providers and their users. This paper presents the design of services for the management of cloud-oriented SLAs that hinge on the use of a REST-based API. Such services can be easily integrated into existing cloud applications, platforms and infrastructures, in order to support SLA-based cloud services delivery. After a discussion on the SLA life-cycle, an agreement protocol state diagram is introduced. It takes explicitly into account negotiation, remediation and renegotiation issues, is compliant with all the active standards, and is compatible with the WS-Agreement standard. The requirement analysis and the design of a solution able to support the proposed SLA protocol is presented, introducing the REST API used. This API aims at being the basis for a framework to build SLA-based applications. © 2015 IEEE."
"Tang X." $ "Attention, test code is low-quality!" $ "In this paper, we describe the formatting guidelines for ACM SIG Proceedings. Software testing is an essential process during software development and maintenance for improving software quality. Test code, the artefact during software testing, has been widely used in many software quality assurance techniques. Traditionally, software quality assurance techniques, e.g., automatic bug repair, fault localization, test case prioritization, and mining API usage from test code are based on the hypothesis of a sound quality of the test code. However, via empirical study on four open source projects, we found that the quality of test code is quite low comparing with corresponding source code, and this might hurt the above software quality assurance techniques. In this paper, we studied more than 140,000 LOC(lines of code) test code from four large scale and widely used open source projects and found that it is common for test code to be unregulated and of low-quality in open source projects. First, the comment clone ratio, unreleased resource ratio and clone code ratio of test code is much higher than that of corresponding source code, second, bug-fixed coverage is down to 0. We have learned the following lessons: the quality of test code is quite low comparing with corresponding source code, and the low quality test code may misguide existing software quality assurance techniques. Categories and Subject Descriptors D.2.5 [Software Engineering]: [Testing and Debugging] General Terms Experimentation, Measurement. © 2015 for this paper by its authors."
"Weiss J.M." $ "Comparison of POSIX threads, OpenMP and C++11 concurrency frameworks" $ "Multi-core architectures have become the norm on highend computing devices, from desktop computers to tablets to cell phones. In order to take full advantage of parallelism, it is essential to write multithreaded applications. In the past, parallel processing in C++ was been restricted to external libraries. But the C++11 release introduces concurrency constructs into the language itself, providing benefits to software development, optimization, and portability. This paper compares performance and usability of the new C++11 concurrency interface to two widely-used external parallel processing libraries: POSIX threads and OpenMP. Copyright © 2015 by The International Society for Computers and Their Applications (ISCA)."
"Alotaibi H.M., Alamer R.A., Al-Khalifa H.S." $ "MLab: A mobile language learning lab system for language learners" $ "This paper describes the design and development of a mobile language lab system called MLab. The MLab system aims to replace the traditional language lab—which typically has a restrictive layout and lacks interaction—with a more user-friendly, low-cost mobile language lab. The target users of MLab are language teachers and students, and the system offers them the freedom to move around and use their own devices at any time and in any place. The MLab system was developed using several web technologies and Application Programming Interface (API) to provide a fast and convenient method of accessing required content. To evaluate the MLab system, a pilot test was conducted with a class of 15 students and their teacher. The results showed high usability rates and generally positive attitudes toward using the system. © 2015, J.UCS."
"Chen L., Chen K., Shao C., Zhu P." $ "SocAware: A middleware for social applications in online social networks" $ "The popularity of online social network (OSN) services has given rise to a variety of social network applications. However these applications lack a common platform for information sharing and people interoperating. In this paper, we propose SocAware, a middleware designed for OSN services. SocAware extracts social relation from heterogeneous networks, and builds a uniform knowledge base to manage the social information. SocAware distinguishes itself from other OSN middlewares by analyzing the OSN activities to classify the social relations, and by calculating the strength of social relations to provide reusability between social applications. We also provide a set of API to facilitate third-party application development and the effective utilization of these relations. In order to validate SocAware, we developed two prototype applications above the middleware. The experimental results demonstrate the usability and expansibility of the middleware. © 2014 IEEE."
"Brown J., Knepley M.G., Smith B.F." $ "Run-time extensibility and librarization of simulation software" $ "Build-time configuration and environment assumptions are hampering progress and usability in scientific software. This situation, which would be utterly unacceptable in nonscientific software, somehow passes for the norm in scientific packages. The scientific software community needs reusable, easy-to-use software packages that are flexible enough to accommodate next-generation simulation and analysis demands. © 1999-2011 IEEE."
"Lemic F., Handziski V., Wirström N., Van Haute T., De Poorter E., Voigt T., Wolisz A." $ "Web-based platform for evaluation of RF-based indoor localization algorithms" $ "The experimental efforts for optimizing the performance of RF-based indoor localization algorithms for specific environments and scenarios is time consuming and costly. In this work, we address this problem by providing a publicly accessible platform for streamlined experimental evaluation of RF-based indoor localization algorithms, without the need of a physical testbed infrastructure. We also offer an extensive set of raw measurements that can be used as input data for indoor localization algorithms. The datasets are collected in multiple testbed environments, with various densities of measurement points, using different measuring devices and in various scenarios with controlled RF interference. The platform encompasses two core services: one focused on storage and management of raw data, and one focused on automated calculation of metrics for performance characterization of localization algorithms. Tools for visualization of the raw data, as well as software libraries for convenient access to the platform from MATLAB and Python, are also offered. By contrasting its fidelity and usability with respect to remote experiments on dedicated physical testbed infrastructure, we show that the virtual platform produces comparative performance results while offering significant reduction in the complexity, time and labor overheads. © 2015 IEEE."
"Toegl R., Winter J., Gissing M., Winkler T., Nauman M., Hong T.W." $ "Programming interfaces for the TPM" $ "The paradigm of Trusted Computing promises a new approach to improve the security of embedded and mobile systems. The core functionality, based on a hardware component known as Trusted Platform Module (TPM), is widely available. However, integration and application in embedded systems remains limited at present, simply because of the extremely steep learning curve involved in using the programmer–facing interfaces. In this chapter, we describe the current state of the Trusted Computing Group's software architecture and present previous approaches to improve usability. We report on a novel design of a high–level API for Trusted Computing for Java which has been optimized for ease–of–use and clear abstraction of Trusted Computing concepts. We derive requirements and design goals and outline the API design. Finally, we show the application and benchmarks in embedded systems. The result of this effort has been standardized as Java Specification Request 321. © Springer International Publishing Switzerland 2015."
"[No author name available]" $ "CEUR Workshop Proceedings" $ "The proceedings contain 31 papers. The topics discussed include: trusted, fair multi-segment business models, enabled by a user-centric, privacy-aware platform, for a data-driven era, gamifying software development environments using cognitive principles, community-based API builder to manage APIs and their connections with cloud-based services, applying idea management system (IMS) approach to design and implement a collaborative environment in public service related open innovation processes, towards visually monitoring multiple perspectives of business process compliance, the influence of syntactic quality of enterprise process models on model comprehension, KPI-based activity planning for people working in flexible processes, usability evaluation of variability modeling by means of common variability language, patterns for identifying and structuring features from textual descriptions: an exploratory study, and a resource oriented architecture to handle data volume diversity."
"Bukhari A.C., Nagy M.L., Krauthammer M., Ciccarese P., Baker C.J.O." $ "ICyrus: A semantic framework for biomedical image discovery" $ "Images have an irrefutably central role in scientific discovery and discourse. However, the issues associated with knowledge management and utility operations unique to image data are only recently gaining recognition. In our previous work, we have developed Yale Image finder (YIF), which is a novel Biomedical image search engine that indexes around two million biomedical image data, along with associated metadata. While YIF is considered to be a veritable source of easily accessible biomedical images, there are still a number of usability and interoperability challenges that have yet to be addressed. To overcome these issues and to accelerate the adoption of the YIF for next generation biomedical applications, we have developed a publically accessible semantic API for biomedical images with multiple modalities. The core API called iCyrus is powered by a dedicated semantic architecture that exposes the YIF content as linked data, permitting integration with related information resources and consumption by linked data-aware data services. To facilitate the adhoc integration of image data with other online data resources, we also built semantic web services for iCyrus, such that it is compatible with the SADI semantic web service framework. The utility of the combined infrastructure is illustrated with a number of compelling use cases and further extended through the incorporation of Domeo, a well known tool for open annotation. Domeo facilitates enhanced search over the images using annotations provided through crowdsourcing. The iCyrus triplestore currently holds more than thirty-five million triples and can be accessed and operated through syntactic or semantic query interfaces. Core features of the iCyrus API, namely: data reusability, system interoperability, semantic image search, automatic update and dedicated semantic infrastructure make iCyrus a state of the art resource for image data discovery and retrieval. © Copyright 2015 for the individual papers by the papers' authors."
"Demangeon R., Honda K., Hu R., Neykova R., Yoshida N." $ "Practical interruptible conversations: distributed dynamic verification with multiparty session types and Python" $ "The rigorous and comprehensive verification of communication-based software is an important engineering challenge in distributed systems. Drawn from our industrial collaborations (Ocean Observatories Initative, http://www.oceanobservatories.org/, JBoss Savara Project, http://www.jboss.org/savara) on Scribble, a choreography description language based on multiparty session types, and its theoretical foundations (Honda et al., in POPL, pp 273–284, 2008), this article proposes a dynamic verification framework for structured interruptible conversation programming. We first present our extension of Scribble to support the specification of asynchronously interruptible conversations. We then implement a concise API for conversation programming with interrupts in Python that enables session types properties to be dynamically verified for distributed processes. Finally, we expose the underlying theory of our interrupt mechanism, studying its syntax and semantics, its integration in MPST theory and proving the correctness of our design. Our framework ensures the global safety of a system in the presence of asynchronous interrupts through independent runtime monitoring of each endpoint, checking the conformance of the local execution trace to the specified protocol. The usability of our framework for describing and verifying choreographic communications has been tested by integration into the large scientific cyberinfrastructure developed by the Ocean Observatories Initiative. Asynchronous interrupts have proven expressive enough to represent and verify their main classes of communication patterns, including asynchronous streaming and various timeout-based protocols, without introducing any implicit synchronisations. Benchmarks show conversation programming and monitoring can be realised with little overhead. © 2014, Springer Science+Business Media New York."
"Nguyen H.A., Dyer R., Nguyen T.N., Rajan H." $ "Mining preconditions of APIs in large-scale code corpus" $ "Modern software relies on existing application programming interfaces (APIs) from libraries. Formal specifications for the APIs enable many software engineering tasks as well as help developers correctly use them. In this work, we mine large-scale repositories of existing open-source software to derive potential preconditions for API methods. Our key idea is that APIs' preconditions would appear frequently in an ultra-large code corpus with a large number of API usages, while project-specific conditions will occur less frequently. First, we find all client methods invoking APIs. We then compute a control dependence relation from each call site and mine the potential conditions used to reach those call sites. We use these guard conditions as a starting point to automatically infer the preconditions for each API. We analyzed almost 120 million lines of code from SourceForge and Apache projects to infer preconditions for the standard Java Development Kit (JDK) library. The results show that our technique can achieve high accuracy with recall from 75-80% and precision from 82-84%. We also found 5 preconditions missing from human written specifications. They were all confirmed by a specification expert. In a user study, participants found 82% of the mined preconditions as a good starting point for writing specifications. Using our mining result, we also built a benchmark of more than 4,000 precondition-related bugs. Copyright 2014 ACM."
"Bodden E." $ "TS4J: A fluent interface for defining and computing typestate analyses" $ "Typestate analyses determine whether a program's use of a given API obeys this API's usage constraints in the sense that the right methods are called on the right objects in the right order. Previously, we and others have described approaches that generate typestate analyses from textual finitestate property definitions written in specialized domainspecific languages. While such an approach is feasible, it requires a heavyweight compiler, hindering an effective integration into the programmer's development environment and thus often also into her software-development practice. Here we explain the design of a pure-Java interface facilitating both the definition and evaluation of typestate analyses. The interface is fluent, a term coined by Eric Evans and Martin Fowler. Fluent interfaces provide the user with the possibility to write method-invocation chains that almost read like natural-language text, in our case allowing for a seemingly declarative style of typestate definitions. In all previously described approaches, however, fluent APIs are used to build configuration objects. In this work, for the first time we show how to design a fluent API in such a way that it also encapsulates actual computation, not just configuration. We describe an implementation on top of Soot, Heros and Eclipse, which we are currently evaluating together with pilot customers in an industrial context at Fraunhofer SIT. © Copyright 2014 ACM."
"Akbar R.J., Omori T., Maruyama K." $ "Mining API usage patterns by applying method categorization to improve code completion" $ "Developers often face difficulties while using APIs. API usage patterns can aid them in using APIs efficiently, which are extracted from source code stored in software repositories. Previous approaches have mined repositories to extract API usage patterns by simply applying data mining techniques to the collection of method invocations of API objects. In these approaches, respective functional roles of invoked methods within API objects are ignored. The functional role represents what type of purpose each method actually achieves, and a method has a specific predefined order of invocation in accordance with its role. Therefore, the simple application of conventional mining techniques fails to produce API usage patterns that are helpful for code completion. This paper proposes an improved approach that extracts API usage patterns at a higher abstraction level rather than directly mining the actual method invocations. It embraces a multilevel sequential mining technique and uses categorization of method invocations based on their functional roles. We have implemented a mining tool and an extended Eclipse's code completion facility with extracted API usage patterns. Evaluation results of this tool show that our approach improves existing code completion. © 2014 The Institute of Electronics, Information and Communication Engineers."
"Ko D., Ma K., Park S., Kim S., Kim D., Traon Y.L." $ "API document quality for resolving deprecated APIs" $ "Using deprecated APIs often results in security vulnerability or performance degradation. Thus, invocations to deprecated APIs should be immediately replaced by alternative APIs. To resolve deprecated APIs, most developers rely on API documents provided by service API libraries. However, the documents often do not have sufficient information. This makes many deprecated API usages remain unresolved, which leads programs to vulnerable states. This paper reports a result of studying document quality for deprecated APIs. We first collected 260 deprecated APIs of eight Java libraries as well as the corresponding API documents. These documents were manually investigated to figure out whether it provides alternative APIs, rationales, or examples. Then, we examined 2,126 API usages in 249 client applications and figured out whether those were resolved in the subsequent versions. This study revealed that 1) 3.6 APIs was deprecated and 3.6 deprecated APIs are removed from the library a month on average, 2) only 61% of API documents provided alternative APIs while rationale and examples were rarely documented, and 3) 62% of deprecate API usages in client applications were resolved if the corresponding API documents provided alternative APIs while 49% were resolved when the documents provided no alternative APIs. Based on these results, we draw future directions to encourage resolving deprecated APIs. © 2014 IEEE."
"Cardoso B., Romão T." $ "The timeline as a programming interface" $ "The task of implementing meaningful reactive behavior in mobile applications is not trivial. To abstract over platform-specific details while writing expressive and legible code, we've developed EveWorks, a framework for context awareness that interfaces with the rest of the application code through statements written in a simple, interpreted language. In this work, we explain the conceptualization that stands at the core of our framework's language, inspired by one of the most ubiquitous representations of temporality, the timeline."
"Ghafari M., Heydarnoori A." $ "Towards a visualized code recommendation for APIs enriched with specification mining" $ "This paper positions an idea for an interactive code recommendation system. In this work, candidate recommendations are abstracted as a graph-based visualization of the API usages that are decorated with the API specifications and the usage rules mined from the unit test cases of the given API and its usage examples. The user can then progressively explore this graph to obtain her desired code with- out delving into the implementation details. © 2014 ACM."
"Petersen P., Hanenberg S., Robbes R." $ "An empirical comparison of static and dynamic type systems on API usage in the presence of an IDE: Java vs. Groovy with eclipse" $ "Several studies have concluded that static type systems offer an advantage over dynamic type systems for programming tasks involving the discovery of a new API. However, these studies did not take into account modern IDE features, the advanced navigation and code completion techniques available in modern IDEs could drastically alter their conclusions. This study describes an experiment that compares the usage of an unknown API using Java and Groovy using the IDE Eclipse. It turns out that the previous finding that static type systems improve the usability of an unknown API still holds, even in the presence of a modern IDE. Copyright © 2014 ACM."
"Ghafari M." $ "Extracting code examples from unit test cases" $ "Understanding how to properly use APIs of large libraries is difficult, error prone, and time consuming. Software developers resort to study to learn APIs. Several approaches have been proposed to mine these examples, but the sources from which they mine examples as well as their mining approaches hamper their applicability in some practical scenarios. Unit test cases seem to be an additional source of significant API examples, which may overcome the aforementioned difficulties. Synthesizing meaningful examples from tests not only improves the applicability of current code recommendation systems, but also facilitates providing up to date API examples to augment documentation. However, mining examples of API use from unit tests is a non trivial task and arises several research challenges summarized in this paper. © 2014 IEEE."
"Chen C., Zhang K." $ "Who asked what: Integrating crowdsourced FAQs into API documentation" $ "Documentation is important for learning Application Pro-gramming Interfaces (APIs). In addition to official docu-ments, much crowdsourced API knowledge is available on the Web. Crowdsourced API documentation is fragmented, scattered around the Web, and disconnected from official doc-umentation. Developers often rely on Web search to retrieve additional programming help. We propose to connect these two types of documentation by capturing developers' Web browsing behavior in the context of document reading and integrating crowdsourced frequently asked questions (FAQs) into API documents. Such an integration not only provides relevant API help more conveniently, but also opens a new approach to promoting knowledge collaboration and studying API users' information needs. Copyright © 2014 ACM."
"Pandit M.R., Bhardwaj T., Khatri V." $ "Steps towards web ubiquitous computing" $ "With evasion of digital convergence [1], computing has by and large pervaded into our environment. WWW has enhanced day-to-day life by utilizing information such as Location awareness, User-context awareness, touch API, mutation observer [2], and many more. The future [3] trends in ubiquitous computing [4] provide a great scope for innovation and value-added services.With approach of “computing being embedded,” the future sees its usage more pervasive and appealing. Web is evolving and so are supporting technologies (in terms of hardware technologies). Many real-life examples including augmented-reality, wearable technologies, gesture-based recognition systems, etc., are already in place illustrating its high-end usage. Such diverse future targeting billions of people and devices need streamlined approach. Some steps have already been taken care by World Wide Web consortium (W3C) to provide standards relating to API usage. In this paper, we highlight various aspects of web-ubiquitous computing and how they can be dealt w.r.t to their implementation. © Springer India 2014."
"Lorenzon A.F., Filho A.C.S.B., Cera M.C." $ "The impact of different multi-threading interfaces on embedded systems" $ "The popularity of multicore embedded systems brings new challenges to the development of parallel applications: at the same time it is necessary to exploit the availability of multiple cores, it is also mandatory to consume less energy. To speed up the development process and make it as more transparent as possible to the programmer, parallelism is exploited through the use of Application Programming Interfaces (API). Each one of these API implements different ways to exchange data. However, data exchange occurs between the threads in shared memory regions, which have higher energy consumption. Therefore, each API will present different energy costs to communicate. In this paper, we present the first step to show that different APIs have different impacts on energy consumption, through the analysis of the communication mechanism that each one employs, the number of memory accesses necessary for the communication, and the number of executed instructions according to the API used. Our results show that OpenMP presents a higher communication overhead, with more memory accesses and instructions executed, when compared to Pthreads. © 2013 IEEE."
"Acretoaie V., Störrle H." $ "Hypersonic: Model analysis and checking in the cloud" $ "Modeling tools are traditionally delivered as monolithic desktop applications, optionally extended by plug-ins or special purpose central servers. This delivery model suffers from several drawbacks, ranging from poor scalability to difficult maintenance and the proliferation of shelfware"". Objective: In this paper we investigate the conceptual and technical feasibility of a new software architecture for modeling tools, where certain advanced features are factored out of the client and moved towards the Cloud. With this approach we plan to address the above mentioned drawbacks of existing modeling tools. Method: We base our approach on RESTful Web services. Using features implemented in the existing Model Analysis and Checking (MACH) tool, we create a RESTful Web service API offering model analysis facilities. We refer to it as the Hypersonic API. We provide a proof of concept implementation for the Hypersonic API using model clone detection as our example case. We also implement a sample Web application as a client for these Web services. Results: Our initial experiments with Hypersonic demonstrate the viability of our approach. By applying standards such as REST and JSON in combination with Prolog as an implementation language, we are able to transform MACH from a command line tool into the first Web-based model clone detection service with remarkably little effort."
"De Roover C., Stevens R." $ "Building development tools interactively using the EKEKO meta-programming library" $ "EKEKO is a Clojure library for applicative logic meta-programming against an Eclipse workspace. EKEKO has been applied successfully to answering program queries (e.g., ""does this bug pattern occur in my code?""), to analyzing project corpora (e.g., 'how often does this API usage pattern occur in this corpus?'), and to transforming programs (e.g., ""change occurrences of this pattern as follows"") in a declarative manner. These applications rely on a seamless embedding of logic queries in applicative expressions. While the former identify source code of interest, the latter associate error markers with, compute statistics about, or rewrite the identified source code snippets. In this paper, we detail the logic and applicative aspects of the EKEKO library. We also highlight key choices in their implementation. In particular, we demonstrate how a causal connection with the Eclipse infrastructure enables building development tools interactively on the Clojure read-eval-print loop. © 2014 IEEE."
"Shin J." $ "Investigating the accuracy of the openFDA API using the FDA Adverse Event Reporting System (FAERS)" $ "The US Food and Drug Administration (FDA) Adverse Event Reporting System (FAERS) is a database that contains information on adverse event and medication error reports submitted to the FDA. Each quarter the FDA releases the data to the public, but accessing the data requires researchers to download, import, and consolidate data for every quarter starting from 2004. In an effort to provide easier access to this, the FDA launched the openFDA initiative in June 2014, which gives the public API access to information about adverse events reports. Although the API enables easier access to the FAERS data, the quality of the API design and the features of the data set will determine the reliability of the information retrieved. Thus, errors in the API can result in inaccurate and unreliable data analysis. Furthermore, the number of adverse events reports retrieved by the API for a particular drug can differ from the FAERS data files due to the openFDA harmonization process and the existence of multiple entries and variations for any given drug name in the FAERS data files. Since there are no universal rule that can be used to identify errors or potential issues, we propose evaluating the openFDA API by searching for a particular drug (brand name), Yaz, and the generic name, Drospirenone Ethinyl Estradiol, and comparing the results against the FAERS data files. Our results show that in the case of Yaz, the openFDA API and the drug harmonization process is inaccurate and inconsistent. © 2014 IEEE."
"Steele G.L., Jr., Lea D., Flood C.H." $ "Fast splittable pseudorandom number generators" $ "We describe a new algorithm SPLITMIX for an objectoriented and splittable pseudorandom number generator (PRNG) that is quite fast: 9 64-bit arithmetic/logical operations per 64 bits generated. A conventional linear PRNG object provides a generate method that returns one pseudorandom value and updates the state of the PRNG, but a splittable PRNG object also has a second operation, split, that replaces the original PRNG object with two (seemingly) independent PRNG objects, by creating and returning a new such object and updating the state of the original object. Splittable PRNG objects make it easy to organize the use of pseudorandom numbers in multithreaded programs structured using forkjoin parallelism. No locking or synchronization is required (other than the usual memory fence immediately after object creation). Because the generate method has no loops or conditionals, it is suitable for SIMD or GPU implementation. Copyright 2014 ACM.We derive SPLITMIX from the DOTMIX algorithm of Leiserson, Schardl, and Sukha by making a series of program transformations and engineering improvements. The end result is an object-oriented version of the purely functional API used in the Haskell library for over a decade, but SPLITMIX is faster and produces pseudorandom sequences of higher quality, it is also far superior in quality and speed to Java.util.Random, and has been included in Java JDK8 as the class Java.util.SplittableRandom. We have tested the pseudorandom sequences produced by SPLITMIX using two standard statistical test suites (DieHarder and TestU01) and they appear to be adequate for ""everyday"" use, such as in Monte Carlo algorithms and randomized data structures where speed is important."
"Steele G.L., Jr., Lea D., Flood C.H." $ "Fast splittable pseudorandom number generators" $ "We describe a new algorithm SPLITMIX for an object-oriented and splittable pseudorandom number generator (PRNG) that is quite fast: 9 64-bit arithmetic/logical operations per 64 bits generated. A conventional linear PRNG object provides a generate method that returns one pseudorandom value and updates the state of the PRNG, but a splittable PRNG object also has a second operation, split, that replaces the original PRNG object with two (seemingly) independent PRNG objects, by creating and returning a new such object and updating the state of the original object. Splittable PRNG objects make it easy to organize the use of pseudorandom numbers in multithreaded programs structured using fork-join parallelism. No locking or synchronization is required (other than the usual memory fence immediately after object creation). Because the generate method has no loops or conditionals, it is suitable for SIMD or GPU implementation. We derive SPLITMIX from the DOTMIX algorithm of Leiserson, Schardl, and Sukha by making a series of program transformations and engineering improvements. The end result is an object-oriented version of the purely functional API used in the Haskell library for over a decade, but SPLITMIX is faster and produces pseudorandom sequences of higher quality, it is also far superior in quality and speed to java.util. Random, and has been included in Java JDK8 as the class java.util. SplittableRandom. We have tested the pseudorandom sequences produced by SPLITMIX using two standard statistical test suites (DieHarder and TestU01) and they appear to be adequate for ""everyday"" use, such as in Monte Carlo algorithms and randomized data structures where speed is important. Copyright © 2014 ACM."
"Diprose J.P., Plimmer B., Macdonald B.A., Hosking J.G." $ "A human-centric API for programming socially interactive robots" $ "Whilst robots are increasingly being deployed as social agents, it is still difficult to program them to interact socially. This is because current programming tools either require programmers to work at a low level or lack features needed to create certain aspects of social interaction. High level, domain specific tools with features designed specifically to meet the requirements of social interaction have the potential to ease the creation of social applications. We present a domain specific application programming interface (API) that is designed to meet the requirements of social interaction. The Cognitive Dimensions Framework was used as a design tool during the design process and the API was validated by implementing an exemplar application. The evaluation of the API showed that programmers with no robotics knowledge were positively impressed by the notation and that its organization, domain specific interfaces and object oriented nature positively affected several Cognitive Dimensions. © 2014 IEEE."
"Lu H.K." $ "Keeping your API keys in a safe" $ "Cloud API (Application Programming Interface) enables client applications to access services and manage resources hosted in the Cloud. To protect themselves and their customers, Cloud service providers (CSP) often require client authentication for each API call. The authentication usually depends on some kind of secret (or called API key), for example, secret access key, password, or access token. As such, the API key unlocks the door to the treasure inside the Cloud. Hence, protecting these keys is critical. It is a difficult task especially on the client side, such as users' computers or mobile devices. How do CSPs authenticate client applications? What are security risks of managing API keys in common practices? How can we mitigate these risks? This paper focuses on finding answers to these questions. By reviewing popular client authentication methods that CSPs use and using Cloud APIs as software developers, we identified various security risks associated with API keys. To mitigate these risks, we use hardware secure elements for secure key provisioning, storage, and usage. The solution replaces the manual key handling with end-to-end security between CSP and its customers' secure elements. This removes the root causes of the identified risks and enhances API security. It also enhances the usability by eliminating manual key operations and alleviating software developers' worries of working with cryptography. © 2014 IEEE."
"Nagaraju S." $ "Shapers: Capturing free form shapes for bendable device interactions" $ "Future mobile and wearable devices are heavily influenced by advances in materials which make the devices flexible to interact. In this paper, we propose a system to capture the shape of bent device at graphics framework and make use of the shape to develop novel user interactions for native and app store downloadable applications on consumer electronic devices. We further detail the API, parameters and prototype on Android for shape generation along with OpenGL based emulation for bendable device deformation, followed by usability study results. © 2014 The Authors. Published by Elsevier B.V."
"Ertugrul A.M., Onal I." $ "RemindMe: An enhanced mobile location-based reminder application" $ "In this study, a location based reminder application RemindMe, enhanced with various location tagging options using social networking APIs is proposed. Main purpose of this application is to allow users to create reminders based on the location besides time and to notify users with those reminders automatically. In terms of ease of use, a hybrid structure consisting of various components is formed for location tagging. First of all, the user tags the locations using the applications such as Google Maps or Foursquare or via the embedded sensors of the Android device. Then, he creates reminders for the tagged locations and when he gets close to this location, the system notifies the user. Our application is separated from similar applications with its enhanced location tagging feature. Moreover, by consisting of various services, it is open to innovations on the way to become a social reminder application. The usability test results indicate that RemindMe is an effective location based reminder application. © 2014 IEEE."
"Danelutto M., Torquati M." $ "Loop parallelism: A new skeleton perspective on data parallel patterns" $ "Traditionally, skeleton based parallel programming frameworks support data parallelism by providing the programmer with a comprehensive set of data parallel skeletons, based on different variants of map and reduce patterns. On the other side, more conventional parallel programming frameworks provide application programmers with the possibility to introduce parallelism in the execution of loops with a relatively small programming effort. In this work, we discuss a ""ParallelFor"" skeleton provided within the FastFlow framework and aimed at filling the usability and expressivity gap between the classical data parallel skeleton approach and the loop parallelisation facilities offered by frameworks such as OpenMP and Intel TBB. By exploiting the low run-time overhead of the FastFlow parallel skeletons and the new facilities offered by the C++11 standard, our ParallelFor skeleton succeeds to obtain comparable or better performance than both OpenMP and TBB on the Intel Phi many-core and Intel Nehalem multi-core for a set of benchmarks considered, yet requiring a comparable programming effort. © 2014 IEEE."
"Zaghi S." $ "OFF, Open source Finite volume Fluid dynamics code: A free, high-order solver based on parallel, modular, object-oriented Fortran API" $ "OFF, an open source (free software) code for performing fluid dynamics simulations, is presented. The aim of OFF is to solve, numerically, the unsteady (and steady) compressible Navier-Stokes equations of fluid dynamics by means of finite volume techniques: the research background is mainly focused on high-order (WENO) schemes for multi-fluids, multi-phase flows over complex geometries. To this purpose a highly modular, object-oriented application program interface (API) has been developed. In particular, the concepts of data encapsulation and inheritance available within Fortran language (from standard 2003) have been stressed in order to represent each fluid dynamics ""entity"" (e.g. the conservative variables of a finite volume, its geometry, etc...) by a single object so that a large variety of computational libraries can be easily (and efficiently) developed upon these objects. The main features of OFF can be summarized as follows: Programming LanguageOFF is written in standard (compliant) Fortran 2003, its design is highly modular in order to enhance simplicity of use and maintenance without compromising the efficiency, Parallel Frameworks Supported the development of OFF has been also targeted to maximize the computational efficiency: the code is designed to run on shared-memory multi-cores workstations and distributed-memory clusters of shared-memory nodes (supercomputers), the code's parallelization is based on Open Multiprocessing (OpenMP) and Message Passing Interface (MPI) paradigms, Usability, Maintenance and Enhancement in order to improve the usability, maintenance and enhancement of the code also the documentation has been carefully taken into account, the documentation is built upon comprehensive comments placed directly into the source files (no external documentation files needed): these comments are parsed by means of doxygen free software producing high quality html and latex documentation pages, the distributed versioning system referred as git has been adopted in order to facilitate the collaborative maintenance and improvement of the code, CopyrightsOFF is a free software that anyone can use, copy, distribute, study, change and improve under the GNU Public License version 3. The present paper is a manifesto of OFF code and presents the currently implemented features and ongoing developments. This work is focused on the computational techniques adopted and a detailed description of the main API characteristics is reported. OFF capabilities are demonstrated by means of one and two dimensional examples and a three dimensional real application."
"Viyanon W." $ "Bus search: Development and evaluation of performance and usability of mobile application for blind or visually impaired" $ "This paper describes the design and development of a mobile application supporting independent travel in accessing public buses for people who are blind or visually impaired. The key objective is to develop solutions that are low cost, have an intuitive and easy to use interface. The Android architecture was used with speech recognition (SR) technology in order to assist blind or visually impaired users. With the help of A-GPS in phones and through Web Services using GPRS, Location Based Services can be implemented on android based on smart phones to provide value-added services: retrieving current traffic conditions, providing routing information, getting estimated wait time for users. The mobile application supports two languages, English and Thai as voice inputs using open-source CMU Sphinx for Thai and Google speech recognition API for English. Empirical analysis under various environments such as indoor, outdoor, and building surrounded and usability studies were performed to illustrate the efficacy of the application. The results of average of application response time are acceptable according to SOASTA's survey. Improved feedback was added based on usability study results."
"Spiza S., Hanenberg S." $ "Type names without static type checking already improve the usability of APIs (As Long as the Type Names are Correct): An Empirical Study" $ "In the discussion about the usefulness of static or dynamic type systems there is often the statement that static type systems improve the documentation of software. In the meantime there exists even some empirical evidence for this statement. One of the possible explanations for this positive influence is that the static type system of programming languages such as Java require developers to write down the type names, i.e. lexical representations which potentially help developers. Because of that there is a plausible hypothesis that the main benefit comes from the type names and not from the static type checks that are based on these names. In order to argue for or against static type systems it is desirable to check this plausible hypothesis in an experimental way. This paper describes an experiment with 20 participants that has been performed in order to check whether developers using an unknown API already benefit (in terms of development time) from the pure syntactical representation of type names without static type checking. The result of the study is that developers do benefit from the type names in an API's source code. But already a single wrong type name has a measurable significant negative impact on the development time in comparison to APIs without type names. Copyright © 2014 ACM. Copyright © 2014 ACM."
"Kührer M., Hoffmann J., Holz T." $ "CloudSylla: Detecting suspicious system calls in the cloud" $ "To protect computer systems against the tremendous number of daily malware threats, security software is typically installed on individual end hosts and the responsibility to keep this software updated is often assigned to (inexperienced) users. A critical drawback of this strategy, especially in enterprise networks, is that a single unprotected client system might lead to severe attacks such as industrial espionage. To overcome this problem, a potential approach is to move the responsibility to utilize the latest detection mechanisms to a centralized, continuously maintained network service to identify suspicious behavior on end hosts and perform adequate actions once a client invokes malicious activities. In this paper, we propose a security approach called CloudSylla (Cloud-based SY scaLL Analysis) in which we utilize a centralized network service to analyze the clients’ activities directly at the API and system call level. This enables, among other advantages, a centralized management of signatures and a unified security policy. To evaluate the applicability of our approach, we implemented prototypes for desktop computers and mobile devices and found this approach to be applicable in practice as no substantial limitations of usability are caused on the client side. © Springer International Publishing Switzerland 2014."
"Stroggylos K., Mitropoulos D., Tzermias Z., Papadopoulos P., Rafailidis F., Spinellis D., Ioannidis S., Katsaros P." $ "TRACER: A platform for securing legacy code" $ "A security vulnerability is a programming error that introduces a potentially exploitable weakness into a computer system. Such a vulnerability can severely affect an organization's infrastructure and cause significant financial damage to it. Hence, one of the basic pursuits in every new software release should be to mitigate such defects. A number of tools and techniques are available for performing vulnerability detection in software written in various programming platforms. One of the most common approaches to identify software vulnerabilities is static analysis [1]. This kind of analysis is performed by automated tools either on the program's source or object code and without actually executing it. However, since the formats in which static analysis tools store and present their results vary wildly, it is typically difficult to utilize many of them in the scope of a project. By automating the process of running a variety of vulnerability detectors and collecting their results in an efficient manner during development, the task of tracking security defects throughout the evolution history of software projects can be simplified. In this paper we present TRACER, a framework to support the development of secure applications by constantly monitoring software projects for vulnerabilities. TRACER simplifies the integration of existing tools that detect software vulnerabilities and promotes their use during development and maintenance. Instead of designing and implementing TRACER from the ground up, we built it on top of the open source Alitheia Core [2] platform, which is designed for facilitating large scale quantitative software engineering studies. While Alitheia Core aims for efficient estimation of the quality of software projects, TRACER was designed with a focus on software security. To support the specific objectives of TRACER, a set of new components was added at each level of the Alitheia Core architecture. These include a model for representing software vulnerabilities, a mechanism for automatic vulnerability detection triggering, a REST API for accessing the analysis results, and an archetype for plug-ins to integrate new vulnerability detection tools in the platform. Like Alitheia Core, TRACER monitors multiple data sources associated with the development of a software project, such as the source code repository and bug tracking system, and automatically analyzes each revision. Therefore it can be used to track security defects throughout the evolution of a project. In most cases, the detection of vulnerabilities on a software artifact involves only two steps: invoking an external tool created for this purpose with specific arguments as required, and evaluating the results it generates. There is a vast number of software vulnerability detection tools available, each one having different operating requirements. Such a tool can be integrated in TRACER by creating a corresponding driver that implements these two steps and stores the results using the data model provided by the platform. Thus we can leverage the functionality provided by existing tools, without duplicating it. Such an external tool driver is called a vulnerability detector plug-in, and it uses the Alitheia Core infrastructure to handle automatic activation, as well as storage and retrieval of results. Each vulnerability detector is associated with the set of vulnerability types it can detect and the different types of software artifacts or programming constructs that it can analyze. This allows the platform to automatically trigger it when needing to check if a software project or artifact is vulnerable to a specific type of attacks or a new artifact is submitted to the system for evaluation. To demonstrate the efficiency and usability of the platform, we have created plug-ins to integrate two different tools for vulnerability detection, namely: FindBugs [3], and Frama-c [4]. The former analyzes applications written in Java, while the latter examines applications written in c. This highlights the fact that our platform does not depend on the programming language used to develop the project that is being analyzed, and that the simplicity of integrating third party tools leads to high levels of expandability of the platform. © 2014 Springer International Publishing."
"Chang K.S.-P., Myers B.A., Cahill G.M., Simanta S., Morris E., Lewis G." $ "A plug-in architecture for connecting to new data sources on mobile devices" $ "A key use for mobile devices is to search and view online information while on the go. As a result, many mobile applications serve as front ends for online databases. While there are many thousands of data sources that provide web service APIs giving access to their databases, creating mobile applications to use those sources requires significant mobile programming knowledge and a significant amount of time. We introduce Spinel, a plug-in architecture for Android, and a set of web-based configuration tools that together enable users to connect mobile applications to new data sources without programming. Spinel also provides APIs that make it easy for developers to create new applications that use those data sources. We provide three demonstration Android applications that use such data: Listpad for entering personal lists, Listviewer for viewing results of data queries, and Mapviewer for displaying query results on a map. An informal usability study showed that users could successfully attach new data sources to those applications. © 2013 IEEE."
"Wang J., Dang Y., Zhang H., Chen K., Xie T., Zhang D." $ "Mining succinct and high-coverage API usage patterns from source code" $ "During software development, a developer often needs to discover specific usage patterns of Application Programming Interface (API) methods. However, these usage patterns are often not well documented. To help developers to get such usage patterns, there are approaches proposed to mine client code of the API methods. However, they lack metrics to measure the quality of the mined usage patterns, and the API usage patterns mined by the existing approaches tend to be many and redundant, posing significant barriers for being practical adoption. To address these issues, in this paper, we propose two quality metrics (succinctness and coverage) for mined usage patterns, and further propose a novel approach called Usage Pattern Miner (UP-Miner) that mines succinct and high-coverage usage patterns of API methods from source code. We have evaluated our approach on a large-scale Microsoft codebase. The results show that our approach is effective and outperforms an existing representative approach MAPO. The user studies conducted with Microsoft developers confirm the usefulness of the proposed approach in practice. © 2013 IEEE."
"[No author name available]" $ "2013 10th Working Conference on Mining Software Repositories, MSR 2013 - Proceedings" $ "The proceedings contain 63 papers. The topics discussed include: why so complicated? simple term filtering and weighting for location-based bug report assignment recommendation, bug report assignee recommendation using activity profiles, retrieving and analyzing mobile apps feature requests from online reviews, Gerrit software code review data from android, why, when, and what: analyzing stack overflow questions by topic, type, and code, deficient documentation detection: a methodology to locate deficient project documentation using topic analysis, detecting API usage obstacles: a study of iOS and Android developer questions, a discriminative model approach for suggesting tags automatically for stack overflow questions, a study of innovation diffusion through link sharing on stack overflow, building reputation in stackoverflow: an empirical investigation, and intensive metrics for the study of the evolution of open source projects: case studies from apache software foundation projects."
"Piccioni M., Furia C.A., Meyer B." $ "An empirical study of API usability" $ "Modern software development extensively involves reusing library components accessed through their Application Programming Interfaces (APIs). Usability is therefore a fundamental goal of API design, but rigorous empirical studies of API usability are still relatively uncommon. In this paper, we present the design of an API usability study which combines interview questions based on the cognitive dimensions framework, with systematic observations of programmer behavior while solving programming tasks based on ''tokens''. We also discuss the implementation of the study to assess the usability of a persistence library API (offering functionalities such as storing objects into relational databases). The study involved 25 programmers (including students, researchers, and professionals), and provided additional evidence to some critical features evidenced by related studies, such as the difficulty of finding good names for API features and of discovering relations between API types. It also discovered new issues relevant to API design, such as the impact of flexibility, and confirmed the crucial importance of accurate documentation for usability. © 2013 IEEE."
"McDonnell T., Ray B., Kim M." $ "An empirical study of API stability and adoption in the android ecosystem" $ "When APIs evolve, clients make corresponding changes to their applications to utilize new or updated APIs. Despite the benefits of new or updated APIs, developers are often slow to adopt the new APIs. As a first step toward understanding the impact of API evolution on software ecosystems, we conduct an in-depth case study of the co-evolution behavior of Android API and dependent applications using the version history data found in github. Our study confirms that Android is evolving fast at a rate of 115 API updates per month on average. Client adoption, however, is not catching up with the pace of API evolution. About 28% of API references in client applications are outdated with a median lagging time of 16 months. 22% of outdated API usages eventually upgrade to use newer API versions, but the propagation time is about 14 months, much slower than the average API release interval (3 months). Fast evolving APIs are used more by clients than slow evolving APIs but the average time taken to adopt new versions is longer for fast evolving APIs. Further, API usage adaptation code is more defect prone than the one without API usage adaptation. This may indicate that developers avoid API instability. © 2013 IEEE."
"Cardoso J.C.S., José R." $ "Evaluation of a programming toolkit for interactive public display applications" $ "Interaction is repeatedly pointed out as a key enabling element towards more engaging and valuable public displays. Still, most digital public displays today do not support any interactive features. We argue that this is mainly due to the lack of efficient and clear abstractions that developers can use to incorporate interactivity into their applications. As a consequence, interaction represents a major overhead for developers, and users are faced with inconsistent interaction models across different displays. This paper describes the results of the evaluation of a widget toolkit for generalized interaction with public displays. Our toolkit was developed for web-based applications and it supports multiple interaction mechanisms, automatically generated graphical interfaces, asynchronous events and concurrent interaction. We have evaluated the toolkit along various dimensions - system performance, API usability, and real-world deployment - and we present and discuss the results in this paper. © 2013 ACM."
"Sankhe P., Kuriakose S., Lahiri U." $ "A step towards a robotic system with smartphone working as its brain: An assistive technology" $ "This paper describes a novel smartphone based navigation application. The smartphone based robotic system is sensitive to both the tactile and head-movement input commands from a user. Here we present our design used for developing a prototype of the robotic system as a proof-of-concept of an assistive technology that could facilitate partially disabled people to navigate effectively. Additionally we designed a usability study where our prototype was validated by seven healthy participants. Such an intelligent robotic system controlled by a smartphone can find a variety of applications based on navigation systems for disabled persons, educational tools especially for children with autism, surveillance and social telepresence. The hardware prototype could then be further used for development purposes to build a variety of applications using Application Program Interfaces (APIs) that can program the robot to do a custom task. © 2013 IEEE."
"Dayarathna M., Suzumura T." $ "A first view of exedra: A domain-specific language for large graph analytics workflows" $ "In recent years, many programming models, software libraries, and middleware have appeared for processing large graphs of various forms. However, there exists a significant usability gap between the graph analysis scientists, and High Performance Computing (HPC) application programmers due to the complexity of HPC graph analysis software. In this paper we provide a basic view of Exedra, a domain-specific language (DSL) for large graph analysis in which we aim to eliminate the aforementioned complexities. Exedra consists of high level language constructs for specifying different graph analysis tasks on distributed environments. We implemented Exedra DSL on a scalable graph analysis platform called Dipper. Dipper uses Igraph/R interface for creating graph analysis workflows which in turn gets translated to Exedra statements. Exedra statements are interpreted by Dipper interpreter, and gets mapped to user specified libraries/ middleware. Exedra DSL allows for synthesize of graph algorithms that are more efficient compared to bare use of graph libraries while maintaining a standard interface that could use even future graph analysis software. We evaluated Exedra's feasibility for expressing graph analysis tasks by running Dipper on a cluster of four nodes. We observed that Dipper has the ability of reducing the time taken for graph analysis when the workflow was distributed on all four nodes despite the communication, and data format conversion overhead of the Dipper framework."
"Elangovan V.K., Badia R.M., Parra E.A." $ "OmpSs-OpenCL programming model for heterogeneous systems" $ "The advent of heterogeneous computing has forced programmers to use platform specific programming paradigms in order to achieve maximum performance. This approach has a steep learning curve for programmers and also has detrimental influence on productivity and code re-usability. To help with this situation, OpenCL an open-source, parallel computing API for cross platform computations was conceived. OpenCL provides a homogeneous view of the computational resources (CPU and GPU) thereby enabling software portability across different platforms. Although OpenCL resolves software portability issues, the programming paradigm presents low programmability and additionally falls short in performance. In this paper we focus on integrating OpenCL framework with the OmpSs task based programming model using Nanos run time infrastructure to address these shortcomings. This would enable the programmer to skip cumbersome OpenCL constructs including OpenCL plaform creation, compilation, kernel building, kernel argument setting and memory transfers, instead write a sequential program with annotated pragmas. Our proposal mainly focuses on how to exploit the best of the underlying hardware platform with greater ease in programming and to gain significant performance using the data parallelism offered by the OpenCL run time for GPUs and multicore architectures. We have evaluated the platform with important benchmarks and have noticed substantial ease in programming with comparable performance. © © Springer-Verlag Berlin Heidelberg 2013."
"De Roover C., Lammel R., Pek E." $ "Multi-dimensional exploration of API usage" $ "This paper is concerned with understanding API usage in a systematic, explorative manner for the benefit of both API developers and API users. There exist complementary, less explorative methods, e.g., based on code search, code completion, or API documentation. In contrast, our approach is highly interactive and can be seen as an extension of what IDEs readily provide today. Exploration is based on multiple dimensions: i) the hierarchically organized scopes of projects and APIs, ii) metrics of API usage (e.g., number of project classes extending API classes), iii) metadata for APIs, iv) project- versus API-centric views. We also provide the QUAATLAS corpus of Java projects which enhances the existing QUALITAS corpus to enable API-usage analysis. We implemented the exploration approach in an open-source, IDE-like, Web-enabled tool EXAPUS. © 2013 IEEE."
"Song F., Touili T." $ "Model-checking software library API usage rules" $ "Modern software increasingly relies on using libraries which are accessed via Application Programming Interfaces (APIs). Libraries usually impose constraints on how API functions can be used (API usage rules) and programmers have to obey these API usage rules. However, API usage rules often are not well-documented or documented informally. In this work, we show how to use the SCTPL logic to precisely specify API usage rules in libraries, where SCTPL can be seen as an extension of the branching-time temporal logic CTL with variables, quantifiers, and predicates over the stack. This allows library providers to formally describe API usage rules without knowing how their libraries will be used by programmers. We also propose an approach to automatically check whether programs using libraries violate or not the corresponding API usage rules. Our approach consists in modeling programs as pushdown systems (PDSs), and checking API usage rules on programs using SCTPL model checking for PDSs. To make the model-checking procedure more efficient, we propose an abstraction that reduces drastically the size of the program model. Moreover, we characterize a sub-logic rSCTPL of SCTPL preserved by the abstraction. rSCTPL is sufficient to precisely specify all the API usage rules we met. We implemented our techniques in a tool and applied it to check several API usage rules. Our tool detected several previously unknown errors in well-known programs, such as Nssl, Verbs, Acacia+, Walksat and Getafix. Our experimental results are encouraging. © 2013 Springer-Verlag Berlin Heidelberg."
"Blom S., Kiniry J., Huisman M." $ "How do developers use APIs? A case study in concurrency" $ "With the omnipresent usage of APIs in software development, it has become important to analyse how the routines and functionalities of APIs are actually used. This information is in particular useful for API developers, to make decisions about future updates of the API. However, also for developers of static analysis and verification tools this information is highly important, because it indicates where and how to put the most efficient effort in annotating APIs, to make them usable for the static analysis and verification tools. This paper presents an analysis of the usage of the routines and functionalities of the Java concurrency library java. util. concurrent. It discusses the Histogram tool that we developed for this purpose, i.e., to efficiently analyse a large collection of bytecode classes. The Histogram tool is used on a representative benchmark set, the Qualitas Corpus. The paper discusses the results of the analysis of this benchmark set in detail. This covers both an analysis of the important classes and methods used by the current releases of the benchmark collection, as well as an analysis of the time it took for the Java concurrency library to start being used in released software. © 2013 IEEE."
"Linares-Vásquez M., Bavota G., Bernal-Cárdenas C., Di Penta M., Oliveto R., Poshyvanyk D." $ "API change and fault proneness: A threat to the success of android apps" $ "During the recent years, the market of mobile software applications (apps) has maintained an impressive upward trajectory. Many small and large software development companies invest considerable resources to target available opportunities. As of today, the markets for such devices feature over 850K+ apps for Android and 900K+ for iOS. Availability, cost, functionality, and usability are just some factors that determine the success or lack of success for a given app. Among the other factors, reliability is an important criteria: users easily get frustrated by repeated failures, crashes, and other bugs, hence, abandoning some apps in favor of others. This paper reports a study analyzing how the fault- and change-proneness of APIs used by 7, 097 (free) Android apps relates to applications' lack of success, estimated from user ratings. Results of this study provide important insights into a crucial issue: making heavy use of fault- and change-prone APIs can negatively impact the success of these apps. Copyright 2013 ACM."
"Khatoon S., Mahmood A., Li G., Xu J." $ "A novel integrated framework to increase software quality by mining source code" $ "Source code contain lot of structural features that embody latent information that if identified can help software engineers to develop quality software in least amount of time. For instance, many programming rules are hidden in set of function calls, variable usage, data accesses in functions, object interaction etc. that seldom exist outside the minds of developers. Violations of these rules may introduce bugs which are difficult to uncover, report to bug-tracking systems and fix unless the rules are explicitly documented and made available to the development team. In order to address this problem there is a need to apply strong analysis techniques on source code to find latent programming patterns that can be potentially useful for performing various software engineering tasks. This study demonstrates how data mining techniques can be applied on source code to improve software quality and productivity by proposing a framework. This new approach is able to find different programming patterns such as programming rules, variable correlation, code clones and frequent API usage patterns. Furthermore, efficient algorithms are proposed to automatically detect violation to the extracted rules. Proposed framework is validated by developing a prototype and evaluated on various projects of significant size and complexity. Results shows proposed technique greatly reduced time and cost of manually checking defects from source code by programmers. © 2013 Academic Journals Inc."
"Sangeetha R." $ "Detection of malicious code in user mode" $ "A particular type of executable malware code is malicious code that harms the computer or networks without the user intervention. Static analysis is used to identify the location of system calls from service request and monitor the executables at runtime, but difficult to determine the obfuscated code because code uses dynamic code generation and obfuscation techniques. This technique hides the win32 API calls at runtime. Malicious code can interact with operating system through Win32 API usage. Malicious executables can hide their win32 API usage during Static analysis. Our proposed approach is used to distinguish the software executables and analyze the virtual address and API names of instructions from system calls are recorded to match with the interrupt address table. The recorded instructions are found in Address table, the services are forwarded to kernel mode. Filter is mainly focus on separating the address belongs to its local id and remote id for validating the dispatch id in system service dispatch table. Through filter using the process creation algorithm to finalize it service request from legitimate user. The overall processing is done by user mode before the injected code entering into the kernel mode. © 2013 IEEE."
"Senseney J., Bokinsky A., Cheng R., McCreedy E., McAuliffe M.J." $ "Java multi-histogram volume rendering framework for medical images" $ "This work extends the multi-histogram volume rendering framework proposed by Kniss et al. [1] to provide rendering results based on the impression of overlaid triangles on a graph of image intensity versus gradient magnitude. The developed method of volume rendering allows for greater emphasis to boundary visualization while avoiding issues common in medical image acquisition. For example, partial voluming effects in computed tomography and intensity inhomogeneity of similar tissue types in magnetic resonance imaging introduce pixel values that will not reflect differing tissue types when a standard transfer function is applied to an intensity histogram. This new framework uses developing technology to improve upon the Kniss multi-histogram framework by using Java, the GPU, and MIPAV, an open-source medical image processing application, to allow multi-histogram techniques to be widely disseminated. The OpenGL view aligned texture rendering approach suffered from performance setbacks, inaccessibility, and usability problems. Rendering results can now be interactively compared with other rendering frameworks, surfaces can now be extracted for use in other programs, and file formats that are widely used in the field of biomedical imaging can be visualized using this multi-histogram approach. OpenCL and GLSL are used to produce this new multi-histogram approach, leveraging texture memory on the graphics processing unit of desktops to provide a new interactive method for visualizing biomedical images. Performance results for this method are generated and qualitative rendering results are compared. The resulting framework provides the opportunity for further applications in medical imaging, both in volume rendering and in generic image processing. © 2013 SPIE."
"Hofmeyr S., Colmenares J.A., Iancu C., Kubiatowicz J." $ "Juggle: Addressing extrinsic load imbalances in SPMD applications on multicore computers" $ "We investigate proactive dynamic load balancing on multicore systems, in which threads are continually migrated to reduce the impact of processor/thread mismatches. Our goal is to enhance the flexibility of the SPMD-style programming model and enable SPMD applications to run efficiently in multiprogrammed environments. We present Juggle, a practical decentralized, user-space implementation of a proactive load balancer that emphasizes portability and usability. In this paper we assume perfect intrinsic load balance and focus on extrinsic imbalances caused by OS noise, multiprogramming and mismatches of threads to hardware parallelism. Juggle shows performance improvements of up to 80 % over static load balancing for oversubscribed UPC, OpenMP, and pthreads benchmarks. We also show that Juggle is effective in unpredictable, multiprogrammed environments, with up to a 50 % performance improvement over the Linux load balancer and a 25 % reduction in performance variation. We analyze the impact of Juggle on parallel applications and derive lower bounds and approximations for thread completion times. We show that results from Juggle closely match theoretical predictions across a variety of architectures, including NUMA and hyper-threaded systems. © 2012 Springer Science + Business Media, LLC (outside the USA)."
"Robillard M.P., Bodden E., Kawrykow D., Mezini M., Ratchford T." $ "Automated API property inference techniques" $ "Frameworks and libraries offer reusable and customizable functionality through Application Programming Interfaces (APIs). Correctly using large and sophisticated APIs can represent a challenge due to hidden assumptions and requirements. Numerous approaches have been developed to infer properties of APIs, intended to guide their use by developers. With each approach come new definitions of API properties, new techniques for inferring these properties, and new ways to assess their correctness and usefulness. This paper provides a comprehensive survey of over a decade of research on automated property inference for APIs. Our survey provides a synthesis of this complex technical field along different dimensions of analysis: properties inferred, mining techniques, and empirical results. In particular, we derive a classification and organization of over 60 techniques into five different categories based on the type of API property inferred: unordered usage patterns, sequential usage patterns, behavioral specifications, migration mappings, and general information. © 1976-2012 IEEE."
"Othman A.T., Khan S., Nauman M., Musa S." $ "Towards a high-level trusted computing API for android software stack" $ "Smartphone platforms are fast becoming the de-facto method of online communication. Android is one of the most promising smartphone platforms with backing of both the finances of industry leaders and the technical skills and expertise of the open source community. These two factors combined with the usability of application design on the Android platform has propelled the platform in the fore-front of technological innovations. However, along with this wide acceptance by the community come large risks associated with privacy, security and trust. Users share very sensitive data of a very personal nature on their smartphones. Protection of this data is of immense importance if the adoption of smartphones is to be continued. Similar threats on the pc have been countered using the concepts of Trusted Computing - a highly flexible trust mechanism with strong security properties. The Android platform has yet to see any Trusted Computing applications primarily because of the difficulty in adopting the relatively new paradigm of security. In this paper, we present the design of a high-level api that allows existing Android developers to adopt Trusted Computing and use it in their applications without having to learn the intricate details of how Trusted Computing works. The api will help the developers to increase the security of their applications and the data that they consume. Copyright © 2013 ACM."
"Fischer J.E., Ramchurn S.D., Osborne M.A., Parson O., Huynh T.D., Alam M., Pantidi N., Moran S., Bachour K., Reece S., Costanza E., Rodden T., Jennings N.R." $ "Recommending energy tariffs and load shifting based on smart household usage profiling" $ "We present a system and study of personalized energy-related recommendation. AgentSwitch utilizes electricity usage data collected from users' households over a period of time to realize a range of smart energy-related recommendations on energy tariffs, load detection and usage shifting. The web service is driven by a third party real-time energy tariff API (uSwitch), an energy data store, a set of algorithms for usage prediction, and appliance-level load disaggregation. We present the system design and user evaluation consisting of interviews and interface walkthroughs. We recruited participants from a previous study during which three months of their household's energy use was recorded to evaluate personalized recommendations in AgentSwitch. Our contributions are a) a systems architecture for personalized energy services, and b) findings from the evaluation that reveal challenges in designing energy-related recommender systems. In response to the challenges we formulate design recommendations to mitigate barriers to switching tariffs, to incentivize load shifting, and to automate energy management. Copyright © 2013 ACM."
"Earls J.C., Eddy J.A., Funk C.C., Ko Y., Magis A.T., Price N.D." $ "AUREA: An open-source software system for accurate and user-friendly identification of relative expression molecular signatures" $ "Background: Public databases such as the NCBI Gene Expression Omnibus contain extensive and exponentially increasing amounts of high-throughput data that can be applied to molecular phenotype characterization. Collectively, these data can be analyzed for such purposes as disease diagnosis or phenotype classification. One family of algorithms that has proven useful for disease classification is based on relative expression analysis and includes the Top-Scoring Pair (TSP), k-Top-Scoring Pairs (k-TSP), Top-Scoring Triplet (TST) and Differential Rank Conservation (DIRAC) algorithms. These relative expression analysis algorithms hold significant advantages for identifying interpretable molecular signatures for disease classification, and have been implemented previously on a variety of computational platforms with varying degrees of usability. To increase the user-base and maximize the utility of these methods, we developed the program AUREA (Adaptive Unified Relative Expression Analyzer)-a cross-platform tool that has a consistent application programming interface (API), an easy-to-use graphical user interface (GUI), fast running times and automated parameter discovery.Results: Herein, we describe AUREA, an efficient, cohesive, and user-friendly open-source software system that comprises a suite of methods for relative expression analysis. AUREA incorporates existing methods, while extending their capabilities and bringing uniformity to their interfaces. We demonstrate that combining these algorithms and adaptively tuning parameters on the training sets makes these algorithms more consistent in their performance and demonstrate the effectiveness of our adaptive parameter tuner by comparing accuracy across diverse datasets.Conclusions: We have integrated several relative expression analysis algorithms and provided a unified interface for their implementation while making data acquisition, parameter fixing, data merging, and results analysis 'point-and-click' simple. The unified interface and the adaptive parameter tuning of AUREA provide an effective framework in which to investigate the massive amounts of publically available data by both 'in silico' and 'bench' scientists. AUREA can be found at http://price.systemsbiology.net/AUREA/. © 2013 Earls et al, licensee BioMed Central Ltd."
"[No author name available]" $ "IEEE 13th International Working Conference on Source Code Analysis and Manipulation, SCAM 2013" $ "The proceedings contain 24 papers. The topics discussed include: empirical investigation of SEA-based dependence cluster properties, characterization and assessment of the Linux configuration complexity, criticality of defects in cyclic dependent components, code clustering workbench, empirical evidence of large-scale diversity in API usage of object-oriented software, aspectual source code analysis with GASR, driving a sound static software analyzer with branch-and-bound, PtrTracker: pragmatic pointer analysis, tracing with minimal number of probes, a state alteration and inspection-based interactive debugger, Proteum/FL: a mutation-based fault localization Tool, Gecos: an extensible source-to-source compiler for embedded hardware, review efforts reduction by partitioning of static analysis warnings, determining coupling in JavaScript using object type inference, MetricMiner: supporting researchers in mining software repositories, and fix-it: an extensible code auto-fix component in review Bot."
"Lord P." $ "The Semantic Web takes wing: Programming ontologies with Tawny-OWL" $ "The Tawny-OWL library provides a fully-programmatic environment for ontology building, it enables the use of a rich set of tools for ontology development by recasting development as a form of programming. It is built in Clojure - a modern Lisp dialect, and is backed by the OWL API. Used simply, it has a similar syntax to OWL Manchester syntax, but it provides arbitrary extensibility and abstraction. It builds on existing facilities for Clojure, which provides a rich and modern programming tool chain, for versioning, distributed development, build, testing and continuous integration. In this paper, we describe the library, this environment and the its potential implications for the ontology development process."
"Lawall J.L., Brunel J., Palix N., Hansen R.R., Stuart H., Muller G." $ "WYSIWIB: Exploiting fine-grained program structure in a scriptable API-usage protocol-finding process" $ "Bug-finding tools rely on specifications of what is correct or incorrect code. As it is difficult for a tool developer or user to anticipate all possible specifications, strategies for inferring specifications have been proposed. These strategies obtain probable specifications by observing common characteristics of code or execution traces, typically focusing on sequences of function calls. To counter the observed high rate of false positives, heuristics have been proposed for ranking or pruning the results. These heuristics, however, can result in false negatives, especially for rarely used functions. In this paper, we propose an alternate approach to specification inference, in which the user guides the inference process using patterns of code that reflect the user's understanding of the conventions and design of the targeted software project. We focus on specifications describing the correct usage of API functions, which we refer to as API protocols. Our approach builds on the Coccinelle program matching and transformation tool, which allows a user to construct patterns that reflect the structure of the code to be matched. We evaluate our approach on the source code of the Linux kernel, which defines a very large number of API functions with varying properties. Linux is also critical software, implying that fixing even bugs involving rarely used protocols is essential. In our experiments, we use our approach to find over 3000 potential API protocols, with an estimated false positive rate of under 15% and use these protocols to find over 360 bugs in the use of API functions. © 2012 John Wiley & Sons, Ltd."
"Hoxha J., Maleshkova M., Korevaar P." $ "Knowledge discovery meets linked APIs" $ "Knowledge Discovery and Data Mining (KDD) is a very wellestablished research field with useful techniques that explore patterns and regularities in large relational, structured and unstructured datasets. Theoretical and practical development in this field have led to useful and scalable solutions for the tasks of pattern mining, clustering, graph mining, and predictions. In this paper, we demonstrate that these approaches represent great potential to solve a series of problems and make further optimizations in the setting of Web APIs, which have been significantly increasing recently. In particular, approaches integrating Web APIs and Linked Data, also referred to as Linked APIs, provide novel opportunities for the application of synergy approaches with KDD methods. We give insights on several aspects that can be covered through such synergy approach, then focus, specifically, on the problem of API usage mining via statistical relational learning.We propose a Hidden Relational Model, which explores the usage of Web APIs to enable analysis and prediction. The benefit of such model lies on its ability to capture the relational structure of API requests. This approach might help not only to gain insights about the usage of the APIs, but most importantly to make active predictions on which APIs to link together for creating useful mashups, or facilitating API composition. Copyright © 2013 for the individual papers by the papers' authors."
"Störrle H." $ "Improving the usability of OCL as an ad-hoc model querying language" $ "The OCL is often perceived as di-cult to learn and use. In previous research, we have defined experimental query languages exhibiting higher levels of usability than OCL. However, none of these alternatives can rival OCL in terms of adoption and support. In an attempt to leverage the lessons learned from our research and make it accessible to the OCL community, we propose the OCL Query API (OQAPI), a library of query-predicates to improve the user-friendliness of OCL for ad-hoc querying. The usability of OQAPI is studied using controlled experiments. We find considerable evidence to support our claim that OQAPI facilitates user querying using OCL."
"Cao Y., Hua Y., Zhao J., Guo S." $ "Design and implementation of surrounding transaction plotting and management system based on Google map API" $ "With China's rapid economic development and comprehensive national strength growing, Border work has become a long-term and important task in China's diplomatic work. How to implement rapid plotting, real-time sharing and mapping surrounding affairs has taken great significance for government policy makers and diplomatic staff. However, at present the already exists Boundary information system are mainly have problems of Geospatial data update is heavily workload, plotting tools are in a state of serious lack of, Geographic events are difficult to share, this phenomenon has seriously hampered the smooth development of the border task. The development and progress of Geographic information system technology especially the development of Web GIS offers the possibility to solve the above problems, this paper adopts four layers of B/S architecture, with the support of Google maps service, uses the free API which is offered by Google maps and its features of openness, ease of use, sharing characteristics, highresolution images to design and implement the surrounding transaction plotting and management system based on the web development technology of ASP.NET, C#, Ajax. The system can provide decision support for government policy makers as well as diplomatic staff's real-time plotting and sharing of surrounding information. The practice has proved that the system has good usability and strong real-time."
"Munir M.B., Mushtaq A." $ "A framework for extending usability engineering: API usability essentials: Extending usability via component-based platform" $ "Application Programming Interface (API) in software development acts as an important milestone for software productions. It is believed that API usability impacts upon ease-in-use, operationability and acceptability among its audience. Likewise, an ever increasing need for extending and integrating Usability Engineering (UE) has become vital for the success of software products. Earlier researches within this domain do not address API's usability via a component-based framework approach. The proposed framework emphasizes on consolidated formulation of various usability and quality models to derive chunks of dimensional variables. Further the paper highlights API usability practices and heuristics applied in API development process and discusses API product's artifacts component to be used in deriving further product-related components to support enhancing usability. © 2012 IEEE."
"Thung F., Lo D., Jiang L." $ "Detecting similar applications with collaborative tagging" $ "Detecting similar applications are useful for various purposes ranging from program comprehension, rapid prototyping, plagiarism detection, and many more. McMillan et al. have proposed a solution to detect similar applications based on common Java API usage patterns. Recently, collaborative tagging has impacted software development practices. Various sites allow users to give various tags to software systems. In this study, we would like to complement the study by McMillan et al. by leveraging another source of information aside from API usage patterns, namely software tags. We have performed a user study involving several participants and the results show that collaborative tagging is a promising source of information useful for detecting similar software applications. © 2012 IEEE."
"Tapia B., Torres R., Astudillo H., Ortega P." $ "Recommending APIs for mashup completion using association rules mined from real usage data" $ "Mashups are becoming the de facto approach to build customer-oriented Web applications, by combining several Web APIs into a single lightweight, rich, customized Web front-end. To help mashup builders to choose among a plethora of available APIs to assemble in their mashups, some existing recommendation techniques rank candidate APIs using popularity (a social measure) or keyword-based measures (whether semantic or unverified tags). This article proposes to use information on co-usage of APIs in previous mash ups to suggest likely candidate APIs, and introduces a global measure which improves on earlier local co-API measures. The gCAR (global Co-utilization API Ranking) is calculated using association rules inferred from historical API usage data. The MashupRECO tool combines gCAR and a keywordbased measure, to avoid the 'cold-start' problem for new or unused APIs. Evaluation of MashupRECO versus the keyword search of the well-known ProgrammableWeb catalog show that the tool reduces the search time for comparable degree of completeness. © 2011 IEEE."
"Groce A., Fern A., Pinto J., Bauer T., Alipour A., Erwig M., Lopez C." $ "Lightweight automated testing with adaptation-based programming" $ "This paper considers the problem of testing a container class or other modestly-complex API-based software system. Past experimental evaluations have shown that for many such modules, random testing and shape abstraction based model checking are effective. These approaches have proven attractive due to a combination of minimal requirements for tool/language support, extremely high usability, and low overhead. These ""lightweight"" methods are therefore available for almost any programming language or environment, in contrast to model checkers and concolic testers. Unfortunately, for the cases where random testing and shape abstraction perform poorly, there have been few alternatives available with such wide applicability. This paper presents a generalizable approach based on reinforcement learning (RL), using adaptation-based programming (ABP) as an interface to make RL-based testing (almost) as easy to apply and adaptable to new languages and environments as random testing. We show how learned tests differ from random ones, and propose a model for why RL works in this unusual (by RL standards) setting, in the context of a detailed large-scale experimental evaluation of lightweight automated testing methods. © 2012 IEEE."
"Jacob F., Gray J., Carver J.C., Mernik M., Bangalore P." $ "PPModel: A modeling tool for source code maintenance and optimization of parallel programs" $ "As the computation power in desktops advances, parallel programming has emerged as one of the essential skills needed by next generation software engineers. However, programs written in popular parallel programming paradigms have a substantial amount of sequential code mixed with the parallel code. Several such versions supporting different platforms are necessary to find the optimum version of the program for the available resources and problem size. As revealed by our study on benchmark programs, sequential code is often duplicated in these versions. This can affect code comprehensibility and re-usability of the software. In this paper, we discuss a framework named PPModel, which is designed and implemented to free programmers from these scenarios. Using PPModel, a programmer can separate parallel blocks in a program, map these blocks to various platforms, and re-execute the entire program.We provide a graphical modeling tool (PPModel) intended for Eclipse users and a Domain-Specific Language (tPPModel) for non-Eclipse users to facilitate the separation, the mapping, and the re-execution. This is illustrated with a case study from a benchmark program, which involves re-targeting a parallel block to CUDA and another parallel block to OpenMP. The modified program gave almost 5× performance gain compared to the sequential counterpart, and 1.5× gain compared to the existing OpenMP version. © Springer Science+Business Media, LLC 2012."
"Ghosh S., Liao T., Calandra H., Chapman B.M." $ "Experiences with OpenMP, PGI, HMPP and OpenACC directives on ISO/TTI kernels" $ "GPUs are slowly becoming ubiquitous devices in High Performance Computing, as their capabilities to enhance the performance per watt of compute intensive algorithms as compared to multicore CPUs have been identified. The primary shortcoming of a GPU is usability, since vendor specific APIs are quite different from existing programming languages, and it requires a substantial knowledge of the device and programming interface to optimize applications. Hence, lately a growing num- ber of higher level programming models are targeting GPUs to alleviate this problem. The ultimate goal for a high-level model is to expose an easy-to-use interface for the user to offload compute intensive portions of code (kernels) to the GPU, and tune the code according to the target accelerator to maximize overall performance with a reduced development effort. In this paper, we share our experiences of three of the notable high-level directive based GPU programming models - PGI, CAPS and OpenACC (from CAPS and PGI) on an Nvidia M2090 GPU. We analyze their performance and programmability against Isotropic (ISO)/Tilted Transversely Isotropic (TTI) finite differ- ence kernels, which are primary components in the Reverse Time Migration (RTM) application used by oil and gas exploration for seismic imaging of the sub-surface. When ported to a single GPU using the mentioned directives, we observe an average 1.5-1.8x improvement in performance for both ISO and TTI kernels, when compared with optimized multi-threaded CPU implementations using OpenMP. © 2012 IEEE."
"Spycher N., Portmann E." $ "Customized mashups for improved reputation visualization" $ "This document describes a possible use for the YouReputation API. A mashup combining the YouReputation and the Flickr APIs attempts to improve the visualization of reputation. First, this paper gives an introduction to Web services and APIs and further explains the developed prototype. This paper introduces an API that can be easily combined with other APIs to improve the representation of reputation terms and therefore enhance usability and design. © 2012 IEEE."
"Zeidler C., Müller J., Lutteroth C., Weber G." $ "Comparing the usability of grid-bag and constraint-based layouts" $ "While the usability of GUI design methods has been studied in general, the usability of layout specification methods is largely unexplored. In this paper we provide an empirical comparison of two popular GUI layout models, grid-bag layout and constraint-based layout. While the grid-bag layout is a powerful layout model, the constraint-based layout is able to generate even more general and flexible layout configurations. We performed a controlled experiment with postgraduate students of Computer Science and Software Engineering, measuring efficiency, accuracy and preference for typical layout specification and editing tasks. The results show significant differences between both layout models: the initial specification of GUIs is faster with a grid-bag layout whereas editing of existing complex layouts is faster and more accurate with a constraint-based layout. The study shows that constraint-based layout, although it may seem more complicated at first glance, can compete with and in some cases even outperform more conventional techniques in terms of their usability. © 2012 ACM."
"Mishne A., Shoham S., Yahav E." $ "Typestate-based semantic code search over partial programs" $ "We present a novel code search approach for answering queries focused on API-usage with code showing how the API should be used. To construct a search index, we develop new techniques for statically mining and consolidating temporal API specifications from code snippets. In contrast to existing semanticbased techniques, our approach handles partial programs in the form of code snippets. Handling snippets allows us to consume code from various sources such as parts of open source projects, educational resources (e.g. tutorials), and expert code sites. To handle code snippets, our approach (i) extracts a possibly partial temporal specification from each snippet using a relatively precise static analysis tracking a generalized notion of typestate, and (ii) consolidates the partial temporal specifications, combining consistent partial information to yield consolidated temporal specifications, each of which captures a full(er) usage scenario. To answer a search query, we define a notion of relaxed inclusion matching a query against temporal specifications and their corresponding code snippets. We have implemented our approach in a tool called PRIME and applied it to search for API usage of several challenging APIs. PRIME was able to analyze and consolidate thousands of snippets per tested API, and our results indicate that the combination of a relatively precise analysis and consolidation allowed PRIME to answer challenging queries effectively."
"Mayer C., Hanenberg S., Robbes R., Tanter É., Stefik A." $ "An empirical study of the influence of static type systems on the usability of undocumented software" $ "Although the study of static and dynamic type systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems in languages such as Java or C++ is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease flexibility, which may make them harder to use. While these arguments are found in the literature, rigorous empirical evidence is lacking. We report on a controlled experiment where 27 subjects performed programming tasks on an undocumented API with a static type system (requiring type annotations) as well as a dynamic type system (which does not). Our results show that for some tasks, programmers had faster completion times using a static type system, while for others, the opposite held. We conduct an exploratory study to try and theorize why."
"Lee M., Jo H., Choi D.H." $ "Towards high performance and usability programming model for heterogeneous HPC platforms" $ "Latest High Performance Computing (HPC) platforms are built with heterogeneous chips such as multicore microprocessors and multicore GPUs (Graphic Processing units), thus they are commonly called as Heterogeneous High Performance Computing (HPC) platforms. Various programming models have been developed and proposed for heterogeneous platforms. However, their wide adoption in the user community is predicted to be limited, because of low performance, low usability due to revealing architectural details in the program which burdens the programmers, and most importantly the limited SIMD execution model which relies on the GPU for most of the computations in the program which can limit the performance. Thus a more general programming model beyond SIMD which is easy to use and leads to high performance needs to be developed. In this paper, we propose methods to achieve this goal by considering all types of parallelism according to Flynn's classification (SIMD, MIMD, MISD). Our proposed methods incorporate these parallelisms in the existing high usability programming models and can lead to significant performance improvements. © 2012 AICIT."
"Farhadi-Niaki F., GhasemAghaei R., Arya A." $ "Empirical study of a vision-based depth-sensitive human-computer interaction system" $ "This paper proposes the results of a user study on vision-based depth-sensitive input system for performing typical desktop tasks through arm gestures. We have developed a vision-based HCI prototype to be used for our comprehensive usability study. Using the Kinect 3D camera and OpenNI software library we implemented our system with high stability and efficiency by decreasing the ambient disturbing factors such as noise or light condition dependency. In our prototype, we designed a capable algorithm using NITE toolkit to recognize arm gestures. Finally, through a comprehensive user experiment we compared our natural arm gestures to the conventional input devices (mouse/keyboard), for simple and complicated tasks, and in two different situations (small and big-screen displays) for precision, efficiency, ease-of-use, pleasantness, fatigue, naturalness, and overall satisfaction to verify the following hypothesis: on a WIMP user interface, the gesture-based input is superior to mouse/keyboard when using big-screen. Our empirical investigation also proves that gestures are more natural and pleasant to be used than mouse/keyboard. However, arm gestures can cause more fatigue than mouse. Copyright 2012 ACM."
"Lee M., Jo H., Choi D.H." $ "Towards high performance and usability programming methodology for heterogeneous HPC architectures" $ "Various programming models have been developed and proposed for the latest heterogeneous High Performance Computing (HPC) platforms built using heterogeneous chips such as multicore microprocessors and multicore GPUs (Graphic Processing units). However, their wide adoption in the user community is predicted to be limited, because of low performance, low usability due to revealing architectural details in the program which burdens the programmers, and most importantly the limited SIMD execution model using the GPU as the main computation engine which can limit the performance in non-SIMD friendly applications. A more general programming methodology which is easy to use and leads to high performance by incorporating parallelism beyond SIMD needs to be developed. In this paper, we propose methods to achieve this goal in two ways. First, we leverage existing highly usable parallel programming models such as OpenMP and OpenACC which is recently released to become a new standard API for accelerator programming including GPUs. Second, we consider parallelism other than SIMD (MIMD, MISD) in the heterogeneous parallel program to further the performance beyond what users can currently achieve using existing proprietary APIs such as CUDA. Our proposed methodolody can thus lead to high usability and high performance for programs parallelized on heterogeneous HPC platforms."
"Mayer C., Hanenberg S., Robbes R., Tanter E., Stefik A." $ "An empirical study of the influence of static type systems on the usability of undocumented software" $ "Although the study of static and dynamic type systems plays a major role in research, relatively little is known about the impact of type systems on software development. Perhaps one of the more common arguments for static type systems in languages such as Java or C++ is that they require developers to annotate their code with type names, which is thus claimed to improve the documentation of software. In contrast, one common argument against static type systems is that they decrease flexibility, which may make them harder to use. While these arguments are found in the literature, rigorous empirical evidence is lacking. We report on a controlled experiment where 27 subjects performed programming tasks on an undocumented API with a static type system (requiring type annotations) as well as a dynamic type system (which does not). Our results show that for some tasks, programmers had faster completion times using a static type system, while for others, the opposite held. We conduct an exploratory study to try and theorize why. Copyright © 2012 ACM."
"Rupakheti C.R., Hou D." $ "CriticAL: A critic for APIs and libraries" $ "It is well-known that APIs can be hard to learn and use. Although search tools can help find related code examples, API novices still face other significant challenges such as evaluating the relevance of the search results. To help address the broad problems of finding, understanding, and debugging API-based solutions, we have built a critic system that offers recommendations, explanations, and criticisms for API client code. Our critic takes API usage rules as input, performs symbolic execution to check that the client code has followed these rules properly, and generates advice as output to help improve the client code. We demonstrate our critic by applying it to a real-world example derived from the Java Swing Forum. © 2012 IEEE."
"Andersch M., Chi C.C., Juurlink B." $ "Programming parallel embedded and consumer applications in OpenMP superscalar" $ "In this paper, we evaluate the performance and usability of the parallel programming model OpenMP Superscalar (OmpSs), apply it to 10 different benchmarks and compare its performance with corresponding POSIX threads implementations. Copyright © 2012 ACM."
"Nguyen A.T., Nguyen H.A., Nguyen T.T., Nguyen T.N." $ "GraPacc: A graph-based pattern-oriented, context-sensitive code completion tool" $ "Code completion tool plays an important role in daily development activities. It helps developers by auto-completing tedious and detailed code during an editing session. However, existing code completion tools are limited to recommending only context-free code templates and a single method call of the variable under editing. We introduce GraPacc, an advanced, context-sensitive code completion tool that is based on frequent API usage patterns. It extracts the context-sensitive features from the code under editing, for example, the API elements on focus and the current editing point, and their relations to other code elements. It then ranks the relevant API usage patterns and auto-completes the current code with the proper elements according to the chosen pattern. © 2012 IEEE."
"Zhang C., Yang J., Zhang Y., Fan J., Zhang X., Zhao J., Ou P." $ "Automatic parameter recommendation for practical API usage" $ "Programmers extensively use application programming interfaces (APIs) to leverage existing libraries and frameworks. However, correctly and efficiently choosing and using APIs from unfamiliar libraries and frameworks is still a non-trivial task. Programmers often need to ruminate on API documentations (that are often incomplete) or inspect code examples (that are often absent) to learn API usage patterns. Recently, various techniques have been proposed to alleviate this problem by creating API summarizations, mining code examples, or showing common API call sequences. However, few techniques focus on recommending API parameters. In this paper, we propose an automated technique, called Precise, to address this problem. Differing from common code completion systems, Precise mines existing code bases, uses an abstract usage instance representation for each API usage example, and then builds a parameter usage database. Upon a request, Precise queries the database for abstract usage instances in similar contexts and generates parameter candidates by concretizing the instances adaptively. The experimental results show that our technique is more general and applicable than existing code completion systems, specially, 64% of the parameter recommendations are useful and 53% of the recommendations are exactly the same as the actual parameters needed. We have also performed a user study to show our technique is useful in practice. © 2012 IEEE."
"Cuibus M., Potolea R." $ "Adaptable swarm intelligence framework" $ "Modern software systems must be continuously adapted to current performance and usability requirements. Indicators like overhead, computational complexity, parameter tuning, or ease of design and implementation are getting increasingly harder to accomplish due to constant increase in system dimensions like code size, API (Application Programming Interface), deployment size, component communication, network lag etc. Furthermore, many entities rely on classic, highly deterministic algorithms that are little or not capable of changing strategies on the fly. Lately, bio-inspired algorithms have successfully tackled this problem with significant, positive results. We propose a framework that may prove useful in obtaining better performance by automatically selecting and combining the best swarm intelligence algorithms with the best parameter selection. Copyright 2012 ACM."
"Schreckling D., Posegga J., Hausknecht D." $ "Constroid: Data-centric access control for android" $ "We introduce Constroid, a data-centric security policy management framework for Android. It defines a new middleware which allows the developer to specify well defined data items of fine granularity. For these data items, Constroid administrates security policies which are based on the usage control model. They can only be modified by the user of an application not by the applications itself. We use Con-stroid's middle-ware to protect the security policies, ensure consistency between a data item and its corresponding security policy, and describe how our prototype implementation can enforce a subset of possible usage control policies. In this way, our contribution shows how we overcome the rigid API-driven approach to security in Android. The structure and implementation of our framework is presented and discussed in terms of security, performance, and usability. © 2012 ACM."
"Jin H., Kellogg M., Mehrotra P." $ "Using compiler directives for accelerating CFD applications on GPUs" $ "As the current trend of parallel systems is towards a cluster of multi-core nodes enhanced with accelerators, software development for such systems has become a major challenge. Both low-level and high-level programming models have been developed to address complex hierarchical structures at different hardware levels and to ease the programming effort. However, achieving the desired performance goal is still not a simple task. In this study, we describe our experience with using the accelerator directives developed by the Portland Group to port a computational fluid dynamics (CFD) application benchmark to a general-purpose GPU platform. Our work focuses on the usability of this approach and examines the programming effort and achieved performance on two Nvidia GPU-based systems. The study shows very promising results in terms of programmability as well as performance when compared to other approaches such as the CUDA programming model. © 2012 Springer-Verlag."
"Gruetz R., Focke N.K., Hoheisel A., Krefting D., Loehnhardt B., Viezens F., Dickmann F." $ "Enabling parallel computing of a brain connectivity map using the MediGRID-infrastructure and FSL" $ "The non-invasive method to track fibers of the human brain by analyzing diffusion weighted magnetic resonance images improves research of human brain structures and becomes therefore increasingly important. With fiber tracking, a connectivity map which depicts the degree of connectivity of the single voxels can be generated and used to improve knowledge about the human brain. Several tools exist to produce connectivity maps. One of them is part of the FMRIB Software Library (FSL) and free for non-commercial purposes. Due to long and therefore impracticable computing time on small computer cluster solutions, a GUI and the necessary software were implemented for the German MediGRID infrastructure. This was achieved by using wrapper scripts and a workflow for the Generic Workflow Execution Service (GWES). The solution is about 15 times faster than a small local cluster installation, depending on the number of employed MediGRID resources. This enables processing of connectivity maps for practical use in biomedical research. By using the D-Grid infrastructure, this solution is also suitable for small institutes without compute center capacities. For usability reasons, the GUI ConBrain was developed. © 2012 IEEE."
"Scheller T., Kuhn E." $ "Influencing factors on the usability of API classes and methods" $ "Usability is an important quality attribute for APIs. To create APIs with good usability, appropriate measurement methods are needed. But currently available methods are cost- and time-expensive and the results are not objective and therefore hard to quantify. API design guidelines give a good overview about important usability factors, but lack a scientific basis. When looking at scientific API usability studies, only a very small area of API design has been researched yet. Existing results don't give enough basis for a good API usability measurement method. In this paper we identify influencing usability factors for the two most common concepts of APIs: classes and methods. We therefore conduct a study with 20 programmers and 2 different API variants and evaluate how differences between the APIs influence usability when instantiating classes and calling methods. The results build a basis for API usability measurement methods and should help design more usable APIs. © 2012 IEEE."
"Bauer V., Heinemann L." $ "Understanding API usage to support informed decision making in software maintenance" $ "Reuse of third-party libraries promises significant productivity improvements in software development. However, dependencies on external libraries and their APIs also introduce risks to a project and impact strategic decisions during development and maintenance. Informed decision making therefore requires a thorough understanding of the extent and nature of dependencies on external APIs. As realistically sized applications are often heavily entangled with various external APIs, gaining this understanding is infeasible with manual inspections only. To address this, we present an automated approach to analyze the dependencies of software projects on external APIs. The approach is supported by a static analysis tool featuring a visualization of the analysis results. We evaluate the approach as well as the tooling on multiple open source Java systems. © 2012 IEEE."
"Edwards H.C., Sunderland D." $ "Kokkos Array performance-portable manycore programming model" $ "Large, complex scientific and engineering application code have a significant investment in computational kernels which implement their mathematical models. Porting these computational kernels to multicore-CPU and manycore-accelerator (e.g., NVIDIA® GPU) devices is a major challenge given the diverse programming models, application programming interfaces (APIs), and performance requirements. The Kokkos Array programming model provides library-based approach for implementing computational kernels that are performance-portable to multicore-CPU and manycore-accelerator devices. This programming model is based upon three fundamental concepts: (1) manycore compute devices each with its own memory space, (2) data parallel computational kernels, and (3) multidimensional arrays. Performance-portability is achieved by decoupling computational kernels from device-specific data access performance requirements (e.g., NVIDIA coalesced memory access) through an intuitive multidimensional array API. The Kokkos Array API uses C++ template meta-programming to, at compile time, transparently insert device-optimal data access maps into computational kernels. With this programming model computational kernels can be written once and, without modification, performance-portably compiled to multicore-CPU and manycore-accelerator devices. © 2012 ACM."
"Andersch M., Chi C.C., Juurlink B." $ "Programming parallel embedded and consumer applications in openmp superscalar" $ "In this paper, we evaluate the performance and usability of the parallel programming model OpenMP Superscalar (OMPSS), apply it to 10 different benchmarks and compare its performance with corresponding POSIX threads implementations."
"[No author name available]" $ "4th International Conference on Human-Centered Software Engineering, HCSE 2016" $ "The proceedings contain 28 papers. The special focus in this conference is on Human-Centered Software Engineering. The topics include: Human factors engineering as the methodological Babel fish, translating user needs into software design, improving software effort estimation using an expert-centred approach, a compositional model for gesture definition, a development process for usable large scale interactive critical systems, agile user experience development in a large software organization, Smartphone applications usability evaluation, methods towards API usability, a structural analysis of usability problem categories, requirements sensemaking using concept maps, towards conflict management in user interface composition driven by business needs, a model for assessing organizational learning in software development organizations, a personality based design approach using subgroup discovery, assessing use complexity of software, support for the application of creativity techniques in requirements engineering, exploring local cultural perspectives in user interface development in an Indian offshoring context, improving support for visual task modelling, lessons learned from evaluating the usability of mobile spreadsheet applications, ProtoTask, new task model simulator, the usage of usability techniques in scrum projects, visualizing sensor data and graphical controls based environment for user interface evaluation."
"Wang L., Zou Y., Fang L., Xie B., Yang F." $ "An exploratory study of API usage examples on the web" $ "Usage examples are helpful for programmers learning to use APIs from third-party frameworks or libraries. There are lots of usage examples scattered in web pages on the Web, such as tutorials, blogs, and forums. A few researches have proposed approaches to leveraging these usage examples to improve programming. However, due to the lack of comprehensive understanding on the current situation of usage examples on the web, the work is still at the very beginning. Many concerns are reserved, for instance, how many usage examples can be found on the Web? how well do such examples support programmers on earth? what factors have impact on these examples' usability? In this paper, we conducted an exploratory study of usage examples on the web, including their distribution, characteristics like content style, correctness, and complexity, as well as their correlations. Through the study, we obtain some insight of how to facilitate utilization of usage examples on the web and what mechanisms could be provided. Possible research directions and problems are proposed at the end. © 2012 IEEE."
"Cortez R., Vazhenin A., Brine J." $ "Wikipedia miner engine: A re-usable e-learning service based on a virtual MVC design pattern" $ "E-Learning platforms are evolving from monolithic applications with a rigid structure that did not allowed for the exchange of tools or components to applications incorporating service orientation concepts as well as facilitating the dynamic discovery and assembling of e-learning services. Accordingly, the usage of support materials to provide additional guidance to students facilitates the comprehension of learning tasks. Wikipedia is one of the richest sources of human knowledge, encompassing a vast range of topics of all kinds of information, and content, which is in constant change due to its collaborative dynamic nature. The Wikipedia Miner provides a code that can parse a given document identifying main topics and link them to corresponding articles or short definitions from the Wikipedia content. In this paper, we discuss the realization of a reusable Wikipedia Miner service for the e-Learning Computational Cloud (eLC2) Platform designed with the J2EE technology and Service-Oriented (V-MVC) model excluding a direct link between the Model and the View. This allows enhancing the Controller as a middleware, removing the dependency and acting as a single point of contact. In the V-MVC design pattern, the Controller is modeled by the compound design pattern of the Enterprise Service Bus (ESB) supporting higher privacy of the business logic and higher re-usability Architecture standards. The eLC2 is also based on an original Virtual Model-View-Controller of application components. In this framework, Wikipedia Miner services were prototyped as an Application Engine that wraps the logic of the Wikipedia Miner API in order to re-use it for different types of applications. Particularly, we are focusing on two applications in order to demonstrate the usability of the proposed approach. The first application is the WikiGloss tool, which is based on a glossing approach to help learners of English-as-second-language with an extensive reading task. The second application is an Intelligent Hints service for a Task Management Environment which provides explanatory links from relevant Wikipedia articles related to topics of the e-Learning task. This allows re-use of the same problems in different task type modes such as lectures, exercises, and quizzes. © 2012 The authors and IOS Press. All rights reserved."
"De Luca V., Epicoco I., Lezzi D., Aloisio G." $ "GRB-WAPI, a RESTful framework for grid portals" $ "Nowadays grid portals are characterized by various and different features and are implemented in very differing programming languages and technologies, still having many structural aspects in common. This paper describes a RESTful Web API, named GRB-WAPI, specifically developed for grid computing that encapsulates all grid control and computation logic need to build a grid portal. Through the adoption of this API a portal developer does not have to deal with grid technical details focusing just on the high level design of her system and on some other aspects that concern presentation, such as portal usability and functionality. The idea of developing a traditional library has been discarded in order to free portal developers from a particular implementation technology. Thanks to this choice the portal presentation logic can be implemented in any web technology and can be deployed on a different server. Traditional Web Services and SOAP protocol approach has been discarded in order to adopt a RESTful approach to make the Web APIs lighter and also to take advantage of some other aspects illustrated in the paper. © 2012 Published by Elsevier Ltd."
"Khatoon S., Li G., Ashfaq R.M." $ "A Framework for automatically mining source code" $ "Mining source code by using different data mining techniques to extract the informative patterns like programming rules, variable correlation, code clones and frequent API usage is an active area of research. However, no practical framework for integrating these tasks has been attempted. To achieve this objective an integrated framework is designed that can detect different types of bugs to achieve software quality and assist developer in reusing API libraries for rapid software development. Proposed framework automatically extracts large variety of programming patterns and finds the locations where the extracted patterns are violated. Violated patterns are reported as programming rule violation, copy paste code related bugs and inconsistent variable update bugs. Although, the bugs are different but the framework can detect these bugs in one pass and produces higher quality software systems within budget. The framework also helps in code reusing by suggesting the programmer how to write API code to facilitate rapid software development. Proposed framework is validated by developing a prototype that developed in C# (MS Visual Studio, 2008) and evaluated on large application like ERP. Results shows proposed technique greatly reduced time and cost of manually checking defects from source code by programmers. © 2011 Academic Journals Inc."
"Zibran M.F., Eishita F.Z., Roy C.K." $ "Useful, but usable? Factors affecting the usability of APIs" $ "Software development today has been largely dependent on the use of API libraries, frameworks, and reusable components. However, the API usability issues often increase the development cost (e.g., time, effort) and lower code quality. In this regard, we study 1,513 bug-posts across five different bug repositories, using both qualitative and quantitative analysis. We identify the API usability issues that are reflected in the bug-posts from the API users, and distinguish relative significance of the usability factors. Moreover, from the lessons learned by manual investigation of the bug-posts, we provide further insight into the most frequent API usability issues. © 2011 IEEE."
"Ko A.J., Riche Y." $ "The role of conceptual knowledge in API usability" $ "While many studies have investigated the challenges that developers face in finding and using API documentation, few have considered the role of developers' conceptual knowledge in these tasks. We designed a study in which developers were asked to explore the feasibility of two requirements concerning networking protocols and application platforms that most participants were unfamiliar with, observing the effect that a lack of conceptual knowledge had on their use of documentation. Our results show that without conceptual knowledge, developers struggled to formulate effective queries and to evaluate the relevance or meaning of content they found. Our results suggest that API documentation should not only include detailed examples of API use, but also thorough introductions to the concepts, standards, and ideas manifested in an API's data structures and functionality. © 2011 IEEE."
"Uddin G., Dagenais B., Robillard M.P." $ "Analyzing temporal API usage patterns" $ "Software reuse through Application Programming Interfaces (APIs) is an integral part of software development. As developers write client programs, their understanding and usage of APIs change over time. Can we learn from long-term changes in how developers work with APIs in the lifetime of a client program? We propose Temporal API Usage Mining to detect significant changes in API usage. We describe a framework to extract detailed models representing addition and removal of calls to API methods over the change history of a client program. We apply machine learning technique to these models to semi-automatically infer temporal API usage patterns, i.e., coherent addition of API calls at different phases in the life-cycle of the client program. © 2011 IEEE."
"Zhong H., Zhang L., Xie T., Mei H." $ "Inferring specifications for resources from natural language API documentation" $ "Many software libraries, especially those commercial ones, provide API documentation in natural languages to describe correct API usages. However, developers may still write code that is inconsistent with API documentation, partially because many developers are reluctant to carefully read API documentation as shown by existing research. As these inconsistencies may indicate defects, researchers have proposed various detection approaches, and these approaches need many known specifications. As it is tedious to write specifications manually for all APIs, various approaches have been proposed to mine specifications automatically. In the literature, most existing mining approaches rely on analyzing client code, so these mining approaches would fail to mine specifications when client code is not sufficient. Instead of analyzing client code, we propose an approach, called Doc2Spec, that infers resource specifications from API documentation in natural languages. We evaluated our approach on the Javadocs of five libraries. The results show that our approach performs well on real scale libraries, and infers various specifications with relatively high precisions, recalls, and F-scores. We further used inferred specifications to detect defects in open source projects. The results show that specifications inferred by Doc2Spec are useful to detect real defects in existing projects. © Springer Science+Business Media, LLC 2011."
"Wang L., Fang L., Wang L., Li G., Xie B., Yang F." $ "APIExample: An effective web search based usage example recommendation system for java APIs" $ "Programmers often learn how to use an API by studying its usage examples. There are many usage examples scattered in web pages on the Internet. However, it often takes programmers much effort to find out the desired examples from a large number of web pages by web search. This paper proposes a tool named APIExample that can extract usage examples for java APIs from web pages on the Internet and recommend them to programmers. Given a java API, the tool collects its related web pages from the Internet, extracts java code snippets and their surrounding descriptive texts embedded in the pages, then assembles them into usage examples for programmers. Furthermore, in order to help programmers capture more kinds of usages of the target API by browsing fewer examples, our tool clusters and ranks the listed examples based on the target API's usage. Besides, as a practical tool, APIExample provides multiple aspects of frequently-used information about using the target API in a concise user interface with friendly user experience. Two kinds of user-interaction style, a web search portal and an Eclipse plug-in, are now both publicly available. © 2011 IEEE."
"Hosogai E., Mukai T., Jung S., Kowase Y., Bossard A., Xu Y., Ishikawa M., Kaneko K." $ "A multilingual chat system with image presentation for detecting mistranslation" $ "We have designed and developed a multilingual chat system, MCHI (Multilingual Chat with Hint Images), which is based on machine translation and equipped with a presentation function of images related to the contents of the messages by utterers so that listeners are able to notice mistranslation. MCHI accepts English, French, Chinese, Japanese, Korean and Vietnamese languages. It uses the Google API to retrieve related images from the image posting site Flickr. As a result of evaluation experiment, we have observed that participants detected the mismatch of a translated message with its related image. According to the answers of participants for a questionnaire, it turned out that the usability of the MCHI system is good enough though the related images are not satisfactory."
"Stefik A., Siebert S., Stefik M., Slattery K." $ "An empirical comparison of the accuracy rates of novices using the quorum, perl, and randomo programming languages" $ "We present here an empirical study comparing the accuracy rates of novices writing software in three programming languages: Quorum, Perl, and Randomo. The first language, Quorum, we call an evidence-based programming language, where the syntax, semantics, and API designs change in correspondence to the latest academic research and literature on programming language usability. Second, while Perl is well known, we call Randomo a Placebo-language, where some of the syntax was chosen with a random number generator and the ASCII table. We compared novices that were programming for the first time using each of these languages, testing how accurately they could write simple programs using common program constructs (e.g., loops, conditionals, functions, variables, parameters). Results showed that while Quorum users were afforded significantly greater accuracy compared to those using Perl and Randomo, Perl users were unable to write programs more accurately than those using a language designed by chance. © 2011 ACM."
"Khan R.H., Ylitalo J., Ahmed A.S." $ "OpenID authentication as a service in OpenStack" $ "The evolution of cloud computing is driving the next generation of internet services. OpenStack is one of the largest open-source cloud computing middleware development communities. Currently, OpenStack supports platform specific signatures and tokens for user authentication. In this paper, we aim to introduce a cloud platform independent, flexible, and decentralized authentication mechanism, using OpenID as an open-source authentication mechanism in OpenStack. OpenID allows a decentralized framework for user authentication. It has its own advantages for web services, which include improvements in usability and seamless Single-Sign-On experience for the users. This paper presents the OpenlD-Authentication-as-a-Service APIs in OpenStack for front-end GUI servers, and performs the authentication in the back-end at a single Policy Decision Point (PDP). Our implementation allows users to use their OpenID Identifiers from standard OpenTD providers and log into the Dashboard/Django-Nova graphical interface of OpenStack. © 2011 IEEE."
"Dentler K., Cornet R., Ten Teije A., De Keizer N." $ "Comparison of reasoners for large ontologies in the OWL 2 EL profile" $ "This paper provides a survey to and a comparison of state-of-the-art Semantic Web reasoners that succeed in classifying large ontologies expressed in the tractable OWL 2 EL profile. Reasoners are characterized along several dimensions: The first dimension comprises underlying reasoning characteristics, such as the employed reasoning method and its correctness as well as the expressivity and worst-case computational complexity of its supported language and whether the reasoner supports incremental classification, rules, justifications for inconsistent concepts and ABox reasoning tasks. The second dimension is practical usability: whether the reasoner implements the OWL API and can be used via OWLlink, whether it is available as Protégé plugin, on which platforms it runs, whether its source is open or closed and which license it comes with. The last dimension contains performance indicators that can be evaluated empirically, such as classification, concept satisfiability, subsumption checking and consistency checking performance as well as required heap space and practical correctness, which is determined by comparing the computed concept hierarchies with each other. For the very large ontology SNOMED CT, which is released both in stated and inferred form, we test whether the computed concept hierarchies are correct by comparing them to the inferred form of the official distribution. The reasoners are categorized along the defined characteristics and benchmarked against well-known biomedical ontologies. The main conclusion from this study is that reasoners vary significantly with regard to all included characteristics, and therefore a critical assessment and evaluation of requirements is needed before selecting a reasoner for a real-life application. © 2011 - IOS Press and the authors. All rights reserved."
"Tseng L.C.-H." $ "Developer-friendly annotation-based HTML-to-XML transformation technology" $ "Nowadays, the amount of information accessible on the web is huge. Although web users today expect a more integrated way to access information on the web, it is still rather difficult to ""integrate"" information from different web sites since most web pages are authored in HTML format, which is actually a presentation-oriented language and is usually considered unstructured. Today, there are many research works aiming at extracting information from web pages. Existing works typically transform the extracting results into structured or semi-structured data formats, thus other applications can further process the results to discover more useful information. Nevertheless, the unstructured nature of HTML makes the transformation process complex and can hardly be widely adopted. In this paper, an annotation-based HTML-to-XML ransformation technology is proposed. The mechanism is developed with both usability and simplicity in mind. With the proposed mechanism, ordinary web site developers simply add annotations to their web pages. Annotated web pages can then be processed by our software libraries and transformed into XML documents, which are machine-understandable. Software agents thus can be developed based on our technology. © 2011 ACM."
"De Vocht L., Softic S., Ebner M., Mühlburger H." $ "Semantically driven social data aggregation interfaces for research 2.0" $ "We propose a framework to address an important issue in the context of the ongoing adoption of the ""Web 2.0"" in science and research, often referred to as ""Science 2.0"" or ""Research 2.0"". A growing number of people are linked via acquaintances and online social networks such as Twitter1allows indirect access to a huge amount of ideas. These ideas are contained in a massive human information flow [35]. That users of these networks produce relevant data is being shown in many studies [1][2][28][36]. The problem however lies in discovering and verifying such a stream of unstructured data items. Another related problem is locating an expert that could provide an answer to a very specific research question. We are using semantic technologies (RDF2,SPARQL3), common vocabularies(SIOC4, FOAF5,SWRC6) and Linked Data (DBpedia 7, GeoNames8, CoLinDa9) [3][4][5] to extract and mine the data about scientific events out of context of microblogs. Hereby we are identifying persons and organization related to them based on entities of time, place and topic. The framework provides an API that allows quick access to the information that is analyzed by our system. As a proof-of-concept we explain, implement and evaluate such a researcher profiling use case. It involves the development of a framework that focuses on the proposition of researches based on topics and conferences they have in common. This framework provides an API that allows quick access to the analyzed information. A demonstration application: ""Researcher Affinity Browser"" shows how the API supports developers to build rich internet applications for Research 2.0. This application also introduces the concept ""affinity"" that exposes the implicit proximity between entities and users based on the content users produced. The usability of a demonstration application and the usefulness of the framework itself are investigated with an explicit evaluation questionnaire. This user feedback led to important conclusions about successful achievements and opportunities to further improve this effort."
"Thamrin N.M., Ahmad I., Hani M.K." $ "A secure field programmable gate array based System-on-Chip for Telemedicine application" $ "In Telemedicine, confidential information is transferred through an unsecure channel from one party to another. In this paper, a field programmable gate array (FPGA) based approach to protect the data in the Telemedicine system, the mySECURE II is developed. There are two security schemes on a crypto System-on-Chip (SoC) proposed in this paper namely hybrid encryption scheme and Rivest-Shamir-Adleman (RSA) based digital signature scheme. It focuses on the development of 128-bit Advanced Encryption Standard (AES) subsystem, 2048-bit RSA crypto subsystem and Secure Hash Algorithm (SHA-1) crypto subsystem. In AES encryption and RSA crypto subsystems, the strength of these cryptosystems relies on keys. Therefore, a hybrid random number generator (RNG) is designed to provide on-chip key generation operation in this work. The crypto SOC is designed using hardware-software codesign technique. The hardware subsystems design are implemented on Altera Stratix 1S40F780C5 FPGA development board and integrated with Nios II processor to form a complete cryptosystem in System of Programmable Chip (SoPC) environment. The software design consists of the development of device drivers for hardware subsystem communication, and implementation of Cryptographic Service Provider (CSP), serves as the Application Programming Interface (API) in host PC. As a result, a prototype has been developed to test the functionality of the crypto hardware subsystem as well as the usability of the CSP. © 2011 IEEE."
"Hou D., Li L." $ "Obstacles in using frameworks and APIs: An exploratory study of programmers' newsgroup discussions" $ "Large software frameworks and APIs can be hard to learn and use, impeding software productivity. But what are the specific challenges that programmers actually face when using frameworks and APIs in practice? What makes APIs hard to use, and what can be done to alleviate the problems associated with API usability and learnability? To explore these questions, we conducted an exploratory study in which we manually analyzed a set of newsgroup discussions about specific challenges that programmers had about a software framework. Based on this set of data, we identified several categories of obstacles in using APIs. We discussed what could be done to help overcome these obstacles. © 2011 IEEE."
"Ameddah H., Assas M." $ "Bio-CAD reverse engineering of free-form surfaces by planar contours" $ "In this paper, an interactive application tool has been developed for creating 3D models of anatomical organs and other body structures from 2D medical imaging data. 3D models are generated by using reverse engineering algorithm and Planar Contour method by SolidWorks developed in Visual Basic Language. The research includes transferring Computed Tomography (CT) and Magnetic Resonance Imaging (MRI) images into digital matrixes, entering digital matrixes into SolidWorks environment, building feature library for 3D reconstruction, creating medical rapid prototyping models. 3D reconstruction is created by edge configuration generation and triangulated cube configuration generation in capturing section contour points from medical image per slice, creating B-spline curve with the control points in each layer, producing solid model construction in Planar Contours method. Medical rapid prototyping models are performed in SolidWorks. The results of this paper are to develop image processing 3D visualization in SolidWorks Application Programming Interface (API) using Visual Basic Language. The results reveal that the accuracy of 3D reconstruction is acceptable. © 2011 CAD Solutions, LLC."
"Benmerar T.Z., Boumghar F.O." $ "Toward a cloud architecture for medical imagery grid applications: The Acigna-G project" $ "Acigna-G is a new Grid Computing platform we propose, for hosting and interacting with GNU/Linux Grid applications through a web portal, without or with a minimal API use. It aims to provide a convenient Cloud Service for Medical Imagery Grid applications. It extends our GIC architecture with an implementation of a light version of the Virtually-distribution Parallel Architecture and the Multi-level Services architecture that permit the deployment of distributed Grid applications onto our platform. We propose these architecture as solutions to achieve both the convenience of PaaS Cloud services and the richness of Grid applications. We show how we deploy a MAS segmentation algorithm for Medical Imagery onto our Acigna-G platform. © 2011 IEEE."
"Lämmel R., Pek E., Starek J." $ "Large-scale, AST-based API-usage analysis of open-source Java projects" $ "Research on API migration and language conversion can be informed by empirical data about API usage. For instance, such data may help with designing and defending mapping rules for API migration in terms of relevance and applicability. We describe an approach to large-scale API-usage analysis of open-source Java projects, which we also instantiate for the Source-Forge open-source repository in a certain way. Our approach covers checkout, building, tagging with metadata, fact extraction, analysis, and synthesis with a large degree of automation. Fact extraction relies on resolved (type-checked) ASTs. We describe a few examples of API-usage analysis, they are motivated by API migration. These examples are concerned with analysing API footprint (such as the numbers of distinct APIs used in a project), API coverage (such as the percentage of methods of an API used in a corpus), and framework-like vs. class-library-like usage. © 2011 ACM."
"De Luca V., Epicoco I., Lezzi D., Aloisio G." $ "A web API framework for developing grid portals" $ "In this paper we describe a grid problem solving environment we developed for financial applications. We based its development on a portlet framework we have specifically developed and on a set of Web APIs that encapsulate all grid control and computation logic. Even though nowadays grid portals are characterized by various and different features and are implemented in very differing programming languages and technologies, we thought that they have many structural aspects in common. For this reason we decided to design and implement a set of Grid specific Web APIs, that we called GRB WAPI. Through them, a portal developer will not have to deal with grid technical details and will be able to manage a high level design. A portal developer will be able to concentrate on some other aspects that concern presentation, such as portal usability and functionality. We discarded the idea of developing a traditional library in order to free portal developers from a particular implementation technology. Thanks to this choice the portal presentation logic can be implemented in any web technology and can be on a different server. © 2011 Published by Elsevier Ltd."
"Devriese D., Piessens F." $ "Information flow enforcement in monadic libraries" $ "In various scenarios, there is a need to expose a certain API to client programs which are not fully trusted. In cases where the client programs need access to sensitive data, confidentiality can be enforced using an information flow policy. This is a general and powerful type of policy that has been widely studied and implemented. Previous work has shown how information flow policy enforcement can be implemented in a lightweight fashion in the form of a library. However, these approaches all suffer from a number of limitations. Often, the policy and its enforcement are not cleanly separated from the underlying API, and the user of the API is exposed to a strongly and unnaturally modified interface. Some of the approaches are limited to functional APIs and have difficulty handling imperative features like I/O and mutable state variables. In addition, this previous work uses classic static information flow enforcement techniques, and does not consider more recent dynamic information flow enforcement techniques. In this paper, we show that information flow policies can be enforced on imperative-style monadic APIs in a modular and reasonably general way with only a minor impact on the interface provided to API users. The main idea of this paper is that we implement the policy enforcement in a monad transformer while the underlying monadic API remains unaware and unmodified. The policy is specified through the lifting of underlying monad operations. We show the generality of our approach by presenting implementations of three important information flow enforcement techniques, including a purely dynamic, a purely static and a hybrid technique. Two of the techniques require the use of a generalisation of the Monad type class, but impact on the API interface stays limited. We show that our technique lends itself to formal reasoning by sketching a proof that our implementation of the static technique is faithful to the original presentation. Finally, we discuss fundamental limitations of our approach and how it fits in general information flow enforcement theory. © 2011 ACM."
"Membarth R., Hannig F., Teich J., Körner M., Eckert W." $ "Frameworks for multi-core architectures: A comprehensive evaluation using 2D/3D image registration" $ "The development of standard processors changed in the last years moving from bigger, more complex, and faster cores to putting several more simple cores onto one chip. This changed also the way programs are written in order to leverage the processing power of multiple cores of the same processor. In the beginning, programmers had to divide and distribute the work by hand to the available cores and to manage threads in order to use more than one core. Today, several frameworks exist to relieve the programmer from such tasks. In this paper, we present five such frameworks for parallelization on shared memory multi-core architectures, namely OpenMP, Cilk++, Threading Building Blocks, RapidMind, and OpenCL. To evaluate these frameworks, a real world application from medical imaging is investigated, the 2D/3D image registration. In an empirical study, a fine-grained data parallel and a coarse-grained task parallel parallelization approach are used to evaluate and estimate different aspects like usability, performance, and overhead of each framework. © 2011 Springer-Verlag."
"Nguyen H.A., Nguyen T.T., Wilson Jr. G., Nguyen A.T., Kim M., Nguyen T.N." $ "A graph-based approach to API usage adaptation" $ "Reusing existing library components is essential for reducing the cost of software development and maintenance. When library components evolve to accommodate new feature requests, to fix bugs, or to meet new standards, the clients of software libraries often need to make corresponding changes to correctly use the updated libraries. Existing API usage adaptation techniques support simple adaptation such as replacing the target of calls to a deprecated API, however, cannot handle complex adaptations such as creating a new object to be passed to a different API method, or adding an exception handling logic that surrounds the updated API method calls. This paper presents LIBSYNC that guides developers in adapting API usage code by learning complex API usage adaptation patterns from other clients that already migrated to a new library version (and also from the API usages within the library's test code). LIBSYNC uses several graph-based techniques (1) to identify changes to API declarations by comparing two library versions, (2) to extract associated API usage skeletons before and after library migration, and (3) to compare the extracted API usage skeletons to recover API usage adaptation patterns. Using the learned adaptation patterns, LIBSYNC recommends the locations and edit operations for adapting API usages. The evaluation of LIBSYNC on real-world software systems shows that it is highly correct and useful with a precision of 100% and a recall of 91%. © 2010 ACM."
"Nasehi S.M., Maurer F." $ "Unit tests as API usage examples" $ "t This study aims to find out if API unit tests can provide good usage examples, and if so, what prevents developers from finding and using those examples. The results of an experiment we performed with two groups of developers showed that unit tests can be very helpful, especially when the task is complicated and involves multiple classes and methods. Well-written tests proved to be a good source of examples, but finding the relevant examples using the standard tools might be very difficult. We propose to supplement the standard API documentation with relevant examples taken from the unit tests. To further improve the learnability of the API, presentation of the documentation and examples has to be tailored in a way that separates or hides advanced usage scenarios from the commonly used ones. © 2010 IEEE."
"Wu Y.-C., Mar L.W., Jiau H.C." $ "CoDocent: Support API usage with code example and API documentation" $ "API documentation and code example are two major resources to support API usage. To find the best way to use APIs within specific programming tasks, an effective strategy to link related APIs becomes critical. Currently, many code search engines have been proposed to solve this issue. Through those search results, programmers must manually traverse across all API documents to learn the referred API calls. To ensure the productivity in the style of programming with APIs, this work provides CoDocent to help programmers review code examples found by search engines. For each found code example, CoDocent can automatically link related API documents to provide diagrams as abstractions to reflect the semantics of API calls. Two evaluations are conducted to show the effectiveness of CoDocent in investigating and adapting API calls from code examples. © 2010 IEEE."
"Bajracharya S.K., Ossher J., Lopes C.V." $ "Leveraging usage similarity for effective retrieval of examples in code repositories" $ "Developers often learn to use APIs (Application Programming Interfaces) by looking at existing examples of API usage. Code repositories contain many instances of such usage of APIs. However, conventional information retrieval techniques fail to perform well in retrieving API usage examples from code repositories. This paper presents Structural Semantic Indexing (SSI), a technique to associate words to source code entities based on similarities of API usage. The heuristic behind this technique is that entities (classes, methods, etc.) that show similar uses of APIs are semantically related because they do similar things. We evaluate the effectiveness of SSI in code retrieval by comparing three SSI based retrieval schemes with two conventional baseline schemes. We evaluate the performance of the retrieval schemes by running a set of 20 candidate queries against a repository containing 222,397 source code entities from 346 jars belonging to the Eclipse framework. The results of the evaluation show that SSI is effective in improving the retrieval of examples in code repositories. © 2010 ACM."
"O'Callaghan P." $ "The API walkthrough method: A lightweight method for getting early feedback about an API" $ "We propose a method for evaluating the usability of an Application Programming Interface (API) in the context of MATLAB, a high-level programming language. The primary goal is to evaluate whether the participant can develop an accurate mental model of the API based on the code alone. Like traditional usability testing, this method takes place in a lab setting with a facilitator and observers, and a single participant is exposed to a prototype. Unlike traditional usability testing, the prototype is a static text document containing a series of programmatic statements. Rather than performing a task, the participant ""walks through"" the code line by line in an attempt to gain understanding of the system. Using standard usability testing protocols, the facilitators are able to assess whether the participant understands the API, as well as gather preference data between two designs. © 2010 ACM."
"Zibin Y." $ "Jury API: Secure client-side-only multiplayer gaming API" $ "Multiplayer gaming platforms (such as Come2Play, Skype, Nonoba, Oberon) offer game developers an API to develop new games. Having a secure API is critical to prevent hackers from unlawfully winning a game. Until today, to have a secure API, a developer had to write a server-side extension that determines the game outcome. However, a server-side extension is cumbersome to write (because you have to master two programming languages: for the client- and server-side), error-prone, hard to debug, and risky for the gaming platform that runs 3rd party code on its servers. This paper presents the first Secure client-side-only API (for short JuryAPI), i.e., the API is secure (the game outcome cannot be changed by hackers) and the API uses only client-side code (without any server-side extensions). JuryAPI mimics real-life games in which each player verifies that other players follow the game rules. In case of disagreement among the players, the server convenes a jury that finds the hacker. Using JuryAPI, one can develop secure multiplayer games using only client-side code, without using any server-side extensions. JuryAPI is an open-source standard developed by the multiplayer gaming company Come2Play, with an open-source flash emulator1. Come2Play freely hosts 3 rd party flash games and shares the revenues with the game developers."
"Ramkumar S., Kumar S., Shiroor R." $ "Process centric guidance and tools for next generation network services API design" $ "The growth in the number and variety of Network Application Programming Interfaces (APIs) like location, messaging, entertainment, personal storage and computing available to developers today and their rapid evolution has led to increased complexity of use in terms of adoption and keeping up with the incremental changes. Operators thus face an increasing need to roll out new Network Service APIs effectively and seamlessly. Well designed APIs not only make user adoption easier but also increase the probability that the user of the API will choose the Network Services API over other competing APIs in areas where standards are not available. The success Network Services APIs will to a large extent drive the external business case for Service Delivery Platforms in IMS in terms of ease of creation of new services leveraging operator services and capabilities. There is a lack of process centric guidance targeted at all important stakeholders like architects, designers, testers, the governance bodies and marketing personnel for the design of effective Network Services APIs which can help alignment with initiatives like SOA. This paper attempts to remedy the same by providing process centric and empirically grounded guidance for their creation and usage based on the practitioner engagements with leading operators and provides tools for automation. ©2010 IEEE."
"[No author name available]" $ "Evaluation and Usability of Programming Languages and Tools, PLATEAU'10" $ "The proceedings contain 8 papers. The topics discussed include: using CogTool to model programming tasks, user evaluation of correctness conditions: a case study of cooperability, the API walkthrough method, toward transforming freely available source code into usable learning materials for end-users, staking claims: a history of programming language design claims and evidence, hard-to-answer questions about code, comparing the usability of library vs. language approaches to task parallelism, and GoHotDraw: evaluating the go programming language with design patterns."
"Maaser M., Ortmann S." $ "Remote medical treatment at home using the Java Mobile Sensor API" $ "Since wireless sensor networks are successfully deployed in real life scenarios, applications in medical health-care, structural control, homeland security etc. become feasible. In those envisioned applications, easy maintenance and usability become crucial to staff members, e.g., to doctors or nurses. Not only for widespread distribution of hundreds of sensors, but also in tele-medical applications, remotely-controlled sensing and maintenance without direct access to sensors is required. For this purpose we present a middleware abstraction based on the standard Java Mobile Sensor API (JSR-256). It allows transparent access to sensor measurements, sensor information and maintenance data, which appear as local sensor resources to the user even if the sensors are connected via network. Hence, the user neither requires technical skills nor location information to request sensor data. This paper gives an architectural and functional overview of our middleware within the context of telemedicine. We demonstrate how our middleware approach supports patient monitoring for pre- and post-operative treatment at home. ©2010 IEEE."
"Harris W." $ "Functional programming at Freebase" $ "Freebase is a community-built, online database of facts and information, developed by Metaweb Technologies in San Francisco, California [1]. Freebase uses a proprietary graph database technology to store and query a network of over 12 million interrelated topics involving several hundred million individual graph relations. Third-party applications are free to query and update the Freebase database, and do so using the Metaweb Query Language, MQL [2]. MQL queries are expressed with a JSON-based template language which makes them easy to integrate into web applications, particularly the client-side portion which is processed with JavaScript?. Metaweb's first-generation MQL implementation was written as a Python-based middle-tier application that dynamically translates JSON-based queries into a low-level proprietary graph query language and networking protocol [3]. The low-level query language was designed for efficiency rather than for direct usability, and significant effort is required to translate between the two languages. Analysis of the entire Freebase application stack has revealed that as much time was being spent in the MQL query and result translation process as was being spent actually resolving the low-level graph queries. Much of this was attributed to the memory-intensive architecture of the translator, but a large portion was attributed to overhead inherent in the Python 2.6 runtime. We have undertaken developing a second-generation MQL translator written in Ocaml and drawing on a number of pure functional techniques. The core language translation process is expressed in terms of embedded language that implements the graph query protocol. This embedded language is used for both for static queries, e.g. for schema lookups, and for expressing the dynamic translation of MQL queries. The translator operates as a server and uses Lwt (Lightweight Threads library [4]) to interleave both client and graph database requests. A web services API and monitoring console have been developed using the Ocsigen web server and associated Eliom infrastructure [5]. The performance of our reimplemented MQL translator service is very encouraging. One process can sustain over an order of magnitude more simultaneous MQL requests, and service each request in a small fraction of the time consumed by the Python implementation. Moreover, due to the asynchronous nature of the underlying Lwt I/O subsystem, a single processor core can handle several times the capacity of an entire multi-core server machine running the former Apache/WSGI/Python [6] infrastructure. In addition to describing the MQL translator system, I would like to discuss the underlying mechanism by which it batches fragments of I/O requests together into single larger protocol messages, thereby minimizing communication overhead with the underlying graph database. This technique closely resembles monads typically used in functional programming, but also provides some of the benefits of 'arrows' [7]. © 2010 ACM."
"Den Burger M., Jacobs C., Kielmann T., Merzky A., Weidner O., Kaiser H." $ "What is the price of simplicity? A cross-platform evaluation of the SAGA API" $ "The abundance of middleware to access grids and clouds and their often complex APIs hinders ease of programming and portability. The Open Grid Forum (OGF) has therefore initiated the development and standardization of SAGA: a Simple API for Grid Applications. SAGA provides a simple yet powerful API with high-level constructs that abstract from the details of the underlying infrastructure. In this paper we investigate the price that possibly comes with such an API. We discuss the effects on expressiveness and ease of programming, and analyze the performance overhead of three different SAGA implementations (written in Java, Python, and C++) on various middleware. We conclude that SAGA is a good pragmatic approach to make grids easily accessible. The API considerably improves usability and uniformity, but offers a compromise between expressiveness and runtime dependencies. The overall performance of the tested implementations is acceptable, but the strict API semantics require various runtime checks that occasionally cause significant overhead, depending on the underlying infrastructure. © 2010 Springer-Verlag."
"Mileva Y.M., Dallmeier V., Zeller A." $ "Mining API popularity" $ "When designing a piece of software, one frequently must choose between multiple external libraries that provide similar services. Which library is the best one to use? We mined hundreds of open source projects and their external dependencies in order to observe the popularity of their APIs and to give recommendations of the kind: ""Projects are moving away from this API element. Consider a change."" Such wisdom of the crowds can provide valuable information to both the API users and the API producers. © 2010 Springer-Verlag."
"Hsu S.-K., Lin S.-J." $ "Mining source codes to guide software development" $ "The reuse of software library and application framework is an important activity for rapid software development. However, due to rapid software changes, software libraries and application frameworks are usually not well-documented. To deal with this issue, we have developed a tool, named MACs, that provides developers with efficient and effective access to the API pattern databases for a software development project that are form by relevant source files. After an initial program statement is given, our MACs prototype can correctly predict useful relevant API code snippets. In our evaluation, we present a study investigating the usefulness of MACs in software development tasks. Our experimental evaluation shows that MACs has significant potential to assist developers, especially project newcomers, and provides a reuse method for code reuse from relevant source codes files. © 2010 Springer-Verlag Berlin Heidelberg."
"Zhang D.-H., Xie B., Chen H.-J., Lv Y., Yu L." $ "Using geodata and geoprocessing web services in embedded device" $ "Using XML web services in embedded system could be able to use the existing geodata and geoprocessing services through wired/wireless network. However, the processing and memory limitations of embedded devices exacerbate the problem in the area of complexity, constraints, and the verbosity of the protocols used in XML web services effect the usability of XML. This paper presents a GPS navigation system, which accesses OGC-compliant geodata and geoprocessing services using gSOAP toolkit. This system composes of hardware platform, embedded operation system and software system. Our experimental result shows gSOAP could provides transparent SOAP API allows embedded system using XML web services. © 2010 IEEE."
"Bajracharya S., Ossher J., Lopes C." $ "Searching API usage examples in code repositories with sourcerer API search" $ "We present Sourcerer API Search (SAS), a search interface to find API usage examples in large code repositories. SAS facilitates finding API usage examples by providing three unique features: (i) code snippets view for each result that shows the portions of code where APIs are used, (ii) Tag-cloud view of popular words to facilitate query reformulation, and (iii) filtering results using APIs to narrow search results. Furthermore, SAS uses a code index where each code entity is indexed with terms not only found in the entity but also in other entities having similar API usage. These features make SAS a novel search interface to find API usage examples in code repositories. © 2010 ACM."
"Kim I., Lee D., Lee J., Rim K." $ "Extended authorization mechanism in OSGi" $ "As ubiquitous computing technology evolves, open API that is a solution to interconnect heterogeneous devices and services in a more fluid manner has emerged. Among open API solutions, OSGi is a Java-based service platform that is widely used in the service gateway of home network. In home network environments, the user authentication and authorization associated user's information and usability may be important security issue. Although the current OSGi support RBAC-based authorization, it does not support various facilities in the RBAC model. The access control mechanisms for OSGi proposed so far focus on supporting the RBAC conventions with the basic form of role-user-permission mappings. However, these are difficult to support efficient access control. We propose the extended access control mechanism that includes the concepts of relative role and delegate class. We explain the proposed access control mechanism with an example of developing a simple set-top box control service. ©2010 IEEE."
"Eisenberg D.S., Stylos J., Myers B.A." $ "Apatite: A new interface for exploring APIs" $ "We present Apatite, a new tool that aids users in learning and understanding a complex API by visualizing the common associations between its various components. Current object-oriented API documentation is usually navigated in a fixed tree structure, starting with a package and then filtering by a specific class. For large APIs, this scheme is overly restrictive, because it prevents users from locating a particular action without first knowing which class it belongs to. Apatite's design instead enables users to search across any level of an API's hierarchy. This is made possible by the introduction of a novel interaction technique that presents popular items from multiple categories simultaneously, determining their relevance by approximating the strength of their association using search engine data. The design of Apatite was refined through iterative usability testing, and it has been released publicly as a web application. © 2010 ACM."
"Sales L., Teófilo H., Mendonça N.C." $ "G2CL: A generic group communication layer for clustered applications" $ "Generic group communication frameworks offer several benefits to developers of clustered applications, including better software modularity and greater flexibility in selecting a particular group communication system. However, current generic frameworks only support a very limited set of group communication primitives, which has hampered their adoption by many ""real-world"" clustered applications that require higher-level group communication services, such as state transfer, distributed data structures and replicated method invocation. This paper describes the design, implementation and initial evaluation of G2CL, a Generic Group Communication Layer that offers a set of commonly used high-level group communication services implemented on top of an existing generic framework. Compared to current group communication solutions, G2CL offers two main contributions: (i) its services can be configured to run over any group communication system supported by the underlying generic framework, and (ii) it implements the same service API used by JGroups, a popular group communication toolkit, which may reduce its learning curve and make the task of migrating to G2CL particularly attractive for JGroups users. © 2010 Springer-Verlag Berlin Heidelberg."
"Zhou J., Ji Y., Zhao D., Liu J." $ "Using AOP to ensure component interactions in component-based software" $ "Component-based software development (CBSD) has been got considerable adoption in software industry, but it is still lack of language support to ensure proper interactions among components, i.e. modularity assurance, which usually causes the software hard to maintain and evolve because of the improper dependencies among the components. In this paper, we propose an AOP approach to ensure that the interactions among components are strictly conformed to the sated API usage policies of the components. Also, by using AOP, we can separate the constraints violation checking code from the normal functional code via the so called aspects, thus improving the software quality by separation of concern. Experiment using AspectJ as the AOP implementation technique shows that the performance is comparable to the non embedded code. ©2010 IEEE."
"Jugel U." $ "Generating smart wrapper libraries for arbitrary APIs" $ "Library design is language design [1]. The development of a smart program library is very similar to the creation of a domain specific language (DSL). Both are currently created in an ad-hoc manner
"Farooq U., Zirkler D." $ "API peer reviews: A method for evaluating usability of application programming interfaces" $ "API usability tests in the lab are time and resource intensive, thus allowing a relatively small percentage of the API namespace to be evaluated. We describe a group-based usability inspection method - API Peer Reviews - to evaluate API usability. Based on an analysis of usability breakdowns from API Peer Reviews and API usability tests, results show that API Peer Reviews identified breakdowns across several cognitive dimensions, some of which were different than what was identified by API usability tests. We reflect on the adoption of API Peer Reviews as a collaborative practice in organizations for evaluating API usability. Copyright 2010 ACM."
"Kim G., Suzuki Y., Nishida A., Takemiya H." $ "Development of APIs for desktop supercomputing" $ "We developed the Script Generator API to support Grid users to develop their own Grid-enabled client application. The Script Generator API automatically generates a Grid-enabled workflow script needed to execute jobs on a Grid system. The Script Generator API enables users to develop their application with the complex job flow which cannot be generated using existing workflow tools. We implemented the Script Generator API in our Grid infrastructure and utilized it to the three-dimensional virtual plant vibration simulator. By developing Grid-enabled client application for the three-dimensional virtual plant vibration simulator, we confirmed the usability of the Script Generator API. © Springer-Verlag Berlin Heidelberg 2010."
"Pradel M." $ "Dynamically inferring, refining, and checking API usage protocols" $ "Using a set of API methods often requires compliance with a protocol, whose violation can lead to errors in the program. However, most APIs lack explicit and formal definitions of these protocols. We propose a dynamic program analysis for automatically inferring and refining specifications of correct method call sequences. Our experiments with several Java programs show that we can infer meaningful protocols, such as widely respected programming rules. Furthermore, our analysis finds violations of the inferred specifications that point out potential bugs to the programmer."
"Pletcher D.M., Hou D." $ "BCC: Enhancing code completion for better API usability" $ "Nowadays, programmers spend much of their workday dealing with code libraries and frameworks that are bloated with APIs. One common way of interacting with APIs is through Code Completion inside the code editor. By default, Code Completion presents in a scrollable list, in alphabetical order, all accessible members available in the apparent type and supertypes of a receiver expression. This default behavior for Code Completion should and can be further improved because (1) not all public methods are APIs and presenting non-API public members to a programmer is misleading, (2) certain APIs are meant to be accessible only in some limited contexts but not others, and (3) the alphabetical order separates otherwise logically related APIs, making it hard to see their connection. BCC (Better Code Completion) addresses these problems by enhancing Code Completion so that programmers can control how specific API elements should be sorted, filtered, and grouped."
"Lo D., Ramalingam G., Ranganath V.P., Vaswani K." $ "Mining quantified temporal rules: Formalism, algorithms, and evaluation" $ "Libraries usually impose constraints on how clients should use them. Often these constraints are not well-documented. In this paper, we address the problem of recovering such constraints automatically, a problem referred to as specification mining. Given some client programs that use a given library, we identify constraints on the library usage that are (almost) satisfied by the given set of clients. The class of rules we target for mining combines simple binary temporal operators with state predicates (involving equality constraints) and quantification. This is a simple yet expressive subclass of temporal properties that allows us to capture many common API usage rules.We focus on recovering rules from execution traces and apply classical data mining concepts to be robust against bugs (API usage rule violations) in clients. We present new algorithms for mining rules from execution traces. We show how a propositional rule mining algorithm can be generalized to treat quantification and state predicates in a unified way. Our approach enables the miner to be complete - mine all rules within the targeted class that are satisfied by the given traces - while avoiding an exponential blowup. We have implemented these algorithms and used them to mine API usage rules for several Windows APIs. Our experiments show the efficiency and effectiveness of our approach. © 2009 IEEE."
"Kim K., Lee H., Jo S., Ryu W." $ "Implementation of open web portal service enabler based on service delivery platform" $ "This paper is to provide implementation supporting open web portal service enabler based on Service Delivery Platform(SDP). This technology is for adapter to provide the method for converging web portal Application Program Interface(API) using SDP. It united the specification of protocols and parameters per web site in order to support ""Open Method"". Also for adding the new web site and modifying the existed web site with ease, it utilized database dynamically. © 2009 IEEE."
"Stylos J., Faulring A., Yang Z., Myers B.A." $ "Improving API documentation using API usage information" $ "Jadeite is a new Javadoc-like API documentation system that takes advantage of multiple users' aggregate experience to reduce difficulties that programmers have learning new APIs. Previous studies have shown that programmers often guessed that certain classes or methods should exist, and looked for these in the API. Jadeite's ""placeholders"" let users add new ""pretend"" classes or methods that are displayed in the actual API documentation, and can be annotated with the appropriate APIs to use instead. Since studies showed that programmers had difficulty finding the right classes from long lists in documentation, Jadeite takes advantage of usage statistics to display commonly used classes more prominently. Programmers had difficulty discovering how to instantiate objects, so Jadeite uses a large corpus of sample code to automatically the most common ways to construct an instance of any given class. An evaluation showed that programmers were about three times faster at performing common tasks with Jadeite than with standard Javadoc. ©2009 IEEE."
"Nguyen T.T., Nguyen H.A., Pham N.H., Al-Kofahi J.M., Nguyen T.N." $ "Graph-based mining of multiple object usage patterns" $ "The interplay of multiple objects in object-oriented programming often follows specific protocols, for example certain orders of method calls and/or control structure constraints among them that are parts of the intended object usages. Unfortunately, the information is not always documented. That creates long learning curve, and importantly, leads to subtle problems due to the misuse of objects. In this paper, we propose GrouMiner, a novel graph-based approach for mining the usage patterns of one or multiple objects. GrouMiner approach includes a graph-based representation for multiple object usages, a pattern mining algorithm, and an anomaly detection technique that are efficient, accurate, and resilient to software changes. Our experiments on several real-world programs show that our prototype is able to find useful usage patterns with multiple objects and control structures, and to translate them into user-friendly code skeletons to assist developers in programming. It could also detect the usage anomalies that caused yet undiscovered defects and code smells in those programs. Copyright 2009 ACM."
"Parreiras F.S., Saathoff C., Walter T., Franz T., Staab S." $ "APIs à gogo: Automatic generation of ontology APIs" $ "When developing application programming interfaces of ontologies that include many instances of ontology design patterns, developers of semantic web applications usually have to handle complex mappings between descriptions of information given by ontologies and object oriented representations of the same information. In current approaches, annotations on API source code handle these mappings, leading to problems with reuse and maintenance. We propose a domain-specific language to tackle these mappings in a platform independent way - agogo. Agogo provides improvements on software engineering quality attributes like usability, reusability, maintainability, and portability. © 2009 IEEE."
"Mentis A.S." $ "A robotics API dialect for type-safe robots: Translating Myro to Ada" $ "In this paper, we present an Ada robotics API designed to be used in teaching undergraduate-level computer science. Our API is inspired by Myro, a Python-based API, but we improve upon Myro's usability, readability, modularity, and documentation by using features of the Ada programming language and the GNAT Programming Studio's documentation generation tool. The encapsulation, abstraction, and data hiding provided by Ada's packages make it easy for beginning programmers to use the API for advanced tasks, while Ada's syntax and readability allow educators to use the underlying code later in a course or curriculum to illustrate more advanced concepts to the same students as their knowledge and experience grow. Copyright 2009 Association for Computing Machinery."
"Dekel U., Herbsleb J.D." $ "Improving API documentation usability with knowledge pushing" $ "The documentation of API functions typically conveys detailed specifications for the benefit of interested readers. In some cases, however, it also contains usage directives, such as rules or caveats, of which authors of invoking code must be made aware to prevent errors and inefficiencies. There is a risk that these directives may be ""lost"" within the verbose text, or that the text would not be read because there are so many invoked functions. To address these concerns for Java, an Eclipse plug-in named eMoose decorates method invocations whose targets have associated directives. Our goal is to lead readers to investigate further, which we aid by highlighting the tagged directives in the JavaDoc hover. We present a lab study that demonstrates the directive awareness problem in traditional documentation use and the potential benefits of our approach. © 2009 IEEE."
"Dillon R., Bee N.K., Rozner S." $ "The music and emotion driven game engine: Ideas and games" $ "In this paper we describe the ideas behind the Music and Emotion Driven Game Engine (M-EDGE), currently under development at the School of Interactive and Digital Media in Nanyang Polytechnic and fully supported by the Singapore National Research Foundation. The paper will explain a possible method for analyzing emotional content in music in real time and how it can successfully be applied to different game ideas to help defining a new interactive experience and music based gameplay in videogames."
"Harrison W., Lievens D., Simeoni F." $ "Safer typing of complex API usage through java generics" $ "When several incompatible implementations of a single API are in use in a Java program, the danger exists that instances from different implementations may inadvertently be mixed, leading to errors. In this paper we show how to use generics to prevent such mixing. The core idea of the approach is to add a type parameter to the interfaces of the API, and tie the classes that make up an implementation to a unique choice of type parameter. In this way methods of the API can only be invoked with arguments that belong to the same implementation. We show that the presence of a type parameter in the interfaces does not violate the principle of interface-based programming: clients can still completely abstract over the choice of implementation. In addition, we demonstrate how code can be reused between different implementations, how implementations can be defined as extensions of other implementations, and how different implementations may be mixed in a controlled and safe manner. To explore the feasibility of the approach, gauge its usability, and identify any issues that may crop up in practical usage, we have refactored a fairly large existing API-based application suite, and we report on the experience gained in the process. Copyright 2009 ACM."
"Kim M.S., Wellings A." $ "Refactoring asynchronous event handling in the real-time specification for Java" $ "The primary goal for asynchronous event handling (AEH) in the Real-Time Specification for Java (RTSJ) is to have a lightweight concurrency mechanism. However the RTSJ neither provides a well-defined guideline on how to implement AEH nor requires the documentation of the AEH model used in the implementation. Also the AEH API in the RTSJ are criticised as lacking in configurability as they do not provide any means for programmers to have fine control over the AEH facilities, such as the mapping between real-time threads and handlers. For these reasons, it needs the refactoring of its application programming interface (API) to give programmers more configurability. This paper, therefore, proposes a set of AEH related classes and interfaces to enable flexible configurability over AEH components. We have implemented the refactored configurable AEH API using the new specifications on an existing RTSJ implementation and this paper shows that it allows more configurability for programmers than the current AEH API in the RTSJ does. Consequently programmers are able to specifically tailor the AEH subsystem to fit their applications' particular needs. © 2009 IEEE."
"Schoeberlein J.G., Wang Y." $ "Evaluating groupware accessibility" $ "Accessibility has been one of the biggest problems that people with disabilities face in the work place, due to today's rapid change in computer technology. This paper presents the evaluation of several console-based and web-based groupware applications including Outlook, AIM, Google Blog, and Group System's ThinkTank in terms of their accessibility. These applications were evaluated for accessibility based on various characteristics of the applications such as accessible front-end, hierarchy or list structures, input support, output support, screen reader adaptability, and keyboard access. Additionally, web-based groupware applications were evaluated using Web Content Accessibility Guidelines (WCAG) and U.S. Government's Section 508 guidelines. Fujitsu's Web Accessibility Inspector tool was also utilized to help evaluate the web-based applications. It is found that groupware applications have very limited accessibility through the support of keyboard access. Additional audio support and flattened hierarchies should be considered, to enable some persons with disabilities easy access to groupware applications. Future research should include persons with disabilities in evaluating groupware applications, to determine preferences. Since many groupware applications provide Application Program Interfaces (API), custom front-ends should be developed to include audio content and to flatten hierarchies and lists. © 2009 Springer Berlin Heidelberg."
"Kawrykow D., Robillard M.P." $ "Detecting inefficient API usage" $ "Large software projects often rely on third-party libraries, made accessible through Application Programming Interfaces (APIs). We have observed many cases where APIs are used in ways that are not efficient. We developed a technique to automatically detect inefficient API usage in software projects. The main hypothesis underlying the technique is that client code that imitates the behavior of a library method without calling it is likely not to use the library as efficiently as possible. In addition to warning developers of potentially inefficient API usage, our technique also indicates how to improve the use of the API. Application of the technique on Java open-source systems revealed many cases of inefficient API usage, and corresponding recommendations that led to code improvements. © 2009 IEEE."
"Daughtry J.M., Farooq U., Stylos J., Myers B.A." $ "API usability: CHI'2009 special interest group meeting" $ "Programmers of all types from novice end-user developers to professional software engineers make use of application programming interfaces (API) within their various designs. And, while the use of these interfaces is ubiquitous, there is little research about their design. Recently, a number of researchers and practitioners have begun to treat API design as a first-order object of study and practice. The purpose of this special interest group meeting is to bring together the community of usability researchers and professionals interested in API usability. The time will be used to discuss attendees' ideas and opinions in order to stimulate this new and exciting emerging field that crosses the boundaries between human-computer interaction and software engineering."
"Zhong H., Xie T., Zhang L., Pei J., Mei H." $ "MAPO: mining and recommending api usage patterns" $ "To improve software productivity, when constructing new software systems, programmers often reuse existing libraries or frameworks by invoking methods provided in their APIs. Those API methods, however, are often complex and not well documented. To get familiar with how those API methods are used, programmers often exploit a source code search tool to search for code snippets that use the API methods of interest. However, the returned code snippets are often large in number, and the huge number of snippets places a barrier for programmers to locate useful ones. In order to help programmers overcome this barrier, we have developed an API usage mining framework and its supporting tool called MAPO (Mining API usage Pattern from Open source repositories) for mining API usage patterns automatically. A mined pattern describes that in a certain usage scenario, some API methods are frequently called together and their usages follow some sequential rules. MAPO further recommends the mined API usage patterns and their associated code snippets upon programmers' requests. Our experimental results show that with these patterns MAPO helps programmers locate useful code snippets more effectively than two state-of-the-art code search tools. To investigate whether MAPO can assist programmers in programming tasks, we further conducted an empirical study. The results show that using MAPO, programmers produce code with fewer bugs when facing relatively complex API usages, comparing with using the two state-of-the-art code search tools. © 2009 Springer Berlin Heidelberg."
"Jeong S.Y., Xie Y., Beaton J., Myers B.A., Stylos J., Ehret R., Karstens J., Efeoglu A., Busse D.K." $ "Improving documentation for eSOA APIs through user studies" $ "All software today is written using libraries, toolkits, frameworks and other application programming interfaces (APIs). We performed a user study of the online documentation a large and complex API for Enterprise Service-Oriented Architecture (eSOA), which identified many issues and recommendations for making API documentation easier to use. eSOA is an appropriate testbed because the target user groups range from high-level business experts who do not have significant programming expertise (and thus are end-participant developers), to professional programmers. Our study showed that the participants' background influenced how they navigated the documentation. Lack of familiarity with business terminology was a barrier we observed for developers without business application experience. Participants with business software experience had difficulty differentiating similarly named services. Both groups avoided areas of the documentation that had an inconsistent visual design. A new design for the documentation that supports flexible navigation strategies seem to be required to support the wide range of users for eSOA. This paper summarizes our study and provides recommendations for future documentation for developers. © 2009 Springer Berlin Heidelberg."
"Kim G., Suzuki Y., Teshima N., Nishida A., Yamada T., Araya F., Takemiya H., Nakajima N., Kondo M." $ "A script generator API for the full-scale three-dimensional vibration simulation of an entire nuclear power plant within AEGIS" $ "We developed the Script Generator API to support users to develop Grid-enabled client application. The Script Generator API automatically generates a Grid-enabled workflow script needed to execute jobs on a Grid system. Using the Script Generator API enables users to use a Grid environment without consciousness of a Grid computing system. In this paper, we show the implementation of the Script Generator API in our Grid infrastructure and its utilization to the Full-scale 3D Vibration Simulator for an Entire Nuclear Power Plant. By developing a Gridenabled client application for the Full-scale 3D Vibration Simulator, we confirmed the usability of the Script Generator API. © Civil-Comp Press, 2009."
"Bollacker K., Evans C., Paritosh P., Sturge T., Taylor J." $ "Freebase: A collaboratively created graph database for structuring human knowledge" $ "Freebase is a practical, scalable tuple database used to structure general human knowledge. The data in Freebase is collaboratively created, structured, and maintained. Free-base currently contains more than 125,000,000 tuples, more than 4000 types, and more than 7000 properties. Public read/write access to Freebase is allowed through an HTTP-based graph-query API using the Metaweb Query Language (MQL) as a data query and manipulation language. MQL provides an easy-to-use object-oriented interface to the tuple data in Freebase and is designed to facilitate the creation of collaborative, Web-based data-oriented applications."
"Beaton J., Myers B.A., Stylos J., Jeong S.Y., Xie Y." $ "Usability evaluation for Enterprise SOA APIs" $ "SAP recently began offering access to web services through its Enterprise Service-Oriented Architecture (E-SOA) platform. It is in the best interest of SAP that its E-SOA service operations are easier for developers to use and understand, which will contribute to higher E-SOA adoption, and a more effective means of innovation on the part of business customers. To facilitate such a change, Carnegie Mellon University's Human-Computer Interaction Institute is working with SAP's E-SOA and Business Process Renovation Teams to analyze the E-SOA interfaces using HCI techniques and determine means by which developers assigned to create SOA APIs in general, and Enterprise SOA APIs in particular, can design superior interfaces. The identification of usable design patterns, and methodologies to determine these patterns, can streamline SOA projects for API developers and programmers who use SOA APIs. Copyright 2008 ACM."
"Khoroshilov A.V., Rubanov V.V., Shatokhin E.A." $ "Automated formal testing of C API using T2C framework" $ "A problem of automated test development for checking basic functionality of program interfaces (API) is discussed. Different technologies and corresponding tools are surveyed. And T2C technology developed in ISPRAS is presented. The technology and associated tools facilitate development of ""medium quality"" (and ""medium cost"") tests. An important feature of T2C technology is that it enforces that each check in a developed test is explicitly linked to the corresponding place in the standard. T2C tools provide convenient means to create such linkage. The results of using T2C are considered by example of a project for testing interfaces of Linux system libraries defined by the LSB standard. © 2008 Springer-Verlag."
"[No author name available]" $ "RSSE '08 - Proc. 2008 International Workshop on Recommendation Systems for Software Engineering, Co-located with the 16th ACM SIGSOFT International Symposium on the Foundations of Software Engineering" $ "The proceedings contain 14 papers. The topics discussed include: recommending method invocation context changes, not all classes are created equal: toward a recommendation system for focusing testing, potentials and challenges of recommendation systems for software development, on evaluating recommender systems for API usages, dimensions of tools for detecting software conflicts, understanding interaction differences between newcomer and expert programmers, what is the long-term impact of changes?, evaluating recommended applications, seven habits of a highly effective smell detector, towards an agent-based framework for guiding design exploration, improving the readability of defect reports, and a recommendation system for security requirements."
"[No author name available]" $ "3rd International Symposium on Leveraging Applications of Formal Methods, Verification and Validation, ISoLA 2008" $ "The proceedings contain 61 papers. The special focus in this conference is on Leveraging Applications of Formal Methods, Verification and Validation. The topics include: Architecture based specification and verification of embedded software systems, information system engineering supporting observation, orientation, decision, and compliant action, modelling coordination and compensation, animating event B models by formal data models, automated formal testing of C API using T2C framework, tailoring and optimising software for automotive multicore system, timing validation of automotive software, towards using reo for compliance-aware business process modeling, a use-case driven approach to formal service-oriented modelling, safety and response-time analysis of an automotive accident assistance service, a framework for analyzing and testing the performance of software services, assuring the satisfiability of sequential extended regular expressions, computing must and may alias to detect null pointer dereference, program verification by reduction to semi-algebraic systems solving, debugging statecharts via model-code traceability, formal use of design patterns and refactoring, a component-based access control monitor, navigating the requirements jungle, non-functional avionics requirements, measurement-based timing analysis, weaving a formal methods education with problem-based learning, encouraging the uptake of formal methods training in an industrial context, computer-supported collaborative learning with mind-maps, thinking in user-centric models, specialization and instantiation aspects of a standard process for developing educational modules, contexts and context awareness in view of the diagram predicate framework, the use of adaptive semantic hypermedia for ubiquitous collaboration systems, the use of formal ontology to specify context in ubiquitous computing, high service availability in MaTRICS for the OCS, the ASK system and the challenge of distributed knowledge discovery, requirements for ontology based design project assessment, organizing the worlds machine learning information, workflow testing, directed generation of test data for static semantics checker, optimizing the system observability level for diagnosability, weaving authentication and authorization requirements into the functional model of a system using Z promotion, simple gedanken experiments in leveraging applications of formal methods and composition of web services using wrappers."
"Chew B.N., Chang C.W., Salinas S.V., Liew S.C." $ "Remote sensing measurements of aerosol optical thickness and correlation with in-situ air quality parameters during a biomass burning episode in Southeast Asia" $ "Smoke haze related to biomass burning is a recurring environmental problem in Southeast Asia which has affected air quality not only in the source regions, but also in the surrounding areas. Air quality monitoring stations and meteorological stations in the region provide valuable information on the concentrations of criteria pollutants such as sulphur dioxide, nitrogen oxide, carbon monoxide, ozone and particulate mass (PM 10) during the haze episodes. Due to the limited coverage of the air quality monitoring stations, it is difficult to study and monitor the spatial and temporal variability of the smoke haze caused by biomass burning, especially in areas without ground-based instrumentation. As such, in this paper, we combine the standard in-situ measurements of PM 10 with remote sensing imagery obtained from the Moderate Resolution Imaging Spectroradiometer (MODIS) on board the Terra and Aqua satellites. The columnar AOT is first derived from MODIS images for regions where PM 10 measurements are available and a correlation between AOT and PM 10 measurements is then established. Based on this empirical correlation, it is also shown that MODIS AOT can be used to estimate air quality categories as defined in the Air Pollutant Index (API) used by Malaysia's Department of Environment (DOE) and the Pollutant Standards Index (PSI) used by Singapore's National Environment Agency (NEA). With this integrated approach, we hope to complement and enhance current capabilities in monitoring air quality during the haze episodes."
"Eggen R., Jones C., Eggen M." $ "Ruby, PHP, Perl, Python: A web efficiency comparison" $ "In our modern world with so much emphasis being placed on the web and on web services it is fitting to evaluate the most popular web based API for speed, usability, reliability and general over all productivity. This paper seeks to analyze and demarcate Ruby, Perl, Python, and PHP. Several web services are simultaneously requested via the Apache web server. The server accesses scripts in each language to generate data served to the client. Attention is given to ease of use, programmer difficulty, and performance of the applications once completed. A client-server scenario is constructed, timings are taken, and appropriate conclusions drawn."
"Tan Y.K.A., Kwoh L.K., Ong S.H." $ "Texture mapping of 3-D building models using pose estimation of digital photographs" $ "A virtual 3-D city is a sophisticated application of geo-informatics systems as it is a representation of layouts, activities and functionalities of a real-world community. It is an integrated effort in the fields of computer graphics, remote sensing and engineering to model the appearance and dynamics of the real world. The primary aim is to introduce a feasible, yet compelling representation of the city in the virtual world. It will be an attractive option to view and explore the building architecture of the past, present and future without being encumbered by the constraints of reality. Visualization of city models in a virtual environment is a combination of many challenging and laborious tasks, one of which is the texturing of building models façade. To improve the overall photo-realistic quality and usability of the visualization platform, we can texture the building façade with oblique-view terrestrial digital photographs taken using commercially available cameras. This paper will show that we can automatically extract the building façade textures after pose estimation of the acquired image is done. The OpenGL camera must be properly initialized with the intrinsic parameters of the actual camera before pose estimation. After which the actual camera's location and orientation can be estimated directly by matching the relative pose between the rendered 3-D scene geometry and the information from the acquired image. It is important to obtain a good estimate of the camera's pose as the recovered parameters would affect the accuracy of extracted façade textures. A test example will be used to demonstrate the system of performing texture mapping using series of close-range photographs after pose estimation was carried out."
"Lobato C., Garcia A., Romanovsky A., Lucena C." $ "An aspect-oriented software architecture for code mobility" $ "Mobile agents have come forward as a technique for tackling the complexity of open distributed applications. However, the pervasive nature of code mobility implies that it cannot be modularized using only object-oriented (OO) concepts. In fact, developers frequently evidence the presence of mobility scattering in their system's modules. Despite these problems, they usually rely on OO application programming interfaces (APIs) offered by the mobility platforms. Such classical API-oriented designs suffer a number of architectural restrictions, and there is a pressing need for empowering developers with an architectural framework supporting a flexible incorporation of code mobility in the agent applications. This work presents an aspect-oriented software architecture, called ArchM, ensuring that code mobility has an enhanced modularization and variability in agent systems, and is straightforwardly introduced in otherwise stationary agents. It addresses OO APIs' restrictions and is independent of specific platforms and applications. An ArchM implementation also overcomes fine-grained problems related to mobility tangling and scattering at the implementation level. The usefulness and usability of ArchM are assessed within the context of two case studies and through its composition with two mobility platforms. Copyright © 2008 John Wiley & Sons, Ltd."
"Ratiu D., Jürjens J." $ "Evaluating the reference and representation of domain concepts in APIs" $ "As libraries are the most widespread form of software reuse, the usability of their APIs substantially influences the productivity of programmers in all software development phuses. In this paper we develop a framework to characterize domain-specific APIs along two directions: 1) how can the API users reference the domain concepts implemented by the API, 2) how are the domain concepts internally represented in the API. We define metrics that allow the API developer for example to assess the conceptual complexity of his API and the non-uniformity and ambiguities introduced by the API's internal representations of domain concepts, which makes developing and maintaining software that uses the library difficult and error-prone. The aim is to be able to predict these difficulties already during the development of the API, and based on this feedback be able to develop better APIs up front, which will reduce the risks of these difficulties later. © 2008 IEEE."
"Hoefler T., Lumsdaine A." $ "Optimizing non-blocking collective operations for InfiniBand" $ "Non-blocking collective operations have recently been shown to be a promising complementary approach for overlapping communication and computation in parallel applications. However, in order to maximize the performance and usability of these operations it is important that they progress concurrently with the application without introducing CPU overhead and without requiring explicit user intervention. While studying non-blocking collective operations in the context of our portable library (libNBC), we found that most MPI implementations do not sufficienctly support overlap over the InfiniBand network. To address this issue, we developed a low-level communication layer for libNBC based on the Open Fabrics InfiniBand verbs API. With this layer we are able to achieve high degrees of overlap without the need to explicitly progress the communication operations. We show that the communication overhead of parallel application kernels can be reduced up to 92% while not requiring user intervention to make progress. ©2008 IEEE."
"Ivanyukovich A., Marchese M., Giunchiglia F." $ "ScienceTreks: An autonomous digital library system" $ "Purpose - The purpose of this paper is to provide support for automation of the annotation process of large corpora of digital content. Design/methodology/approach - The paper presents and discusses an information extraction pipeline from digital document acquisition to information extraction, processing and management. An overall architecture that supports such an extraction pipeline is detailed and discussed. Findings - The proposed pipeline is implemented in a working prototype of an autonomous digital library (A-DL) system called ScienceTreks that: supports a broad range of methods for document acquisition, does not rely on any external information sources and is solely based on the existing information in the document itself and in the overall set in a given digital archive, and provides application programming interfaces (API) to support easy integration of external systems and tools in the existing pipeline. Practical implications - The proposed A-DL system can be used in automating end-to-end information retrieval and processing, supporting the control and elimination of error-prone human intervention in the process. Originality/value - High quality automatic metadata extraction is a crucial step in the move from linguistic entities to logical entities, relation information and logical relations, and therefore to the semantic level of digital library usability. This in turn creates the opportunity for value-added services within existing and future semantic-enabled digital library systems. © Emerald Group Publishing Limited."
"Vaughan R." $ "Massively multi-robot simulation in stage" $ "Stage is a C++ software library that simulates multiple mobile robots. Stage version 2, as the simulation backend for the Player/Stage system, may be the most commonly used robot simulator in research and university teaching today. Development of Stage version 3 has focused on improving scalability, usability, and portability. This paper examines Stage's scalability. We propose a simple benchmark for multi-robot simulator performance, and present results for Stage. Run time is shown to scale approximately linearly with population size up to 100,000 robots. For example, Stage simulates 1 simple robot at around 1,000 times faster than real time, and 1,000 simple robots at around real time. These results suggest that Stage may be useful for swarm robotics researchers who would otherwise use custom simulators, with their attendant disadvantages in terms of code reuse and transparency. © Springer Science + Business Media, LLC 2008."
"Balakrishnan G., Reps T." $ "Analyzing stripped device-driver executables" $ "This paper sketches the design and implementation of Device-Driver Analyzer for x86 (DDA/x86), a prototype analysis tool for finding bugs in stripped Windows device-driver executables (i.e., when neither source code nor symbol-table/debugging information is available), and presents a case study. DDA/x86 was able to find known bugs (previously discovered by source-code-based analysis tools) along with useful error traces, while having a reasonably low false-positive rate. This work represents the first known application of automatic program verification/analysis to stripped industrial executables, and allows one to check that an executable does not violate known API usage rules (rather than simply trusting that the implementation is correct). © 2008 Springer-Verlag Berlin Heidelberg."
"Song Y., Tanaka Y., Nakada H., Sekiguchi S." $ "Towards simplifying grid enablement for scientific applications" $ "It is very complex to implement and execute grid applications in a dynamic grid environment due to scale and heterogeneity. Consequently, we propose a solution to lower the barrier to implement and execute grid applications in this paper. In order to facilitate adapting scientific applications to a grid environment, GridRPC has been standardized by OGF (Open Grid Forum) for remote procedure calls over the grid. However, the GridRPC standard defines API in C only, while most scientific and engineering applications are implemented in Fortran. To avoid the cumbersome development of Fortran wrappers for such applications, we then have proposed GricRPC Fortran90 bindings and implemented the Fortran90 API based on Ninf-G which is one of the reference implementations of the GridRPC standard. As for the execution, we have developed a resource allocator called GRPLib. The GRPLib can provide applications with availability-guaranteed and reliability-evaluated resources, which frees users from dealing with faults to some extent during executions. A framework which combines the Ninf-G and GRPLib in Fortran90 has also been developed. This framework has been successfully used to gridify a Fortran application called MD/QM (molecular dynamics/quantum mechanical application) simulation program. This paper therefore presents the Fortran90 bindings of the GridRPC, describes the GRPLib, discusses the integrated framework, reports a case study, and concludes the simplicity and usability of this solution. © 2008 Global Information Publisher (H.K) Co., Limited. All rights reserved."
"Yang Y., Chen X., Gopalakrishnan G., Kirby R.M." $ "Distributed dynamic partial order reduction based verification of threaded software" $ "Runtime (dynamic) model checking is a promising verification methodology for real-world threaded software because of its many features, the prominent ones being: (i) it avoids the need to extract a model and instead runs the actual code, and (ii) the precision of information available at run-time allows techniques such as dynamic partial order reduction (DPOR) [1] to dramatically cut down the number of interleavings examined. Unfortunately, DPOR does not have many implementations for real thread libraries such as POSIX Pthreads, and suffers from high computational overheads due to a stateless search that requires re-executions. In our previous work [2], we designed a runtime model checker, inspect, that overcomes the first of these drawbacks. Inspect has been shown capable of detecting data races, deadlocks and other incorrect API usages in real-world PThreads C programs. In this paper, we describe a distributed version of inspect, which implements an extended DPOR algorithm. Our two key contributions are: (i) a practical algorithm for distributed dynamic partial order reduction, (ii) the innovations that helped distributed inspect attain nearly linear (with respect to the number of CPUs) speedup on realistic examples. © Springer-Verlag Berlin Heidelberg 2007."
"Acharya M., Xie T., Pei J., Xu J." $ "Mining API patterns as partial orders from source code: From usage scenarios to specifications" $ "A software system interacts with third-party libraries through various APIs. Using these library APIs often needs tofollow certain usage patterns. Furthermore, ordering rules (specifications) exist between APIs, and these rules govern the secure and robust operation of the system using these APIs. But these patterns and rules may not be well documented by the API developers. Previous approaches mine frequent association rules, itemsets, or subsequences that capture API call patterns shared by API client code. However, these frequent API patterns cannot completely capture some useful orderings shared by APIs, especially when multiple APIs are involved across different procedures. In this paper, we present a framework to automatically extract usage scenarios among user-specified APIs as partial orders, directly from the source code (API client code). We adapt a model checker to generate interprocedural control-flow-sensitive static traces related to the APIs of interest. Different API usage scenarios are extracted from the static traces by our scenario extraction algorithm and fed to a miner. The miner summarizes different usage scenarios as compact partial orders. Specifications are extracted from the frequent partial orders using our specification extraction algorithm. Our experience of applying the framework on 72 X11 clients with 200K LOC in total has shown that theextracted API partial orders are useful in assisting effective API reuse and checking. Copyright 2007 ACM."
"Kitagawa H., Watanabe Y." $ "Stream data management based on integration of a stream processing engine and databases" $ "Recent developments in network and sensor device technologies enable us to easily obtain real-world information, such as locations of moving objects, weather information, news, and stock prices. These data are continuously supplied, and they are regarded as data streams. Because of the dramatical increase of streaming data, their management and utilization has become more and more important. This paper describes a data stream management system named Harmonica. Harmonica employs an architecture combining our stream processing engine named Stream-Spinner and relational DBMSs. Based on the architecture, the system processes both continuous queries and traditional one-shot queries. Moreover, Harmonica supports continuous persistence requirements for streaming data as well as queries including selection, join, projection, and user-defined functions over data streams. Users can also specify continuous queries that integrate streaming data and persistent data stored in databases. Using the Harmonica API, users can develop a variety of applications coping with different continuous steaming data and data stored in databases. Our system can be deployed in network environments to achieve efficient and dependable distributed stream processing. © 2007 IEEE."
"Woemdl W., Yousef H." $ "An adaptation manager for personalized mobile web searches" $ "Context-aware and personalized information access becomes more and more important, especially in a mobile scenario. In this paper, we present an Adaptation Manager which customizes Web searches to a user's context and profile attributes. The approach allows for reuse of personal information for different services such as the Google Web Service API. We identify personalization components as parts of our Adaptation Manager and explain the design of the system. We have also implemented the most important parts of the system and thereby show the usability of the approach. Our solution is extensible, for example to incorporate a rule system to (semi-)automatically switch between services."
"Lim S.C., Lowe S., Koempel J." $ "Application of visual programming to Web mash up development" $ "The ongoing adoption of the latest Web development patterns such as AJAX is helping to enhance the user experience on the Web. Moreover, there is now API-based support from various vendors that allow seamless fusion of disparate data sources into a single application. However, the barrier for Web designers to integrate such features into their Web applications remains high. This hampers a wider proliferation of such novel Web applications. In this paper, we conduct an experiment to see whether visual programming is appropriate for allowing Web designers integrate the aforementioned features. For the experiment, we have developed a prototype, tentatively named WIPER that allows Web designers to incorporate pre-built JavaScript components into live Web pages using drag-and-drop. We combined rapid revision with usability testing to iteratively advance our prototype. Working with users, we have learned that with some targeted refinements, visual programming paradigm can be very effective in achieving our goal. © Springer-Verlag Berlin Heidelberg 2007."
"Stylos J., Clarke S." $ "Usability implications of requiring parameters in objects' constructors" $ "The usability of APIs is increasingly important to programmer productivity. Based on experience with usability studies of specific APIs, techniques were explored for studying the usability of design choices common to many APIs. A comparative study was performed to assess how professional programmers use APIs with required parameters in objects' constructors as opposed to parameterless ""default"" constructors. It was hypothesized that required parameters would create more usable and self-documenting APIs by guiding programmers toward the correct use of objects and preventing errors. However, in the study, it was found that, contrary to expectations, programmers strongly preferred and were more effective with APIs that did not require constructor parameters. Participants' behavior was analyzed using the cognitive dimensions framework, and revealing that required constructor parameters interfere with common learning strategies, causing undesirable premature commitment. © 2007 IEEE."
"Nirnimesh, Harish P., Narayanan P.J." $ "Garuda: A scalable tiled display wall using commodity PCs" $ "Cluster-based tiled display walls can provide cost-effective and scalable displays with high resolution and a large display area. The software to drive them needs to scale too if arbitrarily large displays are to be built. Chromium is a popular software API used to construct such displays. Chromium transparently renders any OpenGL application to a tiled display by partitioning and sending individual OpenGL primitives to each client per frame. Visualization applications often deal with massive geometric data with millions of primitives. Transmitting them every frame results in huge network requirements that adversely affect the scalability of the system. In this paper, we present Garuda, a client-server-based display wall framework that uses off-the-shelf hardware and a standard network. Garuda Is scalable to large tile configurations and massive environments. It can transparently render any application built using the Open Scene Graph (OSG) API to a tiled display without any modification by the user. The Garuda server uses an object-based scene structure represented using a scene graph. The server determines the objects visible to each display tile using a novel adaptive algorithm that culls the scene graph to a hierarchy of frustums. Required parts of the scene graph are transmitted to the clients, which cache them to exploit the interframe redundancy. A multicast-based protocol is used to transmit the geometry to exploit the spatial redundancy present in tiled display systems. A geometry push philosophy from the server helps keep the clients in sync with one another. Neither the server nor a client needs to render the entire scene, making the system suitable for interactive rendering of massive models. Transparent rendering is achieved by intercepting the cull, draw, and swap functions of OSG and replacing them with our own. We demonstrate the performance and scalability of the Garuda system for different configurations of display wall. We also show that the server and network loads grow sublinearly with the increase in the number of tiles, which makes our scheme suitable to construct very large displays. © 2007 IEEE."
"Xie T., Pei J." $ "MAPO: Mining API usages from open source repositories" $ "To improve software productivity, when constructing new software systems, developers often reuse existing class libraries or frameworks by invoking their APIs. Those APIs, however, are often complex and not well documented, posing barriers for developers to use them in new client code. To get familiar with how those APIs are used, developers may search the Web using a general search engine to find relevant documents or code examples. Developers can also use a source code search engine to search open source repositories for source files that use the same APIs. Nevertheless, the number of returned source files is often large. It is difficult for developers to learn API usages from a large number of returned results. In order to help developers understand API usages and write API client code more effectively, we have developed an API usage mining framework and its supporting tool called MAPO (for Mining API usages from Open source repositories). Given a query that describes a method, class, or package for an API, MAPO leverages the existing source code search engines to gather relevant source files and conducts data mining. The mining leads to a short list of frequent API usages for developers to inspect. MAPO currently consists of five components: a code search engine, a source code analyzer, a sequence preprocessor, a frequent sequence miner, and a frequent sequence post processor. We have examined the effectiveness of MAPO using a set of various queries. The preliminary results show that the framework is practical for providing informative and succinct API usage patterns. Copyright 2006 ACM."
"Ball T., Bounimova E., Cook B., Levin V., Lichtenberg J., McGarvey C., Ondrusek B., Rajamani S.K., Ustuner A." $ "Thorough static analysis of device drivers" $ "Bugs in kernel-level device drivers cause 85% of the system crashes in the Windows XP operating system [44]. One of the sources of these errors is the complexity of the Windows driver API itself: programmers must master a complex set of rules about how to use the driver API in order to create drivers that are good clients of the kernel. We have built a static analysis engine that finds API usage errors in C programs. The Static Driver Verifier tool (SDV) uses this engine to find kernel API usage errors in a driver. SDV includes models of the OS and the environment of the device driver, and over sixty API usage rules. SDV is intended to be used by driver developers ""out of the box."" Thus, it has stringent requirements: (1) complete automation with no input from the user, (2) a low rate of false errors. We discuss the techniques used in SDV to meet these requirements, and empirical results from running SDV on over one hundred Windows device drivers."
"Holmes R., Walker R.J., Murphy G.C." $ "Approximate structural context matching: An approach to recommend relevant examples" $ "When coding to an application programming interface (API), developers often encounter difficulties, unsure of which class to subclass, which objects to instantiate, and which methods to call. Example source code that demonstrates the use of the API can help developers make progress on their task. This paper describes an approach to provide such examples in which the structure of the source code that the developer is writing is matched heuristically to a repository of source code that uses the API. The structural context needed to query the repository is extracted automatically from the code, freeing the developer from learning a query language or from writing their code in a particular style. The repository is generated automatically from existing applications, avoiding the need for handcrafted examples. We demonstrate that the approach is effective, efficient, and more reliable than traditional alternatives through four empirical studies. © 2006 IEEE."
"Stylos J." $ "Informing API design through usability studies of API design choices: A research abstract" $ "Using APIs is a common and often difficult task for developers. Successful API designs can guide users of an API and reduce their dependence on documentation, however API design is far from a science. Usability lab studies have been shown to be successful at improving the usability of specific APIs, however these are expensive and not always possible to run for every API. This paper describes an approach to generalize from studies of specific APIs to investigate the usability impact of design choices that commonly arise in the creation of APIs. Based on these results we will inform the design of many new APIs. A preliminary usability study of whether or not to require constructor parameters confirms our belief that the answer to common design decisions is not always obvious, and making the wrong choice can have a strong negative impact on usability for large groups of API users. © 2006 IEEE."
"Lobato C., Garcia A., Lucena C., Romanovsky A." $ "A modular implementation framework for code mobility" $ "With the growing popularity of open distributed applications, mobile agents have naturally emerged as the fundamental technique for tackling the complexity of the emerging applications. However, the pervasive nature of code mobility issues implies that their implementation cannot be modularized based only on object-oriented (OO) abstractions and mechanisms. In fact, programmers of complex mobile agent systems frequently evidence the presence of mobility tangling and scattering in the modules of their systems. Despite these modularity breakdowns caused by code mobility, the developers have mostly relied on OO application programming interfaces (APIs) from mobility platforms and on the Java programming language. As a consequence, there is a pressing need for empowering developers with a modular implementation framework that supports a transparent, flexible incorporation of code mobility-specific capabilities into their applications. This paper presents an aspect-oriented software framework, called AspectM, that ensures: (1) improved modularization of the code mobility issues, (2) a seamless introduction of code mobility into stationary agents, and (3) overall enhanced variability of the mobile agent systems, such as flexible integration of these systems with distinct mobility platforms. The usefulness and usability of the AspectM framework has been assessed in the context of two medium-sized case studies from different application domains, and through its composition with two mobility platforms. Copyright 2006 ACM."
"Lobato C., Garcia A., Lucena C., Romanovsky A." $ "A modular implementation framework for code mobility" $ "With the growing popularity of open distributed applications, mobile agents have naturally emerged as the fundamental technique for tackling the complexity of the emerging applications. However, the pervasive nature of code mobility issues implies that their implementation cannot be modularized based only on object-oriented (OO) abstractions and mechanisms. In fact, programmers of complex mobile agent systems frequently evidence the presence of mobility tangling and scattering in the modules of their systems. Despite these modularity breakdowns caused by code mobility, the developers have mostly relied on OO application programming interfaces (APIs) from mobility platforms and on the Java programming language. As a consequence, there is a pressing need for empowering developers with a modular implementation framework that supports a transparent, flexible incorporation of code mobility-specific capabilities into their applications. This paper presents an aspectoriented software framework, called AspectM, that ensures: (1) improved modularization of the code mobility issues, (2) a seamless introduction of code mobility into stationary agents, and (3) overall enhanced variability of the mobile agent systems, such as flexible integration of these systems with distinct mobility platforms. The usefulness and usability of the AspectM framework has been assessed in the context of two medium-sized case studies from different application domains, and through its composition with two mobility platforms. Copyright 2006 ACM."
"[No author name available]" $ "Proceedings of the 3rd International Conference on Mobile Technology, Applications and Systems" $ "The proceedings contain 70 papers. The topics discussed include: conception and simulation of energy-efficient AODV protocol in ad hoc networks, enabling seamless vertical handovers using unified link-layer API, context handling in a pervasive computing system framework, backbone-based location-aided routing algorithm to reduce control packets of AODV protocol, performance of a multiband impulse radio UWB architecture, design and applications of wireless SET protocol, challenges in multi-mode transmitter design, towards implicit interaction by using wearable interaction device sensors for more than one task, mobile phones as tool to increase communication and location awareness of users, cyberanthropology of mobility, developing design guidelines for context-aware mobile applications, usability guidelines for designing mobile learning portals, network centric photorealistic mixed reality on mobile devices, and signwriting on mobile phones for the deaf."
"Storz O., Friday A., Davies N." $ "Supporting content scheduling on situated public displays" $ "There is increasing interest in creating networks of situated public displays that offer novel forms of interaction and rich media content-often as work towards a vision of ubiquitous computing or ambient multimedia. In this paper, we present an infrastructure developed as part of the e-Campus project that is designed to support the coordinated scheduling of rich media content on networks of situated public displays. The design of the system was informed by an iterative process of developing, deploying and evaluating a set of three technology probes. The resulting system provides flexible support for the construction of domain-specific scheduling approaches on top of a common, domain-independent API. Using this approach, we are able to support a combination of both statically scheduled content and interactive content across multiple displays. The API provides support for transactional semantics, allowing developers of schedulers to reliably schedule content across displays in the presence of conflicts and failures without negative impact on running applications. © 2006 Elsevier Ltd. All rights reserved."
"Worringen J." $ "Self-adaptive hints for collective I/O" $ "The processing of MPI-IO operations can be controlled via the MPI API using file hints, which are passed to the MPI library as MPI info objects. A file hint can affect how the MPI library accesses the file on the file system level, it can set buffer sizes, turn special optimizations on and off or whatever parameters the MPI implementation provides. However, experience shows that file hints are rarely used for reasons that will be discussed in the paper. We present a new approach which dynamically determines the optimal setting for file hints related to collective MPI-IO operations. The chosen settings adapt to the actual file access pattern, the topology of the MPI processes and the available memory resources and consider the characteristics of the underlying file system. We evaluate our approach which has been implemented in MPI/SX, NEC's MPI implementation for the SX series of vector supercomputers. © Springer-Verlag Berlin Heidelberg 2006."
"Kimpe D., Vandewalle S., Poedts S." $ "On the usability of high-level parallel IO in unstructured grid simulations" $ "For this poster, the usability of the two most common IO libraries for parallel IO was evaluated, and compared against a pure MPI-IO implementation. Instead of solely focusing on the raw transfer bandwidth achieved, API issues such as data preparation and call overhead were also taken into consideration. The access pattern resulting from parallel IO in unstructured grid applications, which is also one of the hardest patterns to optimize, was examined. © Springer-Verlag Berlin Heidelberg 2006."
"Sunderraman R., Dogdu E., Madiraju P., Malladi L." $ "A java API for global querying and updates for a system of databases" $ "In this paper, we present the design of system of databases (SyDb). We also give the design and implementation of a Java API for global querying and updates on the SyDb. The databases may be heterogeneous. The API allows for queries and updates that have global references to schema elements of multiple databases to be executed in a seamless manner. The API can be used to develop collaborative applications that need access to several independent databases on the network. One such collaborative application, called the Calendar application, is illustrated in the paper. In this application each individual keeps their schedule information in their personal database. The users can schedule meetings with others, view others schedules, cancel meetings, etc. We implement the API using direct JDBC connections to databases. Copyright 2005 ACM."
"Compton M." $ "Stenning's protocol implemented in UDP and verified in Isabelle" $ "This paper is about the mechanical verification of UDP based network programs. It uses the UDP portion of a formal model of the Internet protocols TCP (Transmission Control Protocol) and UDP (User Datagram Protocol). The model includes asynchronous message passing, message loss and host failure. The model is based around the sockets library, the primary API used for writing UDP and TCP based applications. This paper demonstrates that formal, machine-checked, proof is possible in the UDP model by presenting the proof of a safety property for an implementation of Stenning's Protocol. The protocol is implemented in a fragment of the OCaml language, using the sockets library for UDP network communication. The entire development including the safety proof is carried out in the proof assistant Isabelle, this assures soundness. Thus this paper demonstrates that it is possible to machine verify very concrete representations of distributed programs in a detailed semantics that accurately reflects the programs execution environment. Previously only abstract representations of this protocol have been machine verified. The proof, based on an implementation, provides a contrast to other verifications. © 2005, Australian Computer Society, Inc."
"Bruni R., Ferrari G., Melgratti H., Montanari U., Strollo D., Tuosto E." $ "From theory to practice in transactional composition of Web Services" $ "We address the problem of composing Web Services in long-running transactional business processes, where compensations must be dealt with appropriately. The framework presented in this paper is a Java API called Java Transactional Web Services (JTWS), which provides suitable primitives for wrapping and invoking Web Services as activities in long-running transactions. JTWS adheres to a process calculi formalisation of long-running transactions, called Naïve Sagas, which fixes unambiguously the implemented compensation policy. In particular, the primitives provided by JTWS are in one-to-one correspondence with the primitives of Sagas, and they are abstract enough to hide the complex details of their realization, thus favouring usability. Moreover, JTWS orchestrates business processes in a distributed way. © Springer-Verlag Berlin Heidelberg 2005."
"Chanda A., Elmeleegy K., Cox A.L., Zwaenepoel W." $ "Causeway: Support for controlling and analyzing the execution of multi-tier applications" $ "Causeway provides runtime support for the development of distributed meta-applications. These meta-applications control or analyze the behavior of multi-tier distributed applications such as multi-tier web sites or web services. Examples of meta-applications include multi-tier debugging, fault diagnosis, resource tracking, prioritization, and security enforcement. Efficient online implementation of these meta-applications requires meta-data to be passed between the different program components. Examples of metadata corresponding to the above meta-applications are request identifiers, priorities or security principal identifiers. Causeway provides the infrastructure for injecting, destroying, reading, and writing such metadata. The key functionality in Causeway is forwarding the metadata associated with a request at so-called transfer points, where the execution of that request gets passed from one component to another. This is done automatically for system-visible channels, such as pipes or sockets. An API is provided to implement the forwarding of metadata at system-opaque channels such as shared memory. We describe the design and implementation of Causeway, and we evaluate its usability and performance. Causeway's low overhead allows it to be present permanently in production systems. We demonstrate its usability by showing how to implement, in 150 lines of code and without modification to the application, global priority enforcement in a multi-tier dynamic web server. © IFIP International Federation for Information Processing 2005."
"Marchesini J., Smith S.W., Zhao M." $ "Keyjacking: The surprising insecurity of client-side SSL" $ "In theory, PKI can provide a flexible and strong way to authenticate users in distributed information systems. In practice, much is being invested in realizing this vision via client-side SSL and various client keystores. However, whether this works depends on whether what the machines do with the private keys matches what the humans think they do: whether a server operator can conclude from an SSL request authenticated with a user's private key that the user was aware of and approved that request. Exploring this vision, we demonstrate via a series of experiments that this assumption does not hold with standard desktop tools, even if the browser user does all the right things. A fundamental rethinking of the trust, usage, and storage model might result in more effective tools for achieving the PKI vision. © 2004 Elsevier Ltd. All rights reserved."
"Greenberg J.P., Mock S., Bhatia K., Katz M., Bruno G., Sacerdoti F., Papadopoulos P., Baldridge K.K." $ "Incorporation of middleware and grid technologies to enhance usability in computational chemistry applications" $ "High performance computing, storage, visualization, and database infrastructures are increasing in complexity as scientists move towards grid-based computing. This evolution of computing infrastructure has the effect of pushing breakthrough computational capabilities beyond the reach of domain scientists. In this work, we discuss a workflow management system that allows portal construction that is fully integrated with emerging grid standards but can be dynamically reconfigured. By defining an XML schema to describe both resources, application codes and interfaces, we will enable a ""pluggable"" event-driven model where grid-enabled services can be composed to form elaborate pipelines of simulation, and visual analysis. © 2004 Elsevier B.V. All rights reserved."
"Clarke S." $ "Measuring API Usability" $ "The techniques used to design the usability of APIs that move with .NET are described. The best way to design usable graphical user interfaces (GUI) or APIs is to follow a user-centered design approach. APIs are reviewed periodically by examining the code samples and determining whether or not developers would be comfortable writing the code in each of the samples. The cognitive dimensions framework can also be used to describe the usability of APIs and to gather feedback from customers."
"Zheng Z., Sepehri N." $ "A CORBA-based distributed real-time crane simulator with 3D visualization" $ "The development of a simulator for a crane equipped with a claming device is reported in this paper. The real-time simulation is built upon a complete mathematical model of the claming machine with 3D graphics and interactive features. Common Object Request Broker Architecture (CORBA) technology is employed to distribute the calculation of the complex dynamic equations on a more powerful server, while relieving the -client computer to concentrate on graphics rendering, collision detection and control signal collection. The communication methods and concurrency model of both the client and the server are carefully selected to ensure reliability without compromising the speed. The server supports multiple users. Thus, more than one user can share the resource of a single server when they are connected to a network that supports Transmission Control Protocol (TCP) or Internet Protocol (IP). OpenGL is used as the graphics Application Programming Interface (API), Users can select different visual angle to watch the scene while operating the virtual machine."
"Jones H., Snyder M." $ "Robotic control & 3D GUIs" $ "A graphical user interface (GUI) based on the open GL 3D API used to operate global-positioning system (GPS)-enabled robots, is discussed. This basic technique is used to operate helicopters, submarines and space systems. The position sensing of the robot is accomplished with four GPS antennae that provide both position and altitude using differential carrier phase (DCPGPS) techniques."
"Sicilia M.-A., García E., Díaz P., Aedo I." $ "Extending relational data access programming libraries for fuzziness: The fJDBC framework" $ "Fuzzy relational databases have been extensively studied in recent years, resulting in several models and representation techniques, some of which have been implemented as software layers on top of diverse existing database systems. Fuzzy extensions to query languages and end-user query interfaces have also been developed, but the design of programming interfaces has not been properly addressed yet. In this paper, we describe a software framework called fJDBC that extends the Java Database Connectivity API by enabling fuzzy queries on existing relational databases, using externally-stored metadata. Since the main design objective of this extension is usability for existing database programmers, only a restricted subset of extensions (supported also by an extended object modelling notation) has been included. The overall design of the framework and some empirical results are also described. © Springer-Verlag Berlin Heidelberg 2002."
"Bubak M., Kurzyniec D., Luszczek P., Sunderam V." $ "Creating Java to native code interfaces with Janet" $ "Java is growing in appropriateness and usability for high performance computing. With this increasing adoption, issues relating to combining Java with existing codes in other languages become more important. The Java Native Interface (JNI) API is portable but too inconvenient to be used directly owing to its low-level API. This paper presents Janet - a highly expressive Java language extension and preprocessing tool that enables convenient integration of native code with Java programs. The Janet methodology overcomes some of the limitations of JNI and generates Java programs that execute with little or no degradation despite the flexibility and generality of the interface."
"Aizman A." $ "Easy concurrency" $ "Advances in technology raise expectations. As far as software engineering is concerned, the common expectation is that coding and deploying applications is going to be simple. It seems, though, that software engineering is not getting easier, and the complexity moves to an application domain. One of the sources of complexity is an application concurrency. It is not an uncommon development practice that concurrency and transaction management in multi-user, multi-threaded, event-driven applications are postponed until after most of the required functionality is implemented. This situation has various explanations. On the one hand, business logic may require access and modification of large sets of interconnected application objects. On the other, testing and stress-testing of this logic becomes possible only at advanced stages of product development. At these stages, increasing lock granularities may appear to be less ""ex-pensive"" than debugging race conditions and deadlocks. Coarse-grained locking has, of course, an adverse effect on application scalability. Declaring rules of concurrency outside of the application may solve part of the problem. This paper presents an approach allowing developers to define concurrency in application-specific terms, design it in the early stages of development, and implement it using a documented API of the concurrency engine (CE). Simple notation makes it possible to record concurrency specifications in terms of application operations, relationships between application resources, and synchronization conflicts between operations. These concepts are demonstrated on examples. The final sections include the CE UML diagram, notes on API usage, and performance benchmarks. © Springer-Verlag 2001."
"Whittaker J.A." $ "Software's invisible users" $ "The challenges of dealing with different types of users are discussed, which provide software systems with input. These include human users, operating systems (OS) users, API users, and file system users. When designing software, programmers must decide on the inputs to verify. Testers must also simulate anomalous inputs that create problems for the system."
"Meijer H., Poll E." $ "Towards a full formal specification of the javacard API" $ "This paper reports on ongoing work to develop a formal specification of the JavaCard API using the specification language JML. It discusses the specification of the JCSystem class, which deals with the JavaCard firewall, (atomic) transactions and transient objects. The JCSystem class seems to be the hardest class in the API to specify, and it is closely connected with some of the peculiarities of JavaCard as opposed to Java. © Springer-Verlag Berlin Heidelberg 2001."
"Hale M.A., Mavris D.N." $ "Lean-server foundation for collaborative design" $ "The design framework research community utilizes the Internet as a facilitator for collaborative activities. The ability to support coordination and high-level communication is imperative in any collaboratory. A novel approach using lean-servers is an alternative method for providing a functional server-side computing model that meets the implementation requirements for a collaboratory. The server brokers Internet requests directly within a design application by providing a gateway to the application's programming interface using a HyperText Transfer Protocol compliant layer. This allows requests to be managed directly by the application rather than requiring auxiliary services. Macros are used to provide content and context sensitive responses. A prototype system, called the Systems Programming Architecture for Collaborative Engineering, is described as one scenario for implementing the lean-server technology. Usability of the approach is demonstrated through a Design of Experiments example that is representative of modern design methods. This example also demonstrates coordination because it executes asynchronously with multi-user intervention at any time during the process. In hindsight, the lean-server approach is an enabling technology for collaborative design and focuses future research on methods for communicating reasoning, experience, and other information during design decision-making processes."
"Hoffman D., Strooper P." $ "Prose + test cases = specifications" $ "The rise of component-based software development has created a need for API documentation. Experience has shown that it is hard to create and maintain precise and readable documentation. Prose documentation can provide a good overview but lacks precision. Formal methods offer precision but the resulting documentation is expensive to write and modify. Worse, few developers have the skill or inclination to read formal documentation. We present a pragmatic solution to the problem of API documentation. We augment the current prose documentation with test cases, including expected outputs, and use the prose plus the test cases as the documentation. Typically there are one or two simple test cases for each likely question about API behavior. With this approach, the documentation is precise, albeit partial. Consistency between code and documentation is guaranteed by running the test cases. The readability of the test cases is of paramount importance because communication with API users is their primary purpose. We present a test script language that supports compact, readable test cases and generation of test drivers, and illustrate the approach with a detailed case study."
"Succi G., Eberlein A., Yip J., Luc K., Nguy M., Tan Y." $ "Design of Holmes: a tool for domain analysis and engineering" $ "Holmes is a collection of tools that support the Sherlock domain analysis & engineering (DA&E) methodology. Holmes plans to improve on existing DA&E tools by providing a more usable interface and making better use of existing technologies and standards. Usability is achieved through automation and the use of a critiquing system. The tool is developed in Java to allow easier upgrading to new technologies and standards by updating a server to deploy new versions. Internal data exchange is achieved using the JavaSpaces API while external data exchange uses the Extensible Markup Language (XML)."
"Martin David H., Martin Johnny" $ "Java and digital images" $ "Interfacing Java applications to a video-capture device poses a special challenge because there is currently no easy way to access the camera from Java. The Java virtual machine presents a barrier between applications and C/C++ application programming interfaces (API) used to access the video camera. To access these APIs from Java, one must not only write JNI methods, but must also address image conversion problems, performance issues, and thread synchronization. The three approaches, no integration, loose integration, and full integration, to incorporate video or image capture into a Java application and their abilities/complexity tradeoffs are discussed."
"McCartney T.P." $ "A usability study of end-user construction of distributed multimedia applications" $ "This paper describes an empirical study of end-users that tested the usability of The Programmers' Playground graphical environment. The Programmers' Playground is a software library and run-time system for constructing distributed multimedia applications. Playground's graphical environment enables end-users to create direct-manipulation graphical user interfaces (GUIs) and to dynamically configure communication among distributed application components. In this study, 28 end-users with no prior experience in distributed computing or user interface construction were timed and evaluated on several tasks using our graphical environment. Tasks included the use of direct and indirect constraint relationships, visual configuration of distributed applications, and graphical user interface construction. The results show that a wide variety of end-users (i.e., not just programmers) can learn and apply these concepts, utilizing our graphical environment to construct distributed multimedia applications. © Springer-Verlag 1997."
"Ketchpel S.P., Garcia-Molina H., Paepcke A." $ "Shopping models: a flexible architecture for information commerce" $ "In a digital library, there are many different interaction models between customers and information providers or merchants. Subscriptions, sessions, pay-per-view, shareware, and pro-paid vouchers are different models that each have different properties. A single merchant may use several of them. Yet if a merchant wants to support multiple models, there is a substantial amount of work to implement each one. In this paper, we formalize the shopping models which represent these different modes of consumer to merchant interaction. In addition to developing the overall architecture, we define the application program interfaces (API) to interact with the models. We show how a small number of primitives can be used to construct a wide range of shopping models that a digital library can support, and provide examples of the shopping models in operation, demonstrating their flexibility. Two models have been implemented as part of the Stanford Digital Library Project, to begin validating re-usability of key architectural components."
"Oliveira J.L., Martins J.A." $ "A management architecture based on network topology information" $ "This paper describes the development of a formalism to represent Network Topology Information that provides hierarchical views of the network elements distribution, usable with advantage by management applications. It reviews some topology discovery tools and emphasizes the lack of a common methodology to represent the network cabling and organize the agent distribution information. The formalism, consisting on a descriptive language and on an object-oriented topology base, is described and some application areas, where this information can be used, are pointed. Finally it presents a Management API, as part of the overall architecture, that helps to show the usability of the Topology Information Base. © 1994, Plenum Publishing Corporation. All rights reserved."
"Hilgert L.D." $ "Software Reviews: Test plus" $ "TEST PLUS is a software package based on the Adult Personality Inventory (API). It allows the API user to make decisions based on a systematic comparison of 25 personality factors to a database of up to 100 other examinees or to a “referenced model” constructed by the evaluator. This makes TEST PLUS extremely useful in a variety of settings. © 1987, Sage Publications. All rights reserved."
